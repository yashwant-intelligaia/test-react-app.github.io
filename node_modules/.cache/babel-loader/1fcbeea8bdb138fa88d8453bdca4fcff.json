{"ast":null,"code":"\"use strict\";\n\nvar fs = require('fs'); // useful stuff\n\n\nvar inherits = function inherits(cls, superCtor, statics, prototype) {\n  // eslint-disable-next-line no-underscore-dangle\n  cls.super_ = superCtor;\n\n  if (!prototype) {\n    prototype = statics;\n    statics = null;\n  }\n\n  if (statics) {\n    Object.keys(statics).forEach(function (i) {\n      Object.defineProperty(cls, i, Object.getOwnPropertyDescriptor(statics, i));\n    });\n  }\n\n  var properties = {\n    constructor: {\n      value: cls,\n      enumerable: false,\n      writable: false,\n      configurable: true\n    }\n  };\n\n  if (prototype) {\n    Object.keys(prototype).forEach(function (i) {\n      properties[i] = Object.getOwnPropertyDescriptor(prototype, i);\n    });\n  }\n\n  cls.prototype = Object.create(superCtor.prototype, properties);\n}; // eslint-disable-next-line no-control-regex\n\n\nvar xmlDecodeRegex = /[<>&'\"\\x7F\\x00-\\x08\\x0B-\\x0C\\x0E-\\x1F]/;\nvar utils = {\n  nop: function nop() {},\n  promiseImmediate: function promiseImmediate(value) {\n    return new Promise(function (resolve) {\n      if (global.setImmediate) {\n        setImmediate(function () {\n          resolve(value);\n        });\n      } else {\n        // poorman's setImmediate - must wait at least 1ms\n        setTimeout(function () {\n          resolve(value);\n        }, 1);\n      }\n    });\n  },\n  inherits: inherits,\n  dateToExcel: function dateToExcel(d, date1904) {\n    return 25569 + d.getTime() / (24 * 3600 * 1000) - (date1904 ? 1462 : 0);\n  },\n  excelToDate: function excelToDate(v, date1904) {\n    var millisecondSinceEpoch = Math.round((v - 25569 + (date1904 ? 1462 : 0)) * 24 * 3600 * 1000);\n    return new Date(millisecondSinceEpoch);\n  },\n  parsePath: function parsePath(filepath) {\n    var last = filepath.lastIndexOf('/');\n    return {\n      path: filepath.substring(0, last),\n      name: filepath.substring(last + 1)\n    };\n  },\n  getRelsPath: function getRelsPath(filepath) {\n    var path = utils.parsePath(filepath);\n    return \"\".concat(path.path, \"/_rels/\").concat(path.name, \".rels\");\n  },\n  xmlEncode: function xmlEncode(text) {\n    var regexResult = xmlDecodeRegex.exec(text);\n    if (!regexResult) return text;\n    var result = '';\n    var escape = '';\n    var lastIndex = 0;\n    var i = regexResult.index;\n\n    for (; i < text.length; i++) {\n      var charCode = text.charCodeAt(i);\n\n      switch (charCode) {\n        case 34:\n          // \"\n          escape = '&quot;';\n          break;\n\n        case 38:\n          // &\n          escape = '&amp;';\n          break;\n\n        case 39:\n          // '\n          escape = '&apos;';\n          break;\n\n        case 60:\n          // <\n          escape = '&lt;';\n          break;\n\n        case 62:\n          // >\n          escape = '&gt;';\n          break;\n\n        case 127:\n          escape = '';\n          break;\n\n        default:\n          {\n            if (charCode <= 31 && (charCode <= 8 || charCode >= 11 && charCode !== 13)) {\n              escape = '';\n              break;\n            }\n\n            continue;\n          }\n      }\n\n      if (lastIndex !== i) result += text.substring(lastIndex, i);\n      lastIndex = i + 1;\n      if (escape) result += escape;\n    }\n\n    if (lastIndex !== i) return result + text.substring(lastIndex, i);\n    return result;\n  },\n  xmlDecode: function xmlDecode(text) {\n    return text.replace(/&([a-z]*);/g, function (c) {\n      switch (c) {\n        case '&lt;':\n          return '<';\n\n        case '&gt;':\n          return '>';\n\n        case '&amp;':\n          return '&';\n\n        case '&apos;':\n          return '\\'';\n\n        case '&quot;':\n          return '\"';\n\n        default:\n          return c;\n      }\n    });\n  },\n  validInt: function validInt(value) {\n    var i = parseInt(value, 10);\n    return !Number.isNaN(i) ? i : 0;\n  },\n  isDateFmt: function isDateFmt(fmt) {\n    if (!fmt) {\n      return false;\n    } // must remove all chars inside quotes and []\n\n\n    fmt = fmt.replace(/\\[[^\\]]*]/g, '');\n    fmt = fmt.replace(/\"[^\"]*\"/g, ''); // then check for date formatting chars\n\n    var result = fmt.match(/[ymdhMsb]+/) !== null;\n    return result;\n  },\n  fs: {\n    exists: function exists(path) {\n      return new Promise(function (resolve) {\n        fs.access(path, fs.constants.F_OK, function (err) {\n          resolve(!err);\n        });\n      });\n    }\n  },\n  toIsoDateString: function toIsoDateString(dt) {\n    return dt.toIsoString().subsstr(0, 10);\n  }\n};\nmodule.exports = utils;","map":{"version":3,"sources":["../../../lib/utils/utils.js"],"names":["fs","require","inherits","cls","prototype","statics","Object","properties","constructor","value","enumerable","writable","configurable","superCtor","xmlDecodeRegex","utils","nop","promiseImmediate","global","setImmediate","resolve","setTimeout","dateToExcel","d","date1904","excelToDate","millisecondSinceEpoch","Math","v","parsePath","last","filepath","path","name","getRelsPath","xmlEncode","regexResult","result","escape","lastIndex","i","text","charCode","xmlDecode","validInt","parseInt","Number","isDateFmt","fmt","exists","toIsoDateString","dt","module"],"mappings":"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","sourcesContent":["const fs = require('fs');\r\n\r\n// useful stuff\r\nconst inherits = function(cls, superCtor, statics, prototype) {\r\n  // eslint-disable-next-line no-underscore-dangle\r\n  cls.super_ = superCtor;\r\n\r\n  if (!prototype) {\r\n    prototype = statics;\r\n    statics = null;\r\n  }\r\n\r\n  if (statics) {\r\n    Object.keys(statics).forEach(i => {\r\n      Object.defineProperty(cls, i, Object.getOwnPropertyDescriptor(statics, i));\r\n    });\r\n  }\r\n\r\n  const properties = {\r\n    constructor: {\r\n      value: cls,\r\n      enumerable: false,\r\n      writable: false,\r\n      configurable: true,\r\n    },\r\n  };\r\n  if (prototype) {\r\n    Object.keys(prototype).forEach(i => {\r\n      properties[i] = Object.getOwnPropertyDescriptor(prototype, i);\r\n    });\r\n  }\r\n\r\n  cls.prototype = Object.create(superCtor.prototype, properties);\r\n};\r\n\r\n// eslint-disable-next-line no-control-regex\r\nconst xmlDecodeRegex = /[<>&'\"\\x7F\\x00-\\x08\\x0B-\\x0C\\x0E-\\x1F]/;\r\nconst utils = {\r\n  nop() {},\r\n  promiseImmediate(value) {\r\n    return new Promise(resolve => {\r\n      if (global.setImmediate) {\r\n        setImmediate(() => {\r\n          resolve(value);\r\n        });\r\n      } else {\r\n        // poorman's setImmediate - must wait at least 1ms\r\n        setTimeout(() => {\r\n          resolve(value);\r\n        }, 1);\r\n      }\r\n    });\r\n  },\r\n  inherits,\r\n  dateToExcel(d, date1904) {\r\n    return 25569 + d.getTime() / (24 * 3600 * 1000) - (date1904 ? 1462 : 0);\r\n  },\r\n  excelToDate(v, date1904) {\r\n    const millisecondSinceEpoch = Math.round(\r\n      (v - 25569 + (date1904 ? 1462 : 0)) * 24 * 3600 * 1000\r\n    );\r\n    return new Date(millisecondSinceEpoch);\r\n  },\r\n  parsePath(filepath) {\r\n    const last = filepath.lastIndexOf('/');\r\n    return {\r\n      path: filepath.substring(0, last),\r\n      name: filepath.substring(last + 1),\r\n    };\r\n  },\r\n  getRelsPath(filepath) {\r\n    const path = utils.parsePath(filepath);\r\n    return `${path.path}/_rels/${path.name}.rels`;\r\n  },\r\n  xmlEncode(text) {\r\n    const regexResult = xmlDecodeRegex.exec(text);\r\n    if (!regexResult) return text;\r\n\r\n    let result = '';\r\n    let escape = '';\r\n    let lastIndex = 0;\r\n    let i = regexResult.index;\r\n    for (; i < text.length; i++) {\r\n      const charCode = text.charCodeAt(i);\r\n      switch (charCode) {\r\n        case 34: // \"\r\n          escape = '&quot;';\r\n          break;\r\n        case 38: // &\r\n          escape = '&amp;';\r\n          break;\r\n        case 39: // '\r\n          escape = '&apos;';\r\n          break;\r\n        case 60: // <\r\n          escape = '&lt;';\r\n          break;\r\n        case 62: // >\r\n          escape = '&gt;';\r\n          break;\r\n        case 127:\r\n          escape = '';\r\n          break;\r\n        default: {\r\n          if (charCode <= 31 && (charCode <= 8 || (charCode >= 11 && charCode !== 13))) {\r\n            escape = '';\r\n            break;\r\n          }\r\n          continue;\r\n        }\r\n      }\r\n      if (lastIndex !== i) result += text.substring(lastIndex, i);\r\n      lastIndex = i + 1;\r\n      if (escape) result += escape;\r\n    }\r\n    if (lastIndex !== i) return result + text.substring(lastIndex, i);\r\n    return result;\r\n  },\r\n  xmlDecode(text) {\r\n    return text.replace(/&([a-z]*);/g, c => {\r\n      switch (c) {\r\n        case '&lt;':\r\n          return '<';\r\n        case '&gt;':\r\n          return '>';\r\n        case '&amp;':\r\n          return '&';\r\n        case '&apos;':\r\n          return '\\'';\r\n        case '&quot;':\r\n          return '\"';\r\n        default:\r\n          return c;\r\n      }\r\n    });\r\n  },\r\n  validInt(value) {\r\n    const i = parseInt(value, 10);\r\n    return !Number.isNaN(i) ? i : 0;\r\n  },\r\n\r\n  isDateFmt(fmt) {\r\n    if (!fmt) {\r\n      return false;\r\n    }\r\n\r\n    // must remove all chars inside quotes and []\r\n    fmt = fmt.replace(/\\[[^\\]]*]/g, '');\r\n    fmt = fmt.replace(/\"[^\"]*\"/g, '');\r\n    // then check for date formatting chars\r\n    const result = fmt.match(/[ymdhMsb]+/) !== null;\r\n    return result;\r\n  },\r\n\r\n  fs: {\r\n    exists(path) {\r\n      return new Promise(resolve => {\r\n        fs.access(path, fs.constants.F_OK, err => {\r\n          resolve(!err);\r\n        });\r\n      });\r\n    },\r\n  },\r\n\r\n  toIsoDateString(dt) {\r\n    return dt.toIsoString().subsstr(0, 10);\r\n  },\r\n};\r\n\r\nmodule.exports = utils;\r\n"]},"metadata":{},"sourceType":"script"}