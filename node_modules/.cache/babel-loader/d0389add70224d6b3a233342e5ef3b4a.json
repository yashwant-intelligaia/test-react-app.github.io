{"ast":null,"code":"\"use strict\";\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nvar BaseXform = require('../../base-xform');\n\nvar CompositeXform = require('../../composite-xform');\n\nvar Range = require('../../../../doc/range');\n\nvar DatabarXform = require('./databar-xform');\n\nvar ExtLstRefXform = require('./ext-lst-ref-xform');\n\nvar FormulaXform = require('./formula-xform');\n\nvar ColorScaleXform = require('./color-scale-xform');\n\nvar IconSetXform = require('./icon-set-xform');\n\nvar extIcons = {\n  '3Triangles': true,\n  '3Stars': true,\n  '5Boxes': true\n};\n\nvar getTextFormula = function getTextFormula(model) {\n  if (model.formulae && model.formulae[0]) {\n    return model.formulae[0];\n  }\n\n  var range = new Range(model.ref);\n  var tl = range.tl;\n\n  switch (model.operator) {\n    case 'containsText':\n      return \"NOT(ISERROR(SEARCH(\\\"\".concat(model.text, \"\\\",\").concat(tl, \")))\");\n\n    case 'containsBlanks':\n      return \"LEN(TRIM(\".concat(tl, \"))=0\");\n\n    case 'notContainsBlanks':\n      return \"LEN(TRIM(\".concat(tl, \"))>0\");\n\n    case 'containsErrors':\n      return \"ISERROR(\".concat(tl, \")\");\n\n    case 'notContainsErrors':\n      return \"NOT(ISERROR(\".concat(tl, \"))\");\n\n    default:\n      return undefined;\n  }\n};\n\nvar getTimePeriodFormula = function getTimePeriodFormula(model) {\n  if (model.formulae && model.formulae[0]) {\n    return model.formulae[0];\n  }\n\n  var range = new Range(model.ref);\n  var tl = range.tl;\n\n  switch (model.timePeriod) {\n    case 'thisWeek':\n      return \"AND(TODAY()-ROUNDDOWN(\".concat(tl, \",0)<=WEEKDAY(TODAY())-1,ROUNDDOWN(\").concat(tl, \",0)-TODAY()<=7-WEEKDAY(TODAY()))\");\n\n    case 'lastWeek':\n      return \"AND(TODAY()-ROUNDDOWN(\".concat(tl, \",0)>=(WEEKDAY(TODAY())),TODAY()-ROUNDDOWN(\").concat(tl, \",0)<(WEEKDAY(TODAY())+7))\");\n\n    case 'nextWeek':\n      return \"AND(ROUNDDOWN(\".concat(tl, \",0)-TODAY()>(7-WEEKDAY(TODAY())),ROUNDDOWN(\").concat(tl, \",0)-TODAY()<(15-WEEKDAY(TODAY())))\");\n\n    case 'yesterday':\n      return \"FLOOR(\".concat(tl, \",1)=TODAY()-1\");\n\n    case 'today':\n      return \"FLOOR(\".concat(tl, \",1)=TODAY()\");\n\n    case 'tomorrow':\n      return \"FLOOR(\".concat(tl, \",1)=TODAY()+1\");\n\n    case 'last7Days':\n      return \"AND(TODAY()-FLOOR(\".concat(tl, \",1)<=6,FLOOR(\").concat(tl, \",1)<=TODAY())\");\n\n    case 'lastMonth':\n      return \"AND(MONTH(\".concat(tl, \")=MONTH(EDATE(TODAY(),0-1)),YEAR(\").concat(tl, \")=YEAR(EDATE(TODAY(),0-1)))\");\n\n    case 'thisMonth':\n      return \"AND(MONTH(\".concat(tl, \")=MONTH(TODAY()),YEAR(\").concat(tl, \")=YEAR(TODAY()))\");\n\n    case 'nextMonth':\n      return \"AND(MONTH(\".concat(tl, \")=MONTH(EDATE(TODAY(),0+1)),YEAR(\").concat(tl, \")=YEAR(EDATE(TODAY(),0+1)))\");\n\n    default:\n      return undefined;\n  }\n};\n\nvar opType = function opType(attributes) {\n  var type = attributes.type,\n      operator = attributes.operator;\n\n  switch (type) {\n    case 'containsText':\n    case 'containsBlanks':\n    case 'notContainsBlanks':\n    case 'containsErrors':\n    case 'notContainsErrors':\n      return {\n        type: 'containsText',\n        operator: type\n      };\n\n    default:\n      return {\n        type: type,\n        operator: operator\n      };\n  }\n};\n\nvar CfRuleXform = /*#__PURE__*/function (_CompositeXform) {\n  _inherits(CfRuleXform, _CompositeXform);\n\n  var _super = _createSuper(CfRuleXform);\n\n  function CfRuleXform() {\n    var _this;\n\n    _classCallCheck(this, CfRuleXform);\n\n    _this = _super.call(this);\n    _this.map = {\n      dataBar: _this.databarXform = new DatabarXform(),\n      extLst: _this.extLstRefXform = new ExtLstRefXform(),\n      formula: _this.formulaXform = new FormulaXform(),\n      colorScale: _this.colorScaleXform = new ColorScaleXform(),\n      iconSet: _this.iconSetXform = new IconSetXform()\n    };\n    return _this;\n  }\n\n  _createClass(CfRuleXform, [{\n    key: \"render\",\n    value: function render(xmlStream, model) {\n      switch (model.type) {\n        case 'expression':\n          this.renderExpression(xmlStream, model);\n          break;\n\n        case 'cellIs':\n          this.renderCellIs(xmlStream, model);\n          break;\n\n        case 'top10':\n          this.renderTop10(xmlStream, model);\n          break;\n\n        case 'aboveAverage':\n          this.renderAboveAverage(xmlStream, model);\n          break;\n\n        case 'dataBar':\n          this.renderDataBar(xmlStream, model);\n          break;\n\n        case 'colorScale':\n          this.renderColorScale(xmlStream, model);\n          break;\n\n        case 'iconSet':\n          this.renderIconSet(xmlStream, model);\n          break;\n\n        case 'containsText':\n          this.renderText(xmlStream, model);\n          break;\n\n        case 'timePeriod':\n          this.renderTimePeriod(xmlStream, model);\n          break;\n      }\n    }\n  }, {\n    key: \"renderExpression\",\n    value: function renderExpression(xmlStream, model) {\n      xmlStream.openNode(this.tag, {\n        type: 'expression',\n        dxfId: model.dxfId,\n        priority: model.priority\n      });\n      this.formulaXform.render(xmlStream, model.formulae[0]);\n      xmlStream.closeNode();\n    }\n  }, {\n    key: \"renderCellIs\",\n    value: function renderCellIs(xmlStream, model) {\n      var _this2 = this;\n\n      xmlStream.openNode(this.tag, {\n        type: 'cellIs',\n        dxfId: model.dxfId,\n        priority: model.priority,\n        operator: model.operator\n      });\n      model.formulae.forEach(function (formula) {\n        _this2.formulaXform.render(xmlStream, formula);\n      });\n      xmlStream.closeNode();\n    }\n  }, {\n    key: \"renderTop10\",\n    value: function renderTop10(xmlStream, model) {\n      xmlStream.leafNode(this.tag, {\n        type: 'top10',\n        dxfId: model.dxfId,\n        priority: model.priority,\n        percent: BaseXform.toBoolAttribute(model.percent, false),\n        bottom: BaseXform.toBoolAttribute(model.bottom, false),\n        rank: BaseXform.toIntValue(model.rank, 10, true)\n      });\n    }\n  }, {\n    key: \"renderAboveAverage\",\n    value: function renderAboveAverage(xmlStream, model) {\n      xmlStream.leafNode(this.tag, {\n        type: 'aboveAverage',\n        dxfId: model.dxfId,\n        priority: model.priority,\n        aboveAverage: BaseXform.toBoolAttribute(model.aboveAverage, true)\n      });\n    }\n  }, {\n    key: \"renderDataBar\",\n    value: function renderDataBar(xmlStream, model) {\n      xmlStream.openNode(this.tag, {\n        type: 'dataBar',\n        priority: model.priority\n      });\n      this.databarXform.render(xmlStream, model);\n      this.extLstRefXform.render(xmlStream, model);\n      xmlStream.closeNode();\n    }\n  }, {\n    key: \"renderColorScale\",\n    value: function renderColorScale(xmlStream, model) {\n      xmlStream.openNode(this.tag, {\n        type: 'colorScale',\n        priority: model.priority\n      });\n      this.colorScaleXform.render(xmlStream, model);\n      xmlStream.closeNode();\n    }\n  }, {\n    key: \"renderIconSet\",\n    value: function renderIconSet(xmlStream, model) {\n      // iconset is all primitive or all extLst\n      if (!CfRuleXform.isPrimitive(model)) {\n        return;\n      }\n\n      xmlStream.openNode(this.tag, {\n        type: 'iconSet',\n        priority: model.priority\n      });\n      this.iconSetXform.render(xmlStream, model);\n      xmlStream.closeNode();\n    }\n  }, {\n    key: \"renderText\",\n    value: function renderText(xmlStream, model) {\n      xmlStream.openNode(this.tag, {\n        type: model.operator,\n        dxfId: model.dxfId,\n        priority: model.priority,\n        operator: BaseXform.toStringAttribute(model.operator, 'containsText')\n      });\n      var formula = getTextFormula(model);\n\n      if (formula) {\n        this.formulaXform.render(xmlStream, formula);\n      }\n\n      xmlStream.closeNode();\n    }\n  }, {\n    key: \"renderTimePeriod\",\n    value: function renderTimePeriod(xmlStream, model) {\n      xmlStream.openNode(this.tag, {\n        type: 'timePeriod',\n        dxfId: model.dxfId,\n        priority: model.priority,\n        timePeriod: model.timePeriod\n      });\n      var formula = getTimePeriodFormula(model);\n\n      if (formula) {\n        this.formulaXform.render(xmlStream, formula);\n      }\n\n      xmlStream.closeNode();\n    }\n  }, {\n    key: \"createNewModel\",\n    value: function createNewModel(_ref) {\n      var attributes = _ref.attributes;\n      return _objectSpread(_objectSpread({}, opType(attributes)), {}, {\n        dxfId: BaseXform.toIntValue(attributes.dxfId),\n        priority: BaseXform.toIntValue(attributes.priority),\n        timePeriod: attributes.timePeriod,\n        percent: BaseXform.toBoolValue(attributes.percent),\n        bottom: BaseXform.toBoolValue(attributes.bottom),\n        rank: BaseXform.toIntValue(attributes.rank),\n        aboveAverage: BaseXform.toBoolValue(attributes.aboveAverage)\n      });\n    }\n  }, {\n    key: \"onParserClose\",\n    value: function onParserClose(name, parser) {\n      switch (name) {\n        case 'dataBar':\n        case 'extLst':\n        case 'colorScale':\n        case 'iconSet':\n          // merge parser model with ours\n          Object.assign(this.model, parser.model);\n          break;\n\n        case 'formula':\n          // except - formula is a string and appends to formulae\n          this.model.formulae = this.model.formulae || [];\n          this.model.formulae.push(parser.model);\n          break;\n      }\n    }\n  }, {\n    key: \"tag\",\n    get: function get() {\n      return 'cfRule';\n    }\n  }], [{\n    key: \"isPrimitive\",\n    value: function isPrimitive(rule) {\n      // is this rule primitive?\n      if (rule.type === 'iconSet') {\n        if (rule.custom || extIcons[rule.iconSet]) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }]);\n\n  return CfRuleXform;\n}(CompositeXform);\n\nmodule.exports = CfRuleXform;","map":{"version":3,"sources":["../../../../../../lib/xlsx/xform/sheet/cf/cf-rule-xform.js"],"names":["BaseXform","require","CompositeXform","Range","DatabarXform","ExtLstRefXform","FormulaXform","ColorScaleXform","IconSetXform","extIcons","getTextFormula","model","range","tl","getTimePeriodFormula","opType","type","operator","attributes","CfRuleXform","dataBar","extLst","formula","colorScale","iconSet","rule","xmlStream","dxfId","priority","percent","bottom","rank","aboveAverage","timePeriod","name","parser","Object","module"],"mappings":"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","sourcesContent":["const BaseXform = require('../../base-xform');\r\nconst CompositeXform = require('../../composite-xform');\r\n\r\nconst Range = require('../../../../doc/range');\r\n\r\nconst DatabarXform = require('./databar-xform');\r\nconst ExtLstRefXform = require('./ext-lst-ref-xform');\r\nconst FormulaXform = require('./formula-xform');\r\nconst ColorScaleXform = require('./color-scale-xform');\r\nconst IconSetXform = require('./icon-set-xform');\r\n\r\nconst extIcons = {\r\n  '3Triangles': true,\r\n  '3Stars': true,\r\n  '5Boxes': true,\r\n};\r\n\r\nconst getTextFormula = model => {\r\n  if (model.formulae && model.formulae[0]) {\r\n    return model.formulae[0];\r\n  }\r\n\r\n  const range = new Range(model.ref);\r\n  const {tl} = range;\r\n  switch (model.operator) {\r\n    case 'containsText':\r\n      return `NOT(ISERROR(SEARCH(\"${model.text}\",${tl})))`;\r\n    case 'containsBlanks':\r\n      return `LEN(TRIM(${tl}))=0`;\r\n    case 'notContainsBlanks':\r\n      return `LEN(TRIM(${tl}))>0`;\r\n    case 'containsErrors':\r\n      return `ISERROR(${tl})`;\r\n    case 'notContainsErrors':\r\n      return `NOT(ISERROR(${tl}))`;\r\n    default:\r\n      return undefined;\r\n  }\r\n};\r\n\r\nconst getTimePeriodFormula = model => {\r\n  if (model.formulae && model.formulae[0]) {\r\n    return model.formulae[0];\r\n  }\r\n\r\n  const range = new Range(model.ref);\r\n  const {tl} = range;\r\n  switch (model.timePeriod) {\r\n    case 'thisWeek':\r\n      return `AND(TODAY()-ROUNDDOWN(${tl},0)<=WEEKDAY(TODAY())-1,ROUNDDOWN(${tl},0)-TODAY()<=7-WEEKDAY(TODAY()))`;\r\n    case 'lastWeek':\r\n      return `AND(TODAY()-ROUNDDOWN(${tl},0)>=(WEEKDAY(TODAY())),TODAY()-ROUNDDOWN(${tl},0)<(WEEKDAY(TODAY())+7))`;\r\n    case 'nextWeek':\r\n      return `AND(ROUNDDOWN(${tl},0)-TODAY()>(7-WEEKDAY(TODAY())),ROUNDDOWN(${tl},0)-TODAY()<(15-WEEKDAY(TODAY())))`;\r\n    case 'yesterday':\r\n      return `FLOOR(${tl},1)=TODAY()-1`;\r\n    case 'today':\r\n      return `FLOOR(${tl},1)=TODAY()`;\r\n    case 'tomorrow':\r\n      return `FLOOR(${tl},1)=TODAY()+1`;\r\n    case 'last7Days':\r\n      return `AND(TODAY()-FLOOR(${tl},1)<=6,FLOOR(${tl},1)<=TODAY())`;\r\n    case 'lastMonth':\r\n      return `AND(MONTH(${tl})=MONTH(EDATE(TODAY(),0-1)),YEAR(${tl})=YEAR(EDATE(TODAY(),0-1)))`;\r\n    case 'thisMonth':\r\n      return `AND(MONTH(${tl})=MONTH(TODAY()),YEAR(${tl})=YEAR(TODAY()))`;\r\n    case 'nextMonth':\r\n      return `AND(MONTH(${tl})=MONTH(EDATE(TODAY(),0+1)),YEAR(${tl})=YEAR(EDATE(TODAY(),0+1)))`;\r\n    default:\r\n      return undefined;\r\n  }\r\n};\r\n\r\nconst opType = attributes => {\r\n  const {type, operator} = attributes;\r\n  switch (type) {\r\n    case 'containsText':\r\n    case 'containsBlanks':\r\n    case 'notContainsBlanks':\r\n    case 'containsErrors':\r\n    case 'notContainsErrors':\r\n      return {\r\n        type: 'containsText',\r\n        operator: type,\r\n      };\r\n\r\n    default:\r\n      return {type, operator};\r\n  }\r\n};\r\n\r\nclass CfRuleXform extends CompositeXform {\r\n  constructor() {\r\n    super();\r\n\r\n    this.map = {\r\n      dataBar: (this.databarXform = new DatabarXform()),\r\n      extLst: (this.extLstRefXform = new ExtLstRefXform()),\r\n      formula: (this.formulaXform = new FormulaXform()),\r\n      colorScale: (this.colorScaleXform = new ColorScaleXform()),\r\n      iconSet: (this.iconSetXform = new IconSetXform()),\r\n    };\r\n  }\r\n\r\n  get tag() {\r\n    return 'cfRule';\r\n  }\r\n\r\n  static isPrimitive(rule) {\r\n    // is this rule primitive?\r\n    if (rule.type === 'iconSet') {\r\n      if (rule.custom || extIcons[rule.iconSet]) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    switch (model.type) {\r\n      case 'expression':\r\n        this.renderExpression(xmlStream, model);\r\n        break;\r\n      case 'cellIs':\r\n        this.renderCellIs(xmlStream, model);\r\n        break;\r\n      case 'top10':\r\n        this.renderTop10(xmlStream, model);\r\n        break;\r\n      case 'aboveAverage':\r\n        this.renderAboveAverage(xmlStream, model);\r\n        break;\r\n      case 'dataBar':\r\n        this.renderDataBar(xmlStream, model);\r\n        break;\r\n      case 'colorScale':\r\n        this.renderColorScale(xmlStream, model);\r\n        break;\r\n      case 'iconSet':\r\n        this.renderIconSet(xmlStream, model);\r\n        break;\r\n      case 'containsText':\r\n        this.renderText(xmlStream, model);\r\n        break;\r\n      case 'timePeriod':\r\n        this.renderTimePeriod(xmlStream, model);\r\n        break;\r\n    }\r\n  }\r\n\r\n  renderExpression(xmlStream, model) {\r\n    xmlStream.openNode(this.tag, {\r\n      type: 'expression',\r\n      dxfId: model.dxfId,\r\n      priority: model.priority,\r\n    });\r\n\r\n    this.formulaXform.render(xmlStream, model.formulae[0]);\r\n\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  renderCellIs(xmlStream, model) {\r\n    xmlStream.openNode(this.tag, {\r\n      type: 'cellIs',\r\n      dxfId: model.dxfId,\r\n      priority: model.priority,\r\n      operator: model.operator,\r\n    });\r\n\r\n    model.formulae.forEach(formula => {\r\n      this.formulaXform.render(xmlStream, formula);\r\n    });\r\n\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  renderTop10(xmlStream, model) {\r\n    xmlStream.leafNode(this.tag, {\r\n      type: 'top10',\r\n      dxfId: model.dxfId,\r\n      priority: model.priority,\r\n      percent: BaseXform.toBoolAttribute(model.percent, false),\r\n      bottom: BaseXform.toBoolAttribute(model.bottom, false),\r\n      rank: BaseXform.toIntValue(model.rank, 10, true),\r\n    });\r\n  }\r\n\r\n  renderAboveAverage(xmlStream, model) {\r\n    xmlStream.leafNode(this.tag, {\r\n      type: 'aboveAverage',\r\n      dxfId: model.dxfId,\r\n      priority: model.priority,\r\n      aboveAverage: BaseXform.toBoolAttribute(model.aboveAverage, true),\r\n    });\r\n  }\r\n\r\n  renderDataBar(xmlStream, model) {\r\n    xmlStream.openNode(this.tag, {\r\n      type: 'dataBar',\r\n      priority: model.priority,\r\n    });\r\n\r\n    this.databarXform.render(xmlStream, model);\r\n    this.extLstRefXform.render(xmlStream, model);\r\n\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  renderColorScale(xmlStream, model) {\r\n    xmlStream.openNode(this.tag, {\r\n      type: 'colorScale',\r\n      priority: model.priority,\r\n    });\r\n\r\n    this.colorScaleXform.render(xmlStream, model);\r\n\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  renderIconSet(xmlStream, model) {\r\n    // iconset is all primitive or all extLst\r\n    if (!CfRuleXform.isPrimitive(model)) {\r\n      return;\r\n    }\r\n\r\n    xmlStream.openNode(this.tag, {\r\n      type: 'iconSet',\r\n      priority: model.priority,\r\n    });\r\n\r\n    this.iconSetXform.render(xmlStream, model);\r\n\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  renderText(xmlStream, model) {\r\n    xmlStream.openNode(this.tag, {\r\n      type: model.operator,\r\n      dxfId: model.dxfId,\r\n      priority: model.priority,\r\n      operator: BaseXform.toStringAttribute(model.operator, 'containsText'),\r\n    });\r\n\r\n    const formula = getTextFormula(model);\r\n    if (formula) {\r\n      this.formulaXform.render(xmlStream, formula);\r\n    }\r\n\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  renderTimePeriod(xmlStream, model) {\r\n    xmlStream.openNode(this.tag, {\r\n      type: 'timePeriod',\r\n      dxfId: model.dxfId,\r\n      priority: model.priority,\r\n      timePeriod: model.timePeriod,\r\n    });\r\n\r\n    const formula = getTimePeriodFormula(model);\r\n    if (formula) {\r\n      this.formulaXform.render(xmlStream, formula);\r\n    }\r\n\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  createNewModel({attributes}) {\r\n    return {\r\n      ...opType(attributes),\r\n      dxfId: BaseXform.toIntValue(attributes.dxfId),\r\n      priority: BaseXform.toIntValue(attributes.priority),\r\n      timePeriod: attributes.timePeriod,\r\n      percent: BaseXform.toBoolValue(attributes.percent),\r\n      bottom: BaseXform.toBoolValue(attributes.bottom),\r\n      rank: BaseXform.toIntValue(attributes.rank),\r\n      aboveAverage: BaseXform.toBoolValue(attributes.aboveAverage),\r\n    };\r\n  }\r\n\r\n  onParserClose(name, parser) {\r\n    switch (name) {\r\n      case 'dataBar':\r\n      case 'extLst':\r\n      case 'colorScale':\r\n      case 'iconSet':\r\n        // merge parser model with ours\r\n        Object.assign(this.model, parser.model);\r\n        break;\r\n\r\n      case 'formula':\r\n        // except - formula is a string and appends to formulae\r\n        this.model.formulae = this.model.formulae || [];\r\n        this.model.formulae.push(parser.model);\r\n        break;\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = CfRuleXform;\r\n"]},"metadata":{},"sourceType":"script"}