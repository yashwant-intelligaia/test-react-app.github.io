{"ast":null,"code":"\"use strict\";\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n} // StringBuf - a way to keep string memory operations to a minimum\n// while building the strings for the xml files\n\n\nvar StringBuf = /*#__PURE__*/function () {\n  function StringBuf(options) {\n    _classCallCheck(this, StringBuf);\n\n    this._buf = Buffer.alloc(options && options.size || 16384);\n    this._encoding = options && options.encoding || 'utf8'; // where in the buffer we are at\n\n    this._inPos = 0; // for use by toBuffer()\n\n    this._buffer = undefined;\n  }\n\n  _createClass(StringBuf, [{\n    key: \"toBuffer\",\n    value: function toBuffer() {\n      // return the current data as a single enclosing buffer\n      if (!this._buffer) {\n        this._buffer = Buffer.alloc(this.length);\n\n        this._buf.copy(this._buffer, 0, 0, this.length);\n      }\n\n      return this._buffer;\n    }\n  }, {\n    key: \"reset\",\n    value: function reset(position) {\n      position = position || 0;\n      this._buffer = undefined;\n      this._inPos = position;\n    }\n  }, {\n    key: \"_grow\",\n    value: function _grow(min) {\n      var size = this._buf.length * 2;\n\n      while (size < min) {\n        size *= 2;\n      }\n\n      var buf = Buffer.alloc(size);\n\n      this._buf.copy(buf, 0);\n\n      this._buf = buf;\n    }\n  }, {\n    key: \"addText\",\n    value: function addText(text) {\n      this._buffer = undefined;\n\n      var inPos = this._inPos + this._buf.write(text, this._inPos, this._encoding); // if we've hit (or nearing capacity), grow the buf\n\n\n      while (inPos >= this._buf.length - 4) {\n        this._grow(this._inPos + text.length); // keep trying to write until we've completely written the text\n\n\n        inPos = this._inPos + this._buf.write(text, this._inPos, this._encoding);\n      }\n\n      this._inPos = inPos;\n    }\n  }, {\n    key: \"addStringBuf\",\n    value: function addStringBuf(inBuf) {\n      if (inBuf.length) {\n        this._buffer = undefined;\n\n        if (this.length + inBuf.length > this.capacity) {\n          this._grow(this.length + inBuf.length);\n        } // eslint-disable-next-line no-underscore-dangle\n\n\n        inBuf._buf.copy(this._buf, this._inPos, 0, inBuf.length);\n\n        this._inPos += inBuf.length;\n      }\n    }\n  }, {\n    key: \"length\",\n    get: function get() {\n      return this._inPos;\n    }\n  }, {\n    key: \"capacity\",\n    get: function get() {\n      return this._buf.length;\n    }\n  }, {\n    key: \"buffer\",\n    get: function get() {\n      return this._buf;\n    }\n  }]);\n\n  return StringBuf;\n}();\n\nmodule.exports = StringBuf;","map":{"version":3,"sources":["../../../lib/utils/string-buf.js"],"names":["StringBuf","Buffer","options","position","min","size","buf","text","inPos","inBuf","module"],"mappings":";;;;;;;;;;;;;;;;;;;;;;EAAA;AACA;;;IACMA,S;AACJ,WAAA,SAAA,CAAA,OAAA,EAAqB;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,SAAA,CAAA;;AACnB,SAAA,IAAA,GAAYC,MAAM,CAANA,KAAAA,CAAcC,OAAO,IAAIA,OAAO,CAAnB,IAACA,IAA1B,KAAYD,CAAZ;AACA,SAAA,SAAA,GAAkBC,OAAO,IAAIA,OAAO,CAAnB,QAACA,IAFC,MAEnB,CAFmB,CAInB;;AACA,SAAA,MAAA,GALmB,CAKnB,CALmB,CAOnB;;AACA,SAAA,OAAA,GAAA,SAAA;AACD;;;;+BAcU;AACT;AACA,UAAI,CAAC,KAAL,OAAA,EAAmB;AACjB,aAAA,OAAA,GAAeD,MAAM,CAANA,KAAAA,CAAa,KAA5B,MAAeA,CAAf;;AACA,aAAA,IAAA,CAAA,IAAA,CAAe,KAAf,OAAA,EAAA,CAAA,EAAA,CAAA,EAAmC,KAAnC,MAAA;AACD;;AACD,aAAO,KAAP,OAAA;AACD;;;0BAEKE,Q,EAAU;AACdA,MAAAA,QAAQ,GAAGA,QAAQ,IAAnBA,CAAAA;AACA,WAAA,OAAA,GAAA,SAAA;AACA,WAAA,MAAA,GAAA,QAAA;AACD;;;0BAEKC,G,EAAK;AACT,UAAIC,IAAI,GAAG,KAAA,IAAA,CAAA,MAAA,GAAX,CAAA;;AACA,aAAOA,IAAI,GAAX,GAAA,EAAmB;AACjBA,QAAAA,IAAI,IAAJA,CAAAA;AACD;;AACD,UAAMC,GAAG,GAAGL,MAAM,CAANA,KAAAA,CAAZ,IAAYA,CAAZ;;AACA,WAAA,IAAA,CAAA,IAAA,CAAA,GAAA,EAAA,CAAA;;AACA,WAAA,IAAA,GAAA,GAAA;AACD;;;4BAEOM,I,EAAM;AACZ,WAAA,OAAA,GAAA,SAAA;;AAEA,UAAIC,KAAK,GAAG,KAAA,MAAA,GAAc,KAAA,IAAA,CAAA,KAAA,CAAA,IAAA,EAAsB,KAAtB,MAAA,EAAmC,KAHjD,SAGc,CAA1B,CAHY,CAKZ;;;AACA,aAAOA,KAAK,IAAI,KAAA,IAAA,CAAA,MAAA,GAAhB,CAAA,EAAsC;AACpC,aAAA,KAAA,CAAW,KAAA,MAAA,GAAcD,IAAI,CADO,MACpC,EADoC,CAGpC;;;AACAC,QAAAA,KAAK,GAAG,KAAA,MAAA,GAAc,KAAA,IAAA,CAAA,KAAA,CAAA,IAAA,EAAsB,KAAtB,MAAA,EAAmC,KAAzDA,SAAsB,CAAtBA;AACD;;AAED,WAAA,MAAA,GAAA,KAAA;AACD;;;iCAEYC,K,EAAO;AAClB,UAAIA,KAAK,CAAT,MAAA,EAAkB;AAChB,aAAA,OAAA,GAAA,SAAA;;AAEA,YAAI,KAAA,MAAA,GAAcA,KAAK,CAAnB,MAAA,GAA6B,KAAjC,QAAA,EAAgD;AAC9C,eAAA,KAAA,CAAW,KAAA,MAAA,GAAcA,KAAK,CAA9B,MAAA;AAJc,SAAA,CAMhB;;;AACAA,QAAAA,KAAK,CAALA,IAAAA,CAAAA,IAAAA,CAAgB,KAAhBA,IAAAA,EAA2B,KAA3BA,MAAAA,EAAAA,CAAAA,EAA2CA,KAAK,CAAhDA,MAAAA;;AACA,aAAA,MAAA,IAAeA,KAAK,CAApB,MAAA;AACD;AACF;;;wBAhEY;AACX,aAAO,KAAP,MAAA;AACD;;;wBAEc;AACb,aAAO,KAAA,IAAA,CAAP,MAAA;AACD;;;wBAEY;AACX,aAAO,KAAP,IAAA;AACD;;;;;;AAyDHC,MAAM,CAANA,OAAAA,GAAAA,SAAAA","sourcesContent":["// StringBuf - a way to keep string memory operations to a minimum\r\n// while building the strings for the xml files\r\nclass StringBuf {\r\n  constructor(options) {\r\n    this._buf = Buffer.alloc((options && options.size) || 16384);\r\n    this._encoding = (options && options.encoding) || 'utf8';\r\n\r\n    // where in the buffer we are at\r\n    this._inPos = 0;\r\n\r\n    // for use by toBuffer()\r\n    this._buffer = undefined;\r\n  }\r\n\r\n  get length() {\r\n    return this._inPos;\r\n  }\r\n\r\n  get capacity() {\r\n    return this._buf.length;\r\n  }\r\n\r\n  get buffer() {\r\n    return this._buf;\r\n  }\r\n\r\n  toBuffer() {\r\n    // return the current data as a single enclosing buffer\r\n    if (!this._buffer) {\r\n      this._buffer = Buffer.alloc(this.length);\r\n      this._buf.copy(this._buffer, 0, 0, this.length);\r\n    }\r\n    return this._buffer;\r\n  }\r\n\r\n  reset(position) {\r\n    position = position || 0;\r\n    this._buffer = undefined;\r\n    this._inPos = position;\r\n  }\r\n\r\n  _grow(min) {\r\n    let size = this._buf.length * 2;\r\n    while (size < min) {\r\n      size *= 2;\r\n    }\r\n    const buf = Buffer.alloc(size);\r\n    this._buf.copy(buf, 0);\r\n    this._buf = buf;\r\n  }\r\n\r\n  addText(text) {\r\n    this._buffer = undefined;\r\n\r\n    let inPos = this._inPos + this._buf.write(text, this._inPos, this._encoding);\r\n\r\n    // if we've hit (or nearing capacity), grow the buf\r\n    while (inPos >= this._buf.length - 4) {\r\n      this._grow(this._inPos + text.length);\r\n\r\n      // keep trying to write until we've completely written the text\r\n      inPos = this._inPos + this._buf.write(text, this._inPos, this._encoding);\r\n    }\r\n\r\n    this._inPos = inPos;\r\n  }\r\n\r\n  addStringBuf(inBuf) {\r\n    if (inBuf.length) {\r\n      this._buffer = undefined;\r\n\r\n      if (this.length + inBuf.length > this.capacity) {\r\n        this._grow(this.length + inBuf.length);\r\n      }\r\n      // eslint-disable-next-line no-underscore-dangle\r\n      inBuf._buf.copy(this._buf, this._inPos, 0, inBuf.length);\r\n      this._inPos += inBuf.length;\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = StringBuf;\r\n"]},"metadata":{},"sourceType":"script"}