{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RowFormatter = void 0;\n\nconst lodash_isfunction_1 = __importDefault(require(\"lodash.isfunction\"));\n\nconst lodash_isequal_1 = __importDefault(require(\"lodash.isequal\"));\n\nconst FieldFormatter_1 = require(\"./FieldFormatter\");\n\nconst types_1 = require(\"../types\");\n\nclass RowFormatter {\n  constructor(formatterOptions) {\n    this.rowCount = 0;\n    this.formatterOptions = formatterOptions;\n    this.fieldFormatter = new FieldFormatter_1.FieldFormatter(formatterOptions);\n    this.headers = formatterOptions.headers;\n    this.shouldWriteHeaders = formatterOptions.shouldWriteHeaders;\n    this.hasWrittenHeaders = false;\n\n    if (this.headers !== null) {\n      this.fieldFormatter.headers = this.headers;\n    }\n\n    if (formatterOptions.transform) {\n      this.rowTransform = formatterOptions.transform;\n    }\n  }\n\n  static isRowHashArray(row) {\n    if (Array.isArray(row)) {\n      return Array.isArray(row[0]) && row[0].length === 2;\n    }\n\n    return false;\n  }\n\n  static isRowArray(row) {\n    return Array.isArray(row) && !this.isRowHashArray(row);\n  } // get headers from a row item\n\n\n  static gatherHeaders(row) {\n    if (RowFormatter.isRowHashArray(row)) {\n      // lets assume a multi-dimesional array with item 0 being the header\n      return row.map(it => it[0]);\n    }\n\n    if (Array.isArray(row)) {\n      return row;\n    }\n\n    return Object.keys(row);\n  } // eslint-disable-next-line @typescript-eslint/no-shadow\n\n\n  static createTransform(transformFunction) {\n    if (types_1.isSyncTransform(transformFunction)) {\n      return (row, cb) => {\n        let transformedRow = null;\n\n        try {\n          transformedRow = transformFunction(row);\n        } catch (e) {\n          return cb(e);\n        }\n\n        return cb(null, transformedRow);\n      };\n    }\n\n    return (row, cb) => {\n      transformFunction(row, cb);\n    };\n  }\n\n  set rowTransform(transformFunction) {\n    if (!lodash_isfunction_1.default(transformFunction)) {\n      throw new TypeError('The transform should be a function');\n    }\n\n    this._rowTransform = RowFormatter.createTransform(transformFunction);\n  }\n\n  format(row, cb) {\n    this.callTransformer(row, (err, transformedRow) => {\n      if (err) {\n        return cb(err);\n      }\n\n      if (!row) {\n        return cb(null);\n      }\n\n      const rows = [];\n\n      if (transformedRow) {\n        const {\n          shouldFormatColumns,\n          headers\n        } = this.checkHeaders(transformedRow);\n\n        if (this.shouldWriteHeaders && headers && !this.hasWrittenHeaders) {\n          rows.push(this.formatColumns(headers, true));\n          this.hasWrittenHeaders = true;\n        }\n\n        if (shouldFormatColumns) {\n          const columns = this.gatherColumns(transformedRow);\n          rows.push(this.formatColumns(columns, false));\n        }\n      }\n\n      return cb(null, rows);\n    });\n  }\n\n  finish(cb) {\n    const rows = []; // check if we should write headers and we didnt get any rows\n\n    if (this.formatterOptions.alwaysWriteHeaders && this.rowCount === 0) {\n      if (!this.headers) {\n        return cb(new Error('`alwaysWriteHeaders` option is set to true but `headers` option not provided.'));\n      }\n\n      rows.push(this.formatColumns(this.headers, true));\n    }\n\n    if (this.formatterOptions.includeEndRowDelimiter) {\n      rows.push(this.formatterOptions.rowDelimiter);\n    }\n\n    return cb(null, rows);\n  } // check if we need to write header return true if we should also write a row\n  // could be false if headers is true and the header row(first item) is passed in\n\n\n  checkHeaders(row) {\n    if (this.headers) {\n      // either the headers were provided by the user or we have already gathered them.\n      return {\n        shouldFormatColumns: true,\n        headers: this.headers\n      };\n    }\n\n    const headers = RowFormatter.gatherHeaders(row);\n    this.headers = headers;\n    this.fieldFormatter.headers = headers;\n\n    if (!this.shouldWriteHeaders) {\n      // if we are not supposed to write the headers then\n      // always format the columns\n      return {\n        shouldFormatColumns: true,\n        headers: null\n      };\n    } // if the row is equal to headers dont format\n\n\n    return {\n      shouldFormatColumns: !lodash_isequal_1.default(headers, row),\n      headers\n    };\n  } // todo change this method to unknown[]\n\n\n  gatherColumns(row) {\n    if (this.headers === null) {\n      throw new Error('Headers is currently null');\n    }\n\n    if (!Array.isArray(row)) {\n      return this.headers.map(header => row[header]);\n    }\n\n    if (RowFormatter.isRowHashArray(row)) {\n      return this.headers.map((header, i) => {\n        const col = row[i];\n\n        if (col) {\n          return col[1];\n        }\n\n        return '';\n      });\n    } // if its a one dimensional array and headers were not provided\n    // then just return the row\n\n\n    if (RowFormatter.isRowArray(row) && !this.shouldWriteHeaders) {\n      return row;\n    }\n\n    return this.headers.map((header, i) => row[i]);\n  }\n\n  callTransformer(row, cb) {\n    if (!this._rowTransform) {\n      return cb(null, row);\n    }\n\n    return this._rowTransform(row, cb);\n  }\n\n  formatColumns(columns, isHeadersRow) {\n    const formattedCols = columns.map((field, i) => this.fieldFormatter.format(field, i, isHeadersRow)).join(this.formatterOptions.delimiter);\n    const {\n      rowCount\n    } = this;\n    this.rowCount += 1;\n\n    if (rowCount) {\n      return [this.formatterOptions.rowDelimiter, formattedCols].join('');\n    }\n\n    return formattedCols;\n  }\n\n}\n\nexports.RowFormatter = RowFormatter;","map":{"version":3,"sources":["../../../src/formatter/RowFormatter.ts"],"names":[],"mappings":";;;;;;;;;;;;;AAAA,MAAA,mBAAA,GAAA,eAAA,CAAA,OAAA,CAAA,mBAAA,CAAA,CAAA;;AACA,MAAA,gBAAA,GAAA,eAAA,CAAA,OAAA,CAAA,gBAAA,CAAA,CAAA;;AAEA,MAAA,gBAAA,GAAA,OAAA,CAAA,kBAAA,CAAA;;AACA,MAAA,OAAA,GAAA,OAAA,CAAA,UAAA,CAAA;;AAMA,MAAa,YAAb,CAAyB;AA0DrB,EAAA,WAAA,CAAmB,gBAAnB,EAA2D;AAFnD,SAAA,QAAA,GAAW,CAAX;AAGJ,SAAK,gBAAL,GAAwB,gBAAxB;AACA,SAAK,cAAL,GAAsB,IAAI,gBAAA,CAAA,cAAJ,CAAmB,gBAAnB,CAAtB;AAEA,SAAK,OAAL,GAAe,gBAAgB,CAAC,OAAhC;AACA,SAAK,kBAAL,GAA0B,gBAAgB,CAAC,kBAA3C;AACA,SAAK,iBAAL,GAAyB,KAAzB;;AACA,QAAI,KAAK,OAAL,KAAiB,IAArB,EAA2B;AACvB,WAAK,cAAL,CAAoB,OAApB,GAA8B,KAAK,OAAnC;AACH;;AACD,QAAI,gBAAgB,CAAC,SAArB,EAAgC;AAC5B,WAAK,YAAL,GAAoB,gBAAgB,CAAC,SAArC;AACH;AACJ;;AAtEO,SAAO,cAAP,CAAsB,GAAtB,EAA8B;AAClC,QAAI,KAAK,CAAC,OAAN,CAAc,GAAd,CAAJ,EAAwB;AACpB,aAAO,KAAK,CAAC,OAAN,CAAc,GAAG,CAAC,CAAD,CAAjB,KAAyB,GAAG,CAAC,CAAD,CAAH,CAAO,MAAP,KAAkB,CAAlD;AACH;;AACD,WAAO,KAAP;AACH;;AAEO,SAAO,UAAP,CAAkB,GAAlB,EAA0B;AAC9B,WAAO,KAAK,CAAC,OAAN,CAAc,GAAd,KAAsB,CAAC,KAAK,cAAL,CAAoB,GAApB,CAA9B;AACH,GAVoB,CAYrB;;;AACQ,SAAO,aAAP,CAAqB,GAArB,EAA6B;AACjC,QAAI,YAAY,CAAC,cAAb,CAA4B,GAA5B,CAAJ,EAAsC;AAClC;AACA,aAAO,GAAG,CAAC,GAAJ,CAAS,EAAD,IAAgB,EAAE,CAAC,CAAD,CAA1B,CAAP;AACH;;AACD,QAAI,KAAK,CAAC,OAAN,CAAc,GAAd,CAAJ,EAAwB;AACpB,aAAO,GAAP;AACH;;AACD,WAAO,MAAM,CAAC,IAAP,CAAY,GAAZ,CAAP;AACH,GAtBoB,CAwBrB;;;AACQ,SAAO,eAAP,CACJ,iBADI,EACyC;AAE7C,QAAI,OAAA,CAAA,eAAA,CAAgB,iBAAhB,CAAJ,EAAwC;AACpC,aAAO,CAAC,GAAD,EAAS,EAAT,KAA8C;AACjD,YAAI,cAAc,GAAG,IAArB;;AACA,YAAI;AACA,UAAA,cAAc,GAAG,iBAAiB,CAAC,GAAD,CAAlC;AACH,SAFD,CAEE,OAAO,CAAP,EAAU;AACR,iBAAO,EAAE,CAAC,CAAD,CAAT;AACH;;AACD,eAAO,EAAE,CAAC,IAAD,EAAO,cAAP,CAAT;AACH,OARD;AASH;;AACD,WAAO,CAAC,GAAD,EAAS,EAAT,KAA8C;AACjD,MAAA,iBAAiB,CAAC,GAAD,EAAM,EAAN,CAAjB;AACH,KAFD;AAGH;;AA+BD,MAAW,YAAX,CAAwB,iBAAxB,EAAqE;AACjE,QAAI,CAAC,mBAAA,CAAA,OAAA,CAAW,iBAAX,CAAL,EAAoC;AAChC,YAAM,IAAI,SAAJ,CAAc,oCAAd,CAAN;AACH;;AACD,SAAK,aAAL,GAAqB,YAAY,CAAC,eAAb,CAA6B,iBAA7B,CAArB;AACH;;AAEM,EAAA,MAAM,CAAC,GAAD,EAAS,EAAT,EAAiC;AAC1C,SAAK,eAAL,CAAqB,GAArB,EAA0B,CAAC,GAAD,EAAM,cAAN,KAAoC;AAC1D,UAAI,GAAJ,EAAS;AACL,eAAO,EAAE,CAAC,GAAD,CAAT;AACH;;AACD,UAAI,CAAC,GAAL,EAAU;AACN,eAAO,EAAE,CAAC,IAAD,CAAT;AACH;;AACD,YAAM,IAAI,GAAG,EAAb;;AACA,UAAI,cAAJ,EAAoB;AAChB,cAAM;AAAE,UAAA,mBAAF;AAAuB,UAAA;AAAvB,YAAmC,KAAK,YAAL,CAAkB,cAAlB,CAAzC;;AACA,YAAI,KAAK,kBAAL,IAA2B,OAA3B,IAAsC,CAAC,KAAK,iBAAhD,EAAmE;AAC/D,UAAA,IAAI,CAAC,IAAL,CAAU,KAAK,aAAL,CAAmB,OAAnB,EAA4B,IAA5B,CAAV;AACA,eAAK,iBAAL,GAAyB,IAAzB;AACH;;AACD,YAAI,mBAAJ,EAAyB;AACrB,gBAAM,OAAO,GAAG,KAAK,aAAL,CAAmB,cAAnB,CAAhB;AACA,UAAA,IAAI,CAAC,IAAL,CAAU,KAAK,aAAL,CAAmB,OAAnB,EAA4B,KAA5B,CAAV;AACH;AACJ;;AACD,aAAO,EAAE,CAAC,IAAD,EAAO,IAAP,CAAT;AACH,KApBD;AAqBH;;AAEM,EAAA,MAAM,CAAC,EAAD,EAAyB;AAClC,UAAM,IAAI,GAAG,EAAb,CADkC,CAElC;;AACA,QAAI,KAAK,gBAAL,CAAsB,kBAAtB,IAA4C,KAAK,QAAL,KAAkB,CAAlE,EAAqE;AACjE,UAAI,CAAC,KAAK,OAAV,EAAmB;AACf,eAAO,EAAE,CAAC,IAAI,KAAJ,CAAU,+EAAV,CAAD,CAAT;AACH;;AACD,MAAA,IAAI,CAAC,IAAL,CAAU,KAAK,aAAL,CAAmB,KAAK,OAAxB,EAAiC,IAAjC,CAAV;AACH;;AACD,QAAI,KAAK,gBAAL,CAAsB,sBAA1B,EAAkD;AAC9C,MAAA,IAAI,CAAC,IAAL,CAAU,KAAK,gBAAL,CAAsB,YAAhC;AACH;;AACD,WAAO,EAAE,CAAC,IAAD,EAAO,IAAP,CAAT;AACH,GArHoB,CAuHrB;AACA;;;AACQ,EAAA,YAAY,CAAC,GAAD,EAAS;AACzB,QAAI,KAAK,OAAT,EAAkB;AACd;AACA,aAAO;AAAE,QAAA,mBAAmB,EAAE,IAAvB;AAA6B,QAAA,OAAO,EAAE,KAAK;AAA3C,OAAP;AACH;;AACD,UAAM,OAAO,GAAG,YAAY,CAAC,aAAb,CAA2B,GAA3B,CAAhB;AACA,SAAK,OAAL,GAAe,OAAf;AACA,SAAK,cAAL,CAAoB,OAApB,GAA8B,OAA9B;;AACA,QAAI,CAAC,KAAK,kBAAV,EAA8B;AAC1B;AACA;AACA,aAAO;AAAE,QAAA,mBAAmB,EAAE,IAAvB;AAA6B,QAAA,OAAO,EAAE;AAAtC,OAAP;AACH,KAZwB,CAazB;;;AACA,WAAO;AAAE,MAAA,mBAAmB,EAAE,CAAC,gBAAA,CAAA,OAAA,CAAQ,OAAR,EAAiB,GAAjB,CAAxB;AAA+C,MAAA;AAA/C,KAAP;AACH,GAxIoB,CA0IrB;;;AACQ,EAAA,aAAa,CAAC,GAAD,EAAS;AAC1B,QAAI,KAAK,OAAL,KAAiB,IAArB,EAA2B;AACvB,YAAM,IAAI,KAAJ,CAAU,2BAAV,CAAN;AACH;;AACD,QAAI,CAAC,KAAK,CAAC,OAAN,CAAc,GAAd,CAAL,EAAyB;AACrB,aAAO,KAAK,OAAL,CAAa,GAAb,CAAkB,MAAD,IAAoB,GAAG,CAAC,MAAD,CAAxC,CAAP;AACH;;AACD,QAAI,YAAY,CAAC,cAAb,CAA4B,GAA5B,CAAJ,EAAsC;AAClC,aAAO,KAAK,OAAL,CAAa,GAAb,CAAiB,CAAC,MAAD,EAAS,CAAT,KAAsB;AAC1C,cAAM,GAAG,GAAI,GAAG,CAAC,CAAD,CAAhB;;AACA,YAAI,GAAJ,EAAS;AACL,iBAAO,GAAG,CAAC,CAAD,CAAV;AACH;;AACD,eAAO,EAAP;AACH,OANM,CAAP;AAOH,KAfyB,CAgB1B;AACA;;;AACA,QAAI,YAAY,CAAC,UAAb,CAAwB,GAAxB,KAAgC,CAAC,KAAK,kBAA1C,EAA8D;AAC1D,aAAO,GAAP;AACH;;AACD,WAAO,KAAK,OAAL,CAAa,GAAb,CAAiB,CAAC,MAAD,EAAS,CAAT,KAAuB,GAAG,CAAC,CAAD,CAA3C,CAAP;AACH;;AAEO,EAAA,eAAe,CAAC,GAAD,EAAS,EAAT,EAAoC;AACvD,QAAI,CAAC,KAAK,aAAV,EAAyB;AACrB,aAAO,EAAE,CAAC,IAAD,EAAQ,GAAR,CAAT;AACH;;AACD,WAAO,KAAK,aAAL,CAAmB,GAAnB,EAAwB,EAAxB,CAAP;AACH;;AAEO,EAAA,aAAa,CAAC,OAAD,EAAoB,YAApB,EAAyC;AAC1D,UAAM,aAAa,GAAG,OAAO,CACxB,GADiB,CACb,CAAC,KAAD,EAAQ,CAAR,KAAsB,KAAK,cAAL,CAAoB,MAApB,CAA2B,KAA3B,EAAkC,CAAlC,EAAqC,YAArC,CADT,EAEjB,IAFiB,CAEZ,KAAK,gBAAL,CAAsB,SAFV,CAAtB;AAGA,UAAM;AAAE,MAAA;AAAF,QAAe,IAArB;AACA,SAAK,QAAL,IAAiB,CAAjB;;AACA,QAAI,QAAJ,EAAc;AACV,aAAO,CAAC,KAAK,gBAAL,CAAsB,YAAvB,EAAqC,aAArC,EAAoD,IAApD,CAAyD,EAAzD,CAAP;AACH;;AACD,WAAO,aAAP;AACH;;AApLoB;;AAAzB,OAAA,CAAA,YAAA,GAAA,YAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RowFormatter = void 0;\nconst lodash_isfunction_1 = __importDefault(require(\"lodash.isfunction\"));\nconst lodash_isequal_1 = __importDefault(require(\"lodash.isequal\"));\nconst FieldFormatter_1 = require(\"./FieldFormatter\");\nconst types_1 = require(\"../types\");\nclass RowFormatter {\n    constructor(formatterOptions) {\n        this.rowCount = 0;\n        this.formatterOptions = formatterOptions;\n        this.fieldFormatter = new FieldFormatter_1.FieldFormatter(formatterOptions);\n        this.headers = formatterOptions.headers;\n        this.shouldWriteHeaders = formatterOptions.shouldWriteHeaders;\n        this.hasWrittenHeaders = false;\n        if (this.headers !== null) {\n            this.fieldFormatter.headers = this.headers;\n        }\n        if (formatterOptions.transform) {\n            this.rowTransform = formatterOptions.transform;\n        }\n    }\n    static isRowHashArray(row) {\n        if (Array.isArray(row)) {\n            return Array.isArray(row[0]) && row[0].length === 2;\n        }\n        return false;\n    }\n    static isRowArray(row) {\n        return Array.isArray(row) && !this.isRowHashArray(row);\n    }\n    // get headers from a row item\n    static gatherHeaders(row) {\n        if (RowFormatter.isRowHashArray(row)) {\n            // lets assume a multi-dimesional array with item 0 being the header\n            return row.map((it) => it[0]);\n        }\n        if (Array.isArray(row)) {\n            return row;\n        }\n        return Object.keys(row);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-shadow\n    static createTransform(transformFunction) {\n        if (types_1.isSyncTransform(transformFunction)) {\n            return (row, cb) => {\n                let transformedRow = null;\n                try {\n                    transformedRow = transformFunction(row);\n                }\n                catch (e) {\n                    return cb(e);\n                }\n                return cb(null, transformedRow);\n            };\n        }\n        return (row, cb) => {\n            transformFunction(row, cb);\n        };\n    }\n    set rowTransform(transformFunction) {\n        if (!lodash_isfunction_1.default(transformFunction)) {\n            throw new TypeError('The transform should be a function');\n        }\n        this._rowTransform = RowFormatter.createTransform(transformFunction);\n    }\n    format(row, cb) {\n        this.callTransformer(row, (err, transformedRow) => {\n            if (err) {\n                return cb(err);\n            }\n            if (!row) {\n                return cb(null);\n            }\n            const rows = [];\n            if (transformedRow) {\n                const { shouldFormatColumns, headers } = this.checkHeaders(transformedRow);\n                if (this.shouldWriteHeaders && headers && !this.hasWrittenHeaders) {\n                    rows.push(this.formatColumns(headers, true));\n                    this.hasWrittenHeaders = true;\n                }\n                if (shouldFormatColumns) {\n                    const columns = this.gatherColumns(transformedRow);\n                    rows.push(this.formatColumns(columns, false));\n                }\n            }\n            return cb(null, rows);\n        });\n    }\n    finish(cb) {\n        const rows = [];\n        // check if we should write headers and we didnt get any rows\n        if (this.formatterOptions.alwaysWriteHeaders && this.rowCount === 0) {\n            if (!this.headers) {\n                return cb(new Error('`alwaysWriteHeaders` option is set to true but `headers` option not provided.'));\n            }\n            rows.push(this.formatColumns(this.headers, true));\n        }\n        if (this.formatterOptions.includeEndRowDelimiter) {\n            rows.push(this.formatterOptions.rowDelimiter);\n        }\n        return cb(null, rows);\n    }\n    // check if we need to write header return true if we should also write a row\n    // could be false if headers is true and the header row(first item) is passed in\n    checkHeaders(row) {\n        if (this.headers) {\n            // either the headers were provided by the user or we have already gathered them.\n            return { shouldFormatColumns: true, headers: this.headers };\n        }\n        const headers = RowFormatter.gatherHeaders(row);\n        this.headers = headers;\n        this.fieldFormatter.headers = headers;\n        if (!this.shouldWriteHeaders) {\n            // if we are not supposed to write the headers then\n            // always format the columns\n            return { shouldFormatColumns: true, headers: null };\n        }\n        // if the row is equal to headers dont format\n        return { shouldFormatColumns: !lodash_isequal_1.default(headers, row), headers };\n    }\n    // todo change this method to unknown[]\n    gatherColumns(row) {\n        if (this.headers === null) {\n            throw new Error('Headers is currently null');\n        }\n        if (!Array.isArray(row)) {\n            return this.headers.map((header) => row[header]);\n        }\n        if (RowFormatter.isRowHashArray(row)) {\n            return this.headers.map((header, i) => {\n                const col = row[i];\n                if (col) {\n                    return col[1];\n                }\n                return '';\n            });\n        }\n        // if its a one dimensional array and headers were not provided\n        // then just return the row\n        if (RowFormatter.isRowArray(row) && !this.shouldWriteHeaders) {\n            return row;\n        }\n        return this.headers.map((header, i) => row[i]);\n    }\n    callTransformer(row, cb) {\n        if (!this._rowTransform) {\n            return cb(null, row);\n        }\n        return this._rowTransform(row, cb);\n    }\n    formatColumns(columns, isHeadersRow) {\n        const formattedCols = columns\n            .map((field, i) => this.fieldFormatter.format(field, i, isHeadersRow))\n            .join(this.formatterOptions.delimiter);\n        const { rowCount } = this;\n        this.rowCount += 1;\n        if (rowCount) {\n            return [this.formatterOptions.rowDelimiter, formattedCols].join('');\n        }\n        return formattedCols;\n    }\n}\nexports.RowFormatter = RowFormatter;\n//# sourceMappingURL=RowFormatter.js.map"]},"metadata":{},"sourceType":"script"}