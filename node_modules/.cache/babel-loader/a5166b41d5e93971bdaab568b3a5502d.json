{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CsvFormatterStream = void 0;\n\nconst stream_1 = require(\"stream\");\n\nconst formatter_1 = require(\"./formatter\");\n\nclass CsvFormatterStream extends stream_1.Transform {\n  constructor(formatterOptions) {\n    super({\n      writableObjectMode: formatterOptions.objectMode\n    });\n    this.hasWrittenBOM = false;\n    this.formatterOptions = formatterOptions;\n    this.rowFormatter = new formatter_1.RowFormatter(formatterOptions); // if writeBOM is false then set to true\n    // if writeBOM is true then set to false by default so it is written out\n\n    this.hasWrittenBOM = !formatterOptions.writeBOM;\n  }\n\n  transform(transformFunction) {\n    this.rowFormatter.rowTransform = transformFunction;\n    return this;\n  }\n\n  _transform(row, encoding, cb) {\n    let cbCalled = false;\n\n    try {\n      if (!this.hasWrittenBOM) {\n        this.push(this.formatterOptions.BOM);\n        this.hasWrittenBOM = true;\n      }\n\n      this.rowFormatter.format(row, (err, rows) => {\n        if (err) {\n          cbCalled = true;\n          return cb(err);\n        }\n\n        if (rows) {\n          rows.forEach(r => {\n            this.push(Buffer.from(r, 'utf8'));\n          });\n        }\n\n        cbCalled = true;\n        return cb();\n      });\n    } catch (e) {\n      if (cbCalled) {\n        throw e;\n      }\n\n      cb(e);\n    }\n  }\n\n  _flush(cb) {\n    this.rowFormatter.finish((err, rows) => {\n      if (err) {\n        return cb(err);\n      }\n\n      if (rows) {\n        rows.forEach(r => {\n          this.push(Buffer.from(r, 'utf8'));\n        });\n      }\n\n      return cb();\n    });\n  }\n\n}\n\nexports.CsvFormatterStream = CsvFormatterStream;","map":{"version":3,"sources":["../../src/CsvFormatterStream.ts"],"names":[],"mappings":";;;;;;;AAAA,MAAA,QAAA,GAAA,OAAA,CAAA,QAAA,CAAA;;AAGA,MAAA,WAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;AAEA,MAAa,kBAAb,SAAsE,QAAA,CAAA,SAAtE,CAA+E;AAO3E,EAAA,WAAA,CAAmB,gBAAnB,EAA2D;AACvD,UAAM;AAAE,MAAA,kBAAkB,EAAE,gBAAgB,CAAC;AAAvC,KAAN;AAHI,SAAA,aAAA,GAAgB,KAAhB;AAIJ,SAAK,gBAAL,GAAwB,gBAAxB;AACA,SAAK,YAAL,GAAoB,IAAI,WAAA,CAAA,YAAJ,CAAiB,gBAAjB,CAApB,CAHuD,CAIvD;AACA;;AACA,SAAK,aAAL,GAAqB,CAAC,gBAAgB,CAAC,QAAvC;AACH;;AAEM,EAAA,SAAS,CAAC,iBAAD,EAA8C;AAC1D,SAAK,YAAL,CAAkB,YAAlB,GAAiC,iBAAjC;AACA,WAAO,IAAP;AACH;;AAEM,EAAA,UAAU,CAAC,GAAD,EAAS,QAAT,EAA2B,EAA3B,EAAgD;AAC7D,QAAI,QAAQ,GAAG,KAAf;;AACA,QAAI;AACA,UAAI,CAAC,KAAK,aAAV,EAAyB;AACrB,aAAK,IAAL,CAAU,KAAK,gBAAL,CAAsB,GAAhC;AACA,aAAK,aAAL,GAAqB,IAArB;AACH;;AACD,WAAK,YAAL,CAAkB,MAAlB,CAAyB,GAAzB,EAA8B,CAAC,GAAD,EAAM,IAAN,KAAoB;AAC9C,YAAI,GAAJ,EAAS;AACL,UAAA,QAAQ,GAAG,IAAX;AACA,iBAAO,EAAE,CAAC,GAAD,CAAT;AACH;;AACD,YAAI,IAAJ,EAAU;AACN,UAAA,IAAI,CAAC,OAAL,CAAc,CAAD,IAAY;AACrB,iBAAK,IAAL,CAAU,MAAM,CAAC,IAAP,CAAY,CAAZ,EAAe,MAAf,CAAV;AACH,WAFD;AAGH;;AACD,QAAA,QAAQ,GAAG,IAAX;AACA,eAAO,EAAE,EAAT;AACH,OAZD;AAaH,KAlBD,CAkBE,OAAO,CAAP,EAAU;AACR,UAAI,QAAJ,EAAc;AACV,cAAM,CAAN;AACH;;AACD,MAAA,EAAE,CAAC,CAAD,CAAF;AACH;AACJ;;AAEM,EAAA,MAAM,CAAC,EAAD,EAAsB;AAC/B,SAAK,YAAL,CAAkB,MAAlB,CAAyB,CAAC,GAAD,EAAM,IAAN,KAAoB;AACzC,UAAI,GAAJ,EAAS;AACL,eAAO,EAAE,CAAC,GAAD,CAAT;AACH;;AACD,UAAI,IAAJ,EAAU;AACN,QAAA,IAAI,CAAC,OAAL,CAAc,CAAD,IAAY;AACrB,eAAK,IAAL,CAAU,MAAM,CAAC,IAAP,CAAY,CAAZ,EAAe,MAAf,CAAV;AACH,SAFD;AAGH;;AACD,aAAO,EAAE,EAAT;AACH,KAVD;AAWH;;AA7D0E;;AAA/E,OAAA,CAAA,kBAAA,GAAA,kBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CsvFormatterStream = void 0;\nconst stream_1 = require(\"stream\");\nconst formatter_1 = require(\"./formatter\");\nclass CsvFormatterStream extends stream_1.Transform {\n    constructor(formatterOptions) {\n        super({ writableObjectMode: formatterOptions.objectMode });\n        this.hasWrittenBOM = false;\n        this.formatterOptions = formatterOptions;\n        this.rowFormatter = new formatter_1.RowFormatter(formatterOptions);\n        // if writeBOM is false then set to true\n        // if writeBOM is true then set to false by default so it is written out\n        this.hasWrittenBOM = !formatterOptions.writeBOM;\n    }\n    transform(transformFunction) {\n        this.rowFormatter.rowTransform = transformFunction;\n        return this;\n    }\n    _transform(row, encoding, cb) {\n        let cbCalled = false;\n        try {\n            if (!this.hasWrittenBOM) {\n                this.push(this.formatterOptions.BOM);\n                this.hasWrittenBOM = true;\n            }\n            this.rowFormatter.format(row, (err, rows) => {\n                if (err) {\n                    cbCalled = true;\n                    return cb(err);\n                }\n                if (rows) {\n                    rows.forEach((r) => {\n                        this.push(Buffer.from(r, 'utf8'));\n                    });\n                }\n                cbCalled = true;\n                return cb();\n            });\n        }\n        catch (e) {\n            if (cbCalled) {\n                throw e;\n            }\n            cb(e);\n        }\n    }\n    _flush(cb) {\n        this.rowFormatter.finish((err, rows) => {\n            if (err) {\n                return cb(err);\n            }\n            if (rows) {\n                rows.forEach((r) => {\n                    this.push(Buffer.from(r, 'utf8'));\n                });\n            }\n            return cb();\n        });\n    }\n}\nexports.CsvFormatterStream = CsvFormatterStream;\n//# sourceMappingURL=CsvFormatterStream.js.map"]},"metadata":{},"sourceType":"script"}