{"ast":null,"code":"\"use strict\";\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nvar Enums = require('../../../doc/enums');\n\nvar utils = require('../../../utils/utils');\n\nvar BaseXform = require('../base-xform');\n\nvar validation = {\n  horizontalValues: ['left', 'center', 'right', 'fill', 'centerContinuous', 'distributed', 'justify'].reduce(function (p, v) {\n    p[v] = true;\n    return p;\n  }, {}),\n  horizontal: function horizontal(value) {\n    return this.horizontalValues[value] ? value : undefined;\n  },\n  verticalValues: ['top', 'middle', 'bottom', 'distributed', 'justify'].reduce(function (p, v) {\n    p[v] = true;\n    return p;\n  }, {}),\n  vertical: function vertical(value) {\n    if (value === 'middle') return 'center';\n    return this.verticalValues[value] ? value : undefined;\n  },\n  wrapText: function wrapText(value) {\n    return value ? true : undefined;\n  },\n  shrinkToFit: function shrinkToFit(value) {\n    return value ? true : undefined;\n  },\n  textRotation: function textRotation(value) {\n    switch (value) {\n      case 'vertical':\n        return value;\n\n      default:\n        value = utils.validInt(value);\n        return value >= -90 && value <= 90 ? value : undefined;\n    }\n  },\n  indent: function indent(value) {\n    value = utils.validInt(value);\n    return Math.max(0, value);\n  },\n  readingOrder: function readingOrder(value) {\n    switch (value) {\n      case 'ltr':\n        return Enums.ReadingOrder.LeftToRight;\n\n      case 'rtl':\n        return Enums.ReadingOrder.RightToLeft;\n\n      default:\n        return undefined;\n    }\n  }\n};\nvar textRotationXform = {\n  toXml: function toXml(textRotation) {\n    textRotation = validation.textRotation(textRotation);\n\n    if (textRotation) {\n      if (textRotation === 'vertical') {\n        return 255;\n      }\n\n      var tr = Math.round(textRotation);\n\n      if (tr >= 0 && tr <= 90) {\n        return tr;\n      }\n\n      if (tr < 0 && tr >= -90) {\n        return 90 - tr;\n      }\n    }\n\n    return undefined;\n  },\n  toModel: function toModel(textRotation) {\n    var tr = utils.validInt(textRotation);\n\n    if (tr !== undefined) {\n      if (tr === 255) {\n        return 'vertical';\n      }\n\n      if (tr >= 0 && tr <= 90) {\n        return tr;\n      }\n\n      if (tr > 90 && tr <= 180) {\n        return 90 - tr;\n      }\n    }\n\n    return undefined;\n  }\n}; // Alignment encapsulates translation from style.alignment model to/from xlsx\n\nvar AlignmentXform = /*#__PURE__*/function (_BaseXform) {\n  _inherits(AlignmentXform, _BaseXform);\n\n  var _super = _createSuper(AlignmentXform);\n\n  function AlignmentXform() {\n    _classCallCheck(this, AlignmentXform);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(AlignmentXform, [{\n    key: \"render\",\n    value: function render(xmlStream, model) {\n      xmlStream.addRollback();\n      xmlStream.openNode('alignment');\n      var isValid = false;\n\n      function add(name, value) {\n        if (value) {\n          xmlStream.addAttribute(name, value);\n          isValid = true;\n        }\n      }\n\n      add('horizontal', validation.horizontal(model.horizontal));\n      add('vertical', validation.vertical(model.vertical));\n      add('wrapText', validation.wrapText(model.wrapText) ? '1' : false);\n      add('shrinkToFit', validation.shrinkToFit(model.shrinkToFit) ? '1' : false);\n      add('indent', validation.indent(model.indent));\n      add('textRotation', textRotationXform.toXml(model.textRotation));\n      add('readingOrder', validation.readingOrder(model.readingOrder));\n      xmlStream.closeNode();\n\n      if (isValid) {\n        xmlStream.commit();\n      } else {\n        xmlStream.rollback();\n      }\n    }\n  }, {\n    key: \"parseOpen\",\n    value: function parseOpen(node) {\n      var model = {};\n      var valid = false;\n\n      function add(truthy, name, value) {\n        if (truthy) {\n          model[name] = value;\n          valid = true;\n        }\n      }\n\n      add(node.attributes.horizontal, 'horizontal', node.attributes.horizontal);\n      add(node.attributes.vertical, 'vertical', node.attributes.vertical === 'center' ? 'middle' : node.attributes.vertical);\n      add(node.attributes.wrapText, 'wrapText', !!node.attributes.wrapText);\n      add(node.attributes.shrinkToFit, 'shrinkToFit', !!node.attributes.shrinkToFit);\n      add(node.attributes.indent, 'indent', parseInt(node.attributes.indent, 10));\n      add(node.attributes.textRotation, 'textRotation', textRotationXform.toModel(node.attributes.textRotation));\n      add(node.attributes.readingOrder, 'readingOrder', node.attributes.readingOrder === '2' ? 'rtl' : 'ltr');\n      this.model = valid ? model : null;\n    }\n  }, {\n    key: \"parseText\",\n    value: function parseText() {}\n  }, {\n    key: \"parseClose\",\n    value: function parseClose() {\n      return false;\n    }\n  }, {\n    key: \"tag\",\n    get: function get() {\n      return 'alignment';\n    }\n  }]);\n\n  return AlignmentXform;\n}(BaseXform);\n\nmodule.exports = AlignmentXform;","map":{"version":3,"sources":["../../../../../lib/xlsx/xform/style/alignment-xform.js"],"names":["Enums","require","utils","BaseXform","validation","horizontalValues","p","horizontal","verticalValues","vertical","value","wrapText","shrinkToFit","textRotation","indent","Math","readingOrder","textRotationXform","toXml","tr","toModel","AlignmentXform","xmlStream","model","isValid","add","node","valid","parseInt","module"],"mappings":"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","sourcesContent":["const Enums = require('../../../doc/enums');\r\n\r\nconst utils = require('../../../utils/utils');\r\nconst BaseXform = require('../base-xform');\r\n\r\nconst validation = {\r\n  horizontalValues: [\r\n    'left',\r\n    'center',\r\n    'right',\r\n    'fill',\r\n    'centerContinuous',\r\n    'distributed',\r\n    'justify',\r\n  ].reduce((p, v) => {\r\n    p[v] = true;\r\n    return p;\r\n  }, {}),\r\n  horizontal(value) {\r\n    return this.horizontalValues[value] ? value : undefined;\r\n  },\r\n\r\n  verticalValues: ['top', 'middle', 'bottom', 'distributed', 'justify'].reduce((p, v) => {\r\n    p[v] = true;\r\n    return p;\r\n  }, {}),\r\n  vertical(value) {\r\n    if (value === 'middle') return 'center';\r\n    return this.verticalValues[value] ? value : undefined;\r\n  },\r\n  wrapText(value) {\r\n    return value ? true : undefined;\r\n  },\r\n  shrinkToFit(value) {\r\n    return value ? true : undefined;\r\n  },\r\n  textRotation(value) {\r\n    switch (value) {\r\n      case 'vertical':\r\n        return value;\r\n      default:\r\n        value = utils.validInt(value);\r\n        return value >= -90 && value <= 90 ? value : undefined;\r\n    }\r\n  },\r\n  indent(value) {\r\n    value = utils.validInt(value);\r\n    return Math.max(0, value);\r\n  },\r\n  readingOrder(value) {\r\n    switch (value) {\r\n      case 'ltr':\r\n        return Enums.ReadingOrder.LeftToRight;\r\n      case 'rtl':\r\n        return Enums.ReadingOrder.RightToLeft;\r\n      default:\r\n        return undefined;\r\n    }\r\n  },\r\n};\r\n\r\nconst textRotationXform = {\r\n  toXml(textRotation) {\r\n    textRotation = validation.textRotation(textRotation);\r\n    if (textRotation) {\r\n      if (textRotation === 'vertical') {\r\n        return 255;\r\n      }\r\n\r\n      const tr = Math.round(textRotation);\r\n      if (tr >= 0 && tr <= 90) {\r\n        return tr;\r\n      }\r\n\r\n      if (tr < 0 && tr >= -90) {\r\n        return 90 - tr;\r\n      }\r\n    }\r\n    return undefined;\r\n  },\r\n  toModel(textRotation) {\r\n    const tr = utils.validInt(textRotation);\r\n    if (tr !== undefined) {\r\n      if (tr === 255) {\r\n        return 'vertical';\r\n      }\r\n      if (tr >= 0 && tr <= 90) {\r\n        return tr;\r\n      }\r\n      if (tr > 90 && tr <= 180) {\r\n        return 90 - tr;\r\n      }\r\n    }\r\n    return undefined;\r\n  },\r\n};\r\n\r\n// Alignment encapsulates translation from style.alignment model to/from xlsx\r\nclass AlignmentXform extends BaseXform {\r\n  get tag() {\r\n    return 'alignment';\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    xmlStream.addRollback();\r\n    xmlStream.openNode('alignment');\r\n\r\n    let isValid = false;\r\n    function add(name, value) {\r\n      if (value) {\r\n        xmlStream.addAttribute(name, value);\r\n        isValid = true;\r\n      }\r\n    }\r\n    add('horizontal', validation.horizontal(model.horizontal));\r\n    add('vertical', validation.vertical(model.vertical));\r\n    add('wrapText', validation.wrapText(model.wrapText) ? '1' : false);\r\n    add('shrinkToFit', validation.shrinkToFit(model.shrinkToFit) ? '1' : false);\r\n    add('indent', validation.indent(model.indent));\r\n    add('textRotation', textRotationXform.toXml(model.textRotation));\r\n    add('readingOrder', validation.readingOrder(model.readingOrder));\r\n\r\n    xmlStream.closeNode();\r\n\r\n    if (isValid) {\r\n      xmlStream.commit();\r\n    } else {\r\n      xmlStream.rollback();\r\n    }\r\n  }\r\n\r\n  parseOpen(node) {\r\n    const model = {};\r\n\r\n    let valid = false;\r\n    function add(truthy, name, value) {\r\n      if (truthy) {\r\n        model[name] = value;\r\n        valid = true;\r\n      }\r\n    }\r\n    add(node.attributes.horizontal, 'horizontal', node.attributes.horizontal);\r\n    add(\r\n      node.attributes.vertical,\r\n      'vertical',\r\n      node.attributes.vertical === 'center' ? 'middle' : node.attributes.vertical\r\n    );\r\n    add(node.attributes.wrapText, 'wrapText', !!node.attributes.wrapText);\r\n    add(node.attributes.shrinkToFit, 'shrinkToFit', !!node.attributes.shrinkToFit);\r\n    add(node.attributes.indent, 'indent', parseInt(node.attributes.indent, 10));\r\n    add(\r\n      node.attributes.textRotation,\r\n      'textRotation',\r\n      textRotationXform.toModel(node.attributes.textRotation)\r\n    );\r\n    add(\r\n      node.attributes.readingOrder,\r\n      'readingOrder',\r\n      node.attributes.readingOrder === '2' ? 'rtl' : 'ltr'\r\n    );\r\n\r\n    this.model = valid ? model : null;\r\n  }\r\n\r\n  parseText() {}\r\n\r\n  parseClose() {\r\n    return false;\r\n  }\r\n}\r\n\r\nmodule.exports = AlignmentXform;\r\n"]},"metadata":{},"sourceType":"script"}