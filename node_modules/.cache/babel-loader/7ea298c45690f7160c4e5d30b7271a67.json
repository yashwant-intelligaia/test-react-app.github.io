{"ast":null,"code":"'use strict';\n\nvar crypto = require('crypto');\n\nvar Encryptor = {\n  /**\r\n   * Calculate a hash of the concatenated buffers with the given algorithm.\r\n   * @param {string} algorithm - The hash algorithm.\r\n   * @returns {Buffer} The hash\r\n   */\n  hash: function hash(algorithm) {\n    var hash = crypto.createHash(algorithm);\n\n    for (var _len = arguments.length, buffers = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      buffers[_key - 1] = arguments[_key];\n    }\n\n    hash.update(Buffer.concat(buffers));\n    return hash.digest();\n  },\n\n  /**\r\n   * Convert a password into an encryption key\r\n   * @param {string} password - The password\r\n   * @param {string} hashAlgorithm - The hash algoritm\r\n   * @param {string} saltValue - The salt value\r\n   * @param {number} spinCount - The spin count\r\n   * @param {number} keyBits - The length of the key in bits\r\n   * @param {Buffer} blockKey - The block key\r\n   * @returns {Buffer} The encryption key\r\n   */\n  convertPasswordToHash: function convertPasswordToHash(password, hashAlgorithm, saltValue, spinCount) {\n    hashAlgorithm = hashAlgorithm.toLowerCase();\n    var hashes = crypto.getHashes();\n\n    if (hashes.indexOf(hashAlgorithm) < 0) {\n      throw new Error(\"Hash algorithm '\".concat(hashAlgorithm, \"' not supported!\"));\n    } // Password must be in unicode buffer\n\n\n    var passwordBuffer = Buffer.from(password, 'utf16le'); // Generate the initial hash\n\n    var key = this.hash(hashAlgorithm, Buffer.from(saltValue, 'base64'), passwordBuffer); // Now regenerate until spin count\n\n    for (var i = 0; i < spinCount; i++) {\n      var iterator = Buffer.alloc(4); // this is the 'special' element of Excel password hashing\n      // that stops us from using crypto.pbkdf2()\n\n      iterator.writeUInt32LE(i, 0);\n      key = this.hash(hashAlgorithm, key, iterator);\n    }\n\n    return key.toString('base64');\n  },\n\n  /**\r\n   * Generates cryptographically strong pseudo-random data.\r\n   * @param size The size argument is a number indicating the number of bytes to generate.\r\n   */\n  randomBytes: function randomBytes(size) {\n    return crypto.randomBytes(size);\n  }\n};\nmodule.exports = Encryptor;","map":{"version":3,"sources":["../../../lib/utils/encryptor.js"],"names":["crypto","require","Encryptor","hash","buffers","Buffer","convertPasswordToHash","hashAlgorithm","hashes","passwordBuffer","key","i","iterator","randomBytes","module"],"mappings":"AAAA;;AAEA,IAAMA,MAAM,GAAGC,OAAO,CAAtB,QAAsB,CAAtB;;AAEA,IAAMC,SAAS,GAAG;AAChB;;;;;AAKAC,EAAAA,IANgB,EAAA,SAAA,IAAA,CAAA,SAAA,EAMY;AAC1B,QAAMA,IAAI,GAAGH,MAAM,CAANA,UAAAA,CAAb,SAAaA,CAAb;;AAD0B,SAAA,IAAA,IAAA,GAAA,SAAA,CAAA,MAAA,EAATI,OAAS,GAAA,IAAA,KAAA,CAAA,IAAA,GAAA,CAAA,GAAA,IAAA,GAAA,CAAA,GAAA,CAAA,CAAA,EAAA,IAAA,GAAA,CAAA,EAAA,IAAA,GAAA,IAAA,EAAA,IAAA,EAAA,EAAA;AAATA,MAAAA,OAAS,CAAA,IAAA,GAAA,CAAA,CAATA,GAAS,SAAA,CAAA,IAAA,CAATA;AAAS;;AAE1BD,IAAAA,IAAI,CAAJA,MAAAA,CAAYE,MAAM,CAANA,MAAAA,CAAZF,OAAYE,CAAZF;AACA,WAAOA,IAAI,CAAX,MAAOA,EAAP;AATc,GAAA;;AAWhB;;;;;;;;;;AAUAG,EAAAA,qBArBgB,EAAA,SAAA,qBAAA,CAAA,QAAA,EAAA,aAAA,EAAA,SAAA,EAAA,SAAA,EAqBqD;AACnEC,IAAAA,aAAa,GAAGA,aAAa,CAA7BA,WAAgBA,EAAhBA;AACA,QAAMC,MAAM,GAAGR,MAAM,CAArB,SAAeA,EAAf;;AACA,QAAIQ,MAAM,CAANA,OAAAA,CAAAA,aAAAA,IAAJ,CAAA,EAAuC;AACrC,YAAM,IAAA,KAAA,CAAA,mBAAA,MAAA,CAAA,aAAA,EAAN,kBAAM,CAAA,CAAN;AAJiE,KAAA,CAOnE;;;AACA,QAAMC,cAAc,GAAGJ,MAAM,CAANA,IAAAA,CAAAA,QAAAA,EAR4C,SAQ5CA,CAAvB,CARmE,CASnE;;AACA,QAAIK,GAAG,GAAG,KAAA,IAAA,CAAA,aAAA,EAAyBL,MAAM,CAANA,IAAAA,CAAAA,SAAAA,EAAzB,QAAyBA,CAAzB,EAVyD,cAUzD,CAAV,CAVmE,CAWnE;;AACA,SAAK,IAAIM,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAjB,SAAA,EAA+BA,CAA/B,EAAA,EAAoC;AAClC,UAAMC,QAAQ,GAAGP,MAAM,CAANA,KAAAA,CADiB,CACjBA,CAAjB,CADkC,CAElC;AACA;;AACAO,MAAAA,QAAQ,CAARA,aAAAA,CAAAA,CAAAA,EAAAA,CAAAA;AACAF,MAAAA,GAAG,GAAG,KAAA,IAAA,CAAA,aAAA,EAAA,GAAA,EAANA,QAAM,CAANA;AACD;;AACD,WAAOA,GAAG,CAAHA,QAAAA,CAAP,QAAOA,CAAP;AAxCc,GAAA;;AA0ChB;;;;AAIAG,EAAAA,WA9CgB,EAAA,SAAA,WAAA,CAAA,IAAA,EA8CE;AAChB,WAAOb,MAAM,CAANA,WAAAA,CAAP,IAAOA,CAAP;AACD;AAhDe,CAAlB;AAkDAc,MAAM,CAANA,OAAAA,GAAAA,SAAAA","sourcesContent":["'use strict';\r\n\r\nconst crypto = require('crypto');\r\n\r\nconst Encryptor = {\r\n  /**\r\n   * Calculate a hash of the concatenated buffers with the given algorithm.\r\n   * @param {string} algorithm - The hash algorithm.\r\n   * @returns {Buffer} The hash\r\n   */\r\n  hash(algorithm, ...buffers) {\r\n    const hash = crypto.createHash(algorithm);\r\n    hash.update(Buffer.concat(buffers));\r\n    return hash.digest();\r\n  },\r\n  /**\r\n   * Convert a password into an encryption key\r\n   * @param {string} password - The password\r\n   * @param {string} hashAlgorithm - The hash algoritm\r\n   * @param {string} saltValue - The salt value\r\n   * @param {number} spinCount - The spin count\r\n   * @param {number} keyBits - The length of the key in bits\r\n   * @param {Buffer} blockKey - The block key\r\n   * @returns {Buffer} The encryption key\r\n   */\r\n  convertPasswordToHash(password, hashAlgorithm, saltValue, spinCount) {\r\n    hashAlgorithm = hashAlgorithm.toLowerCase();\r\n    const hashes = crypto.getHashes();\r\n    if (hashes.indexOf(hashAlgorithm) < 0) {\r\n      throw new Error(`Hash algorithm '${hashAlgorithm}' not supported!`);\r\n    }\r\n\r\n    // Password must be in unicode buffer\r\n    const passwordBuffer = Buffer.from(password, 'utf16le');\r\n    // Generate the initial hash\r\n    let key = this.hash(hashAlgorithm, Buffer.from(saltValue, 'base64'), passwordBuffer);\r\n    // Now regenerate until spin count\r\n    for (let i = 0; i < spinCount; i++) {\r\n      const iterator = Buffer.alloc(4);\r\n      // this is the 'special' element of Excel password hashing\r\n      // that stops us from using crypto.pbkdf2()\r\n      iterator.writeUInt32LE(i, 0);\r\n      key = this.hash(hashAlgorithm, key, iterator);\r\n    }\r\n    return key.toString('base64');\r\n  },\r\n  /**\r\n   * Generates cryptographically strong pseudo-random data.\r\n   * @param size The size argument is a number indicating the number of bytes to generate.\r\n   */\r\n  randomBytes(size) {\r\n    return crypto.randomBytes(size);\r\n  },\r\n};\r\nmodule.exports = Encryptor;\r\n"]},"metadata":{},"sourceType":"script"}