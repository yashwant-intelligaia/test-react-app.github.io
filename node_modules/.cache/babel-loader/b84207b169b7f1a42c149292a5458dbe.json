{"ast":null,"code":"\"use strict\";\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nvar XmlStream = require('../../../utils/xml-stream');\n\nvar BaseXform = require('../base-xform');\n\nvar ListXform = require('../list-xform');\n\nvar AutoFilterXform = require('./auto-filter-xform');\n\nvar TableColumnXform = require('./table-column-xform');\n\nvar TableStyleInfoXform = require('./table-style-info-xform');\n\nvar TableXform = /*#__PURE__*/function (_BaseXform) {\n  _inherits(TableXform, _BaseXform);\n\n  var _super = _createSuper(TableXform);\n\n  function TableXform() {\n    var _this;\n\n    _classCallCheck(this, TableXform);\n\n    _this = _super.call(this);\n    _this.map = {\n      autoFilter: new AutoFilterXform(),\n      tableColumns: new ListXform({\n        tag: 'tableColumns',\n        count: true,\n        empty: true,\n        childXform: new TableColumnXform()\n      }),\n      tableStyleInfo: new TableStyleInfoXform()\n    };\n    return _this;\n  }\n\n  _createClass(TableXform, [{\n    key: \"prepare\",\n    value: function prepare(model, options) {\n      this.map.autoFilter.prepare(model);\n      this.map.tableColumns.prepare(model.columns, options);\n    }\n  }, {\n    key: \"render\",\n    value: function render(xmlStream, model) {\n      xmlStream.openXml(XmlStream.StdDocAttributes);\n      xmlStream.openNode(this.tag, _objectSpread(_objectSpread({}, TableXform.TABLE_ATTRIBUTES), {}, {\n        id: model.id,\n        name: model.name,\n        displayName: model.displayName || model.name,\n        ref: model.tableRef,\n        totalsRowCount: model.totalsRow ? '1' : undefined,\n        totalsRowShown: model.totalsRow ? undefined : '1',\n        headerRowCount: model.headerRow ? '1' : '0'\n      }));\n      this.map.autoFilter.render(xmlStream, model);\n      this.map.tableColumns.render(xmlStream, model.columns);\n      this.map.tableStyleInfo.render(xmlStream, model.style);\n      xmlStream.closeNode();\n    }\n  }, {\n    key: \"parseOpen\",\n    value: function parseOpen(node) {\n      if (this.parser) {\n        this.parser.parseOpen(node);\n        return true;\n      }\n\n      var name = node.name,\n          attributes = node.attributes;\n\n      switch (name) {\n        case this.tag:\n          this.reset();\n          this.model = {\n            name: attributes.name,\n            displayName: attributes.displayName || attributes.name,\n            tableRef: attributes.ref,\n            totalsRow: attributes.totalsRowCount === '1',\n            headerRow: attributes.headerRowCount === '1'\n          };\n          break;\n\n        default:\n          this.parser = this.map[node.name];\n\n          if (this.parser) {\n            this.parser.parseOpen(node);\n          }\n\n          break;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"parseText\",\n    value: function parseText(text) {\n      if (this.parser) {\n        this.parser.parseText(text);\n      }\n    }\n  }, {\n    key: \"parseClose\",\n    value: function parseClose(name) {\n      var _this2 = this;\n\n      if (this.parser) {\n        if (!this.parser.parseClose(name)) {\n          this.parser = undefined;\n        }\n\n        return true;\n      }\n\n      switch (name) {\n        case this.tag:\n          this.model.columns = this.map.tableColumns.model;\n\n          if (this.map.autoFilter.model) {\n            this.model.autoFilterRef = this.map.autoFilter.model.autoFilterRef;\n            this.map.autoFilter.model.columns.forEach(function (column, index) {\n              _this2.model.columns[index].filterButton = column.filterButton;\n            });\n          }\n\n          this.model.style = this.map.tableStyleInfo.model;\n          return false;\n\n        default:\n          // could be some unrecognised tags\n          return true;\n      }\n    }\n  }, {\n    key: \"reconcile\",\n    value: function reconcile(model, options) {\n      // fetch the dfxs from styles\n      model.columns.forEach(function (column) {\n        if (column.dxfId !== undefined) {\n          column.style = options.styles.getDxfStyle(column.dxfId);\n        }\n      });\n    }\n  }, {\n    key: \"tag\",\n    get: function get() {\n      return 'table';\n    }\n  }]);\n\n  return TableXform;\n}(BaseXform);\n\nTableXform.TABLE_ATTRIBUTES = {\n  xmlns: 'http://schemas.openxmlformats.org/spreadsheetml/2006/main',\n  'xmlns:mc': 'http://schemas.openxmlformats.org/markup-compatibility/2006',\n  'mc:Ignorable': 'xr xr3',\n  'xmlns:xr': 'http://schemas.microsoft.com/office/spreadsheetml/2014/revision',\n  'xmlns:xr3': 'http://schemas.microsoft.com/office/spreadsheetml/2016/revision3' // 'xr:uid': '{00000000-000C-0000-FFFF-FFFF00000000}',\n\n};\nmodule.exports = TableXform;","map":{"version":3,"sources":["../../../../../lib/xlsx/xform/table/table-xform.js"],"names":["XmlStream","require","BaseXform","ListXform","AutoFilterXform","TableColumnXform","TableStyleInfoXform","TableXform","autoFilter","tableColumns","tag","count","empty","childXform","tableStyleInfo","model","options","xmlStream","id","name","displayName","ref","totalsRowCount","totalsRowShown","headerRowCount","node","attributes","tableRef","totalsRow","headerRow","text","column","xmlns","module"],"mappings":"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","sourcesContent":["const XmlStream = require('../../../utils/xml-stream');\r\n\r\nconst BaseXform = require('../base-xform');\r\nconst ListXform = require('../list-xform');\r\n\r\nconst AutoFilterXform = require('./auto-filter-xform');\r\nconst TableColumnXform = require('./table-column-xform');\r\nconst TableStyleInfoXform = require('./table-style-info-xform');\r\n\r\nclass TableXform extends BaseXform {\r\n  constructor() {\r\n    super();\r\n\r\n    this.map = {\r\n      autoFilter: new AutoFilterXform(),\r\n      tableColumns: new ListXform({\r\n        tag: 'tableColumns',\r\n        count: true,\r\n        empty: true,\r\n        childXform: new TableColumnXform(),\r\n      }),\r\n      tableStyleInfo: new TableStyleInfoXform(),\r\n    };\r\n  }\r\n\r\n  prepare(model, options) {\r\n    this.map.autoFilter.prepare(model);\r\n    this.map.tableColumns.prepare(model.columns, options);\r\n  }\r\n\r\n  get tag() {\r\n    return 'table';\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    xmlStream.openXml(XmlStream.StdDocAttributes);\r\n    xmlStream.openNode(this.tag, {\r\n      ...TableXform.TABLE_ATTRIBUTES,\r\n      id: model.id,\r\n      name: model.name,\r\n      displayName: model.displayName || model.name,\r\n      ref: model.tableRef,\r\n      totalsRowCount: model.totalsRow ? '1' : undefined,\r\n      totalsRowShown: model.totalsRow ? undefined : '1',\r\n      headerRowCount: model.headerRow ? '1' : '0',\r\n    });\r\n\r\n    this.map.autoFilter.render(xmlStream, model);\r\n    this.map.tableColumns.render(xmlStream, model.columns);\r\n    this.map.tableStyleInfo.render(xmlStream, model.style);\r\n\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  parseOpen(node) {\r\n    if (this.parser) {\r\n      this.parser.parseOpen(node);\r\n      return true;\r\n    }\r\n    const {name, attributes} = node;\r\n    switch (name) {\r\n      case this.tag:\r\n        this.reset();\r\n        this.model = {\r\n          name: attributes.name,\r\n          displayName: attributes.displayName || attributes.name,\r\n          tableRef: attributes.ref,\r\n          totalsRow: attributes.totalsRowCount === '1',\r\n          headerRow: attributes.headerRowCount === '1',\r\n        };\r\n        break;\r\n      default:\r\n        this.parser = this.map[node.name];\r\n        if (this.parser) {\r\n          this.parser.parseOpen(node);\r\n        }\r\n        break;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  parseText(text) {\r\n    if (this.parser) {\r\n      this.parser.parseText(text);\r\n    }\r\n  }\r\n\r\n  parseClose(name) {\r\n    if (this.parser) {\r\n      if (!this.parser.parseClose(name)) {\r\n        this.parser = undefined;\r\n      }\r\n      return true;\r\n    }\r\n    switch (name) {\r\n      case this.tag:\r\n        this.model.columns = this.map.tableColumns.model;\r\n        if (this.map.autoFilter.model) {\r\n          this.model.autoFilterRef = this.map.autoFilter.model.autoFilterRef;\r\n          this.map.autoFilter.model.columns.forEach((column, index) => {\r\n            this.model.columns[index].filterButton = column.filterButton;\r\n          });\r\n        }\r\n        this.model.style = this.map.tableStyleInfo.model;\r\n        return false;\r\n      default:\r\n        // could be some unrecognised tags\r\n        return true;\r\n    }\r\n  }\r\n\r\n  reconcile(model, options) {\r\n    // fetch the dfxs from styles\r\n    model.columns.forEach(column => {\r\n      if (column.dxfId !== undefined) {\r\n        column.style = options.styles.getDxfStyle(column.dxfId);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nTableXform.TABLE_ATTRIBUTES = {\r\n  xmlns: 'http://schemas.openxmlformats.org/spreadsheetml/2006/main',\r\n  'xmlns:mc': 'http://schemas.openxmlformats.org/markup-compatibility/2006',\r\n  'mc:Ignorable': 'xr xr3',\r\n  'xmlns:xr': 'http://schemas.microsoft.com/office/spreadsheetml/2014/revision',\r\n  'xmlns:xr3': 'http://schemas.microsoft.com/office/spreadsheetml/2016/revision3',\r\n  // 'xr:uid': '{00000000-000C-0000-FFFF-FFFF00000000}',\r\n};\r\n\r\nmodule.exports = TableXform;\r\n"]},"metadata":{},"sourceType":"script"}