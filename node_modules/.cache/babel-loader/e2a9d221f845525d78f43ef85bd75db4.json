{"ast":null,"code":"\"use strict\";\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nvar BaseXform = require('../base-xform');\n\nvar CellXform = require('./cell-xform');\n\nvar RowXform = /*#__PURE__*/function (_BaseXform) {\n  _inherits(RowXform, _BaseXform);\n\n  var _super = _createSuper(RowXform);\n\n  function RowXform(options) {\n    var _this;\n\n    _classCallCheck(this, RowXform);\n\n    _this = _super.call(this);\n    _this.maxItems = options && options.maxItems;\n    _this.map = {\n      c: new CellXform()\n    };\n    return _this;\n  }\n\n  _createClass(RowXform, [{\n    key: \"prepare\",\n    value: function prepare(model, options) {\n      var styleId = options.styles.addStyleModel(model.style);\n\n      if (styleId) {\n        model.styleId = styleId;\n      }\n\n      var cellXform = this.map.c;\n      model.cells.forEach(function (cellModel) {\n        cellXform.prepare(cellModel, options);\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render(xmlStream, model, options) {\n      xmlStream.openNode('row');\n      xmlStream.addAttribute('r', model.number);\n\n      if (model.height) {\n        xmlStream.addAttribute('ht', model.height);\n        xmlStream.addAttribute('customHeight', '1');\n      }\n\n      if (model.hidden) {\n        xmlStream.addAttribute('hidden', '1');\n      }\n\n      if (model.min > 0 && model.max > 0 && model.min <= model.max) {\n        xmlStream.addAttribute('spans', \"\".concat(model.min, \":\").concat(model.max));\n      }\n\n      if (model.styleId) {\n        xmlStream.addAttribute('s', model.styleId);\n        xmlStream.addAttribute('customFormat', '1');\n      }\n\n      xmlStream.addAttribute('x14ac:dyDescent', '0.25');\n\n      if (model.outlineLevel) {\n        xmlStream.addAttribute('outlineLevel', model.outlineLevel);\n      }\n\n      if (model.collapsed) {\n        xmlStream.addAttribute('collapsed', '1');\n      }\n\n      var cellXform = this.map.c;\n      model.cells.forEach(function (cellModel) {\n        cellXform.render(xmlStream, cellModel, options);\n      });\n      xmlStream.closeNode();\n    }\n  }, {\n    key: \"parseOpen\",\n    value: function parseOpen(node) {\n      if (this.parser) {\n        this.parser.parseOpen(node);\n        return true;\n      }\n\n      if (node.name === 'row') {\n        this.numRowsSeen += 1;\n        var spans = node.attributes.spans ? node.attributes.spans.split(':').map(function (span) {\n          return parseInt(span, 10);\n        }) : [undefined, undefined];\n        var model = this.model = {\n          number: parseInt(node.attributes.r, 10),\n          min: spans[0],\n          max: spans[1],\n          cells: []\n        };\n\n        if (node.attributes.s) {\n          model.styleId = parseInt(node.attributes.s, 10);\n        }\n\n        if (node.attributes.hidden === true || node.attributes.hidden === 'true' || node.attributes.hidden === 1 || node.attributes.hidden === '1') {\n          model.hidden = true;\n        }\n\n        if (node.attributes.bestFit) {\n          model.bestFit = true;\n        }\n\n        if (node.attributes.ht) {\n          model.height = parseFloat(node.attributes.ht);\n        }\n\n        if (node.attributes.outlineLevel) {\n          model.outlineLevel = parseInt(node.attributes.outlineLevel, 10);\n        }\n\n        if (node.attributes.collapsed) {\n          model.collapsed = true;\n        }\n\n        return true;\n      }\n\n      this.parser = this.map[node.name];\n\n      if (this.parser) {\n        this.parser.parseOpen(node);\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"parseText\",\n    value: function parseText(text) {\n      if (this.parser) {\n        this.parser.parseText(text);\n      }\n    }\n  }, {\n    key: \"parseClose\",\n    value: function parseClose(name) {\n      if (this.parser) {\n        if (!this.parser.parseClose(name)) {\n          this.model.cells.push(this.parser.model);\n\n          if (this.maxItems && this.model.cells.length > this.maxItems) {\n            throw new Error(\"Max column count (\".concat(this.maxItems, \") exceeded\"));\n          }\n\n          this.parser = undefined;\n        }\n\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"reconcile\",\n    value: function reconcile(model, options) {\n      model.style = model.styleId ? options.styles.getStyleModel(model.styleId) : {};\n\n      if (model.styleId !== undefined) {\n        model.styleId = undefined;\n      }\n\n      var cellXform = this.map.c;\n      model.cells.forEach(function (cellModel) {\n        cellXform.reconcile(cellModel, options);\n      });\n    }\n  }, {\n    key: \"tag\",\n    get: function get() {\n      return 'row';\n    }\n  }]);\n\n  return RowXform;\n}(BaseXform);\n\nmodule.exports = RowXform;","map":{"version":3,"sources":["../../../../../lib/xlsx/xform/sheet/row-xform.js"],"names":["BaseXform","require","CellXform","RowXform","options","c","model","styleId","cellXform","xmlStream","node","spans","parseInt","number","min","max","cells","parseFloat","text","name","module"],"mappings":"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","sourcesContent":["const BaseXform = require('../base-xform');\r\n\r\nconst CellXform = require('./cell-xform');\r\n\r\nclass RowXform extends BaseXform {\r\n  constructor(options) {\r\n    super();\r\n\r\n    this.maxItems = options && options.maxItems;\r\n    this.map = {\r\n      c: new CellXform(),\r\n    };\r\n  }\r\n\r\n  get tag() {\r\n    return 'row';\r\n  }\r\n\r\n  prepare(model, options) {\r\n    const styleId = options.styles.addStyleModel(model.style);\r\n    if (styleId) {\r\n      model.styleId = styleId;\r\n    }\r\n    const cellXform = this.map.c;\r\n    model.cells.forEach(cellModel => {\r\n      cellXform.prepare(cellModel, options);\r\n    });\r\n  }\r\n\r\n  render(xmlStream, model, options) {\r\n    xmlStream.openNode('row');\r\n    xmlStream.addAttribute('r', model.number);\r\n    if (model.height) {\r\n      xmlStream.addAttribute('ht', model.height);\r\n      xmlStream.addAttribute('customHeight', '1');\r\n    }\r\n    if (model.hidden) {\r\n      xmlStream.addAttribute('hidden', '1');\r\n    }\r\n    if (model.min > 0 && model.max > 0 && model.min <= model.max) {\r\n      xmlStream.addAttribute('spans', `${model.min}:${model.max}`);\r\n    }\r\n    if (model.styleId) {\r\n      xmlStream.addAttribute('s', model.styleId);\r\n      xmlStream.addAttribute('customFormat', '1');\r\n    }\r\n    xmlStream.addAttribute('x14ac:dyDescent', '0.25');\r\n    if (model.outlineLevel) {\r\n      xmlStream.addAttribute('outlineLevel', model.outlineLevel);\r\n    }\r\n    if (model.collapsed) {\r\n      xmlStream.addAttribute('collapsed', '1');\r\n    }\r\n\r\n    const cellXform = this.map.c;\r\n    model.cells.forEach(cellModel => {\r\n      cellXform.render(xmlStream, cellModel, options);\r\n    });\r\n\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  parseOpen(node) {\r\n    if (this.parser) {\r\n      this.parser.parseOpen(node);\r\n      return true;\r\n    }\r\n    if (node.name === 'row') {\r\n      this.numRowsSeen += 1;\r\n      const spans = node.attributes.spans\r\n        ? node.attributes.spans.split(':').map(span => parseInt(span, 10))\r\n        : [undefined, undefined];\r\n      const model = (this.model = {\r\n        number: parseInt(node.attributes.r, 10),\r\n        min: spans[0],\r\n        max: spans[1],\r\n        cells: [],\r\n      });\r\n      if (node.attributes.s) {\r\n        model.styleId = parseInt(node.attributes.s, 10);\r\n      }\r\n      if (\r\n        node.attributes.hidden === true ||\r\n        node.attributes.hidden === 'true' ||\r\n        node.attributes.hidden === 1 ||\r\n        node.attributes.hidden === '1'\r\n      ) {\r\n        model.hidden = true;\r\n      }\r\n      if (node.attributes.bestFit) {\r\n        model.bestFit = true;\r\n      }\r\n      if (node.attributes.ht) {\r\n        model.height = parseFloat(node.attributes.ht);\r\n      }\r\n      if (node.attributes.outlineLevel) {\r\n        model.outlineLevel = parseInt(node.attributes.outlineLevel, 10);\r\n      }\r\n      if (node.attributes.collapsed) {\r\n        model.collapsed = true;\r\n      }\r\n      return true;\r\n    }\r\n\r\n    this.parser = this.map[node.name];\r\n    if (this.parser) {\r\n      this.parser.parseOpen(node);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  parseText(text) {\r\n    if (this.parser) {\r\n      this.parser.parseText(text);\r\n    }\r\n  }\r\n\r\n  parseClose(name) {\r\n    if (this.parser) {\r\n      if (!this.parser.parseClose(name)) {\r\n        this.model.cells.push(this.parser.model);\r\n        if (this.maxItems && this.model.cells.length > this.maxItems) {\r\n          throw new Error(`Max column count (${this.maxItems}) exceeded`);\r\n        }\r\n        this.parser = undefined;\r\n      }\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  reconcile(model, options) {\r\n    model.style = model.styleId ? options.styles.getStyleModel(model.styleId) : {};\r\n    if (model.styleId !== undefined) {\r\n      model.styleId = undefined;\r\n    }\r\n\r\n    const cellXform = this.map.c;\r\n    model.cells.forEach(cellModel => {\r\n      cellXform.reconcile(cellModel, options);\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = RowXform;\r\n"]},"metadata":{},"sourceType":"script"}