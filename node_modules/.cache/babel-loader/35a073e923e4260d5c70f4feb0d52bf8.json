{"ast":null,"code":"\"use strict\";\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nvar _ = require('../../../utils/under-dash');\n\nvar Range = require('../../../doc/range');\n\nvar colCache = require('../../../utils/col-cache');\n\nvar Enums = require('../../../doc/enums');\n\nvar Merges = /*#__PURE__*/function () {\n  function Merges() {\n    _classCallCheck(this, Merges); // optional mergeCells is array of ranges (like the xml)\n\n\n    this.merges = {};\n  }\n\n  _createClass(Merges, [{\n    key: \"add\",\n    value: function add(merge) {\n      // merge is {address, master}\n      if (this.merges[merge.master]) {\n        this.merges[merge.master].expandToAddress(merge.address);\n      } else {\n        var range = \"\".concat(merge.master, \":\").concat(merge.address);\n        this.merges[merge.master] = new Range(range);\n      }\n    }\n  }, {\n    key: \"reconcile\",\n    value: function reconcile(mergeCells, rows) {\n      // reconcile merge list with merge cells\n      _.each(mergeCells, function (merge) {\n        var dimensions = colCache.decode(merge);\n\n        for (var i = dimensions.top; i <= dimensions.bottom; i++) {\n          var row = rows[i - 1];\n\n          for (var j = dimensions.left; j <= dimensions.right; j++) {\n            var cell = row.cells[j - 1];\n\n            if (!cell) {\n              // nulls are not included in document - so if master cell has no value - add a null one here\n              row.cells[j] = {\n                type: Enums.ValueType.Null,\n                address: colCache.encodeAddress(i, j)\n              };\n            } else if (cell.type === Enums.ValueType.Merge) {\n              cell.master = dimensions.tl;\n            }\n          }\n        }\n      });\n    }\n  }, {\n    key: \"getMasterAddress\",\n    value: function getMasterAddress(address) {\n      // if address has been merged, return its master's address. Assumes reconcile has been called\n      var range = this.hash[address];\n      return range && range.tl;\n    }\n  }, {\n    key: \"mergeCells\",\n    get: function get() {\n      return _.map(this.merges, function (merge) {\n        return merge.range;\n      });\n    }\n  }]);\n\n  return Merges;\n}();\n\nmodule.exports = Merges;","map":{"version":3,"sources":["../../../../../lib/xlsx/xform/sheet/merges.js"],"names":["_","require","Range","colCache","Enums","Merges","merge","range","mergeCells","rows","dimensions","i","row","j","cell","type","address","module"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAMA,CAAC,GAAGC,OAAO,CAAjB,2BAAiB,CAAjB;;AAEA,IAAMC,KAAK,GAAGD,OAAO,CAArB,oBAAqB,CAArB;;AACA,IAAME,QAAQ,GAAGF,OAAO,CAAxB,0BAAwB,CAAxB;;AACA,IAAMG,KAAK,GAAGH,OAAO,CAArB,oBAAqB,CAArB;;IAEMI,M;AACJ,WAAA,MAAA,GAAc;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,MAAA,CAAA,CAAA,CACZ;;;AACA,SAAA,MAAA,GAAA,EAAA;AACD;;;;wBAEGC,K,EAAO;AACT;AACA,UAAI,KAAA,MAAA,CAAYA,KAAK,CAArB,MAAI,CAAJ,EAA+B;AAC7B,aAAA,MAAA,CAAYA,KAAK,CAAjB,MAAA,EAAA,eAAA,CAA0CA,KAAK,CAA/C,OAAA;AADF,OAAA,MAEO;AACL,YAAMC,KAAK,GAAA,GAAA,MAAA,CAAMD,KAAK,CAAX,MAAA,EAAA,GAAA,EAAA,MAAA,CAAsBA,KAAK,CAAtC,OAAW,CAAX;AACA,aAAA,MAAA,CAAYA,KAAK,CAAjB,MAAA,IAA4B,IAAA,KAAA,CAA5B,KAA4B,CAA5B;AACD;AACF;;;8BAMSE,U,EAAYC,I,EAAM;AAC1B;AACAT,MAAAA,CAAC,CAADA,IAAAA,CAAAA,UAAAA,EAAmB,UAAA,KAAA,EAAS;AAC1B,YAAMU,UAAU,GAAGP,QAAQ,CAARA,MAAAA,CAAnB,KAAmBA,CAAnB;;AACA,aAAK,IAAIQ,CAAC,GAAGD,UAAU,CAAvB,GAAA,EAA6BC,CAAC,IAAID,UAAU,CAA5C,MAAA,EAAqDC,CAArD,EAAA,EAA0D;AACxD,cAAMC,GAAG,GAAGH,IAAI,CAACE,CAAC,GAAlB,CAAgB,CAAhB;;AACA,eAAK,IAAIE,CAAC,GAAGH,UAAU,CAAvB,IAAA,EAA8BG,CAAC,IAAIH,UAAU,CAA7C,KAAA,EAAqDG,CAArD,EAAA,EAA0D;AACxD,gBAAMC,IAAI,GAAGF,GAAG,CAAHA,KAAAA,CAAUC,CAAC,GAAxB,CAAaD,CAAb;;AACA,gBAAI,CAAJ,IAAA,EAAW;AACT;AACAA,cAAAA,GAAG,CAAHA,KAAAA,CAAAA,CAAAA,IAAe;AACbG,gBAAAA,IAAI,EAAEX,KAAK,CAALA,SAAAA,CADO,IAAA;AAEbY,gBAAAA,OAAO,EAAEb,QAAQ,CAARA,aAAAA,CAAAA,CAAAA,EAAAA,CAAAA;AAFI,eAAfS;AAFF,aAAA,MAMO,IAAIE,IAAI,CAAJA,IAAAA,KAAcV,KAAK,CAALA,SAAAA,CAAlB,KAAA,EAAyC;AAC9CU,cAAAA,IAAI,CAAJA,MAAAA,GAAcJ,UAAU,CAAxBI,EAAAA;AACD;AACF;AACF;AAhBHd,OAAAA;AAkBD;;;qCAEgBgB,O,EAAS;AACxB;AACA,UAAMT,KAAK,GAAG,KAAA,IAAA,CAAd,OAAc,CAAd;AACA,aAAOA,KAAK,IAAIA,KAAK,CAArB,EAAA;AACD;;;wBA9BgB;AACf,aAAO,CAAC,CAAD,GAAA,CAAM,KAAN,MAAA,EAAmB,UAAA,KAAA,EAAK;AAAA,eAAID,KAAK,CAAT,KAAA;AAA/B,OAAO,CAAP;AACD;;;;;;AA+BHW,MAAM,CAANA,OAAAA,GAAAA,MAAAA","sourcesContent":["const _ = require('../../../utils/under-dash');\r\n\r\nconst Range = require('../../../doc/range');\r\nconst colCache = require('../../../utils/col-cache');\r\nconst Enums = require('../../../doc/enums');\r\n\r\nclass Merges {\r\n  constructor() {\r\n    // optional mergeCells is array of ranges (like the xml)\r\n    this.merges = {};\r\n  }\r\n\r\n  add(merge) {\r\n    // merge is {address, master}\r\n    if (this.merges[merge.master]) {\r\n      this.merges[merge.master].expandToAddress(merge.address);\r\n    } else {\r\n      const range = `${merge.master}:${merge.address}`;\r\n      this.merges[merge.master] = new Range(range);\r\n    }\r\n  }\r\n\r\n  get mergeCells() {\r\n    return _.map(this.merges, merge => merge.range);\r\n  }\r\n\r\n  reconcile(mergeCells, rows) {\r\n    // reconcile merge list with merge cells\r\n    _.each(mergeCells, merge => {\r\n      const dimensions = colCache.decode(merge);\r\n      for (let i = dimensions.top; i <= dimensions.bottom; i++) {\r\n        const row = rows[i - 1];\r\n        for (let j = dimensions.left; j <= dimensions.right; j++) {\r\n          const cell = row.cells[j - 1];\r\n          if (!cell) {\r\n            // nulls are not included in document - so if master cell has no value - add a null one here\r\n            row.cells[j] = {\r\n              type: Enums.ValueType.Null,\r\n              address: colCache.encodeAddress(i, j),\r\n            };\r\n          } else if (cell.type === Enums.ValueType.Merge) {\r\n            cell.master = dimensions.tl;\r\n          }\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  getMasterAddress(address) {\r\n    // if address has been merged, return its master's address. Assumes reconcile has been called\r\n    const range = this.hash[address];\r\n    return range && range.tl;\r\n  }\r\n}\r\n\r\nmodule.exports = Merges;\r\n"]},"metadata":{},"sourceType":"script"}