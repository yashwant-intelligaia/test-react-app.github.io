{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FieldFormatter = void 0;\n\nconst lodash_isboolean_1 = __importDefault(require(\"lodash.isboolean\"));\n\nconst lodash_isnil_1 = __importDefault(require(\"lodash.isnil\"));\n\nconst lodash_escaperegexp_1 = __importDefault(require(\"lodash.escaperegexp\"));\n\nclass FieldFormatter {\n  constructor(formatterOptions) {\n    this._headers = null;\n    this.formatterOptions = formatterOptions;\n\n    if (formatterOptions.headers !== null) {\n      this.headers = formatterOptions.headers;\n    }\n\n    this.REPLACE_REGEXP = new RegExp(formatterOptions.quote, 'g');\n    const escapePattern = `[${formatterOptions.delimiter}${lodash_escaperegexp_1.default(formatterOptions.rowDelimiter)}|\\r|\\n]`;\n    this.ESCAPE_REGEXP = new RegExp(escapePattern);\n  }\n\n  set headers(headers) {\n    this._headers = headers;\n  }\n\n  shouldQuote(fieldIndex, isHeader) {\n    const quoteConfig = isHeader ? this.formatterOptions.quoteHeaders : this.formatterOptions.quoteColumns;\n\n    if (lodash_isboolean_1.default(quoteConfig)) {\n      return quoteConfig;\n    }\n\n    if (Array.isArray(quoteConfig)) {\n      return quoteConfig[fieldIndex];\n    }\n\n    if (this._headers !== null) {\n      return quoteConfig[this._headers[fieldIndex]];\n    }\n\n    return false;\n  }\n\n  format(field, fieldIndex, isHeader) {\n    const preparedField = `${lodash_isnil_1.default(field) ? '' : field}`.replace(/\\0/g, '');\n    const {\n      formatterOptions\n    } = this;\n\n    if (formatterOptions.quote !== '') {\n      const shouldEscape = preparedField.indexOf(formatterOptions.quote) !== -1;\n\n      if (shouldEscape) {\n        return this.quoteField(preparedField.replace(this.REPLACE_REGEXP, formatterOptions.escapedQuote));\n      }\n    }\n\n    const hasEscapeCharacters = preparedField.search(this.ESCAPE_REGEXP) !== -1;\n\n    if (hasEscapeCharacters || this.shouldQuote(fieldIndex, isHeader)) {\n      return this.quoteField(preparedField);\n    }\n\n    return preparedField;\n  }\n\n  quoteField(field) {\n    const {\n      quote\n    } = this.formatterOptions;\n    return `${quote}${field}${quote}`;\n  }\n\n}\n\nexports.FieldFormatter = FieldFormatter;","map":{"version":3,"sources":["../../../src/formatter/FieldFormatter.ts"],"names":[],"mappings":";;;;;;;;;;;;;AAAA,MAAA,kBAAA,GAAA,eAAA,CAAA,OAAA,CAAA,kBAAA,CAAA,CAAA;;AACA,MAAA,cAAA,GAAA,eAAA,CAAA,OAAA,CAAA,cAAA,CAAA,CAAA;;AACA,MAAA,qBAAA,GAAA,eAAA,CAAA,OAAA,CAAA,qBAAA,CAAA,CAAA;;AAIA,MAAa,cAAb,CAA2B;AASvB,EAAA,WAAA,CAAmB,gBAAnB,EAA2D;AANnD,SAAA,QAAA,GAA4B,IAA5B;AAOJ,SAAK,gBAAL,GAAwB,gBAAxB;;AACA,QAAI,gBAAgB,CAAC,OAAjB,KAA6B,IAAjC,EAAuC;AACnC,WAAK,OAAL,GAAe,gBAAgB,CAAC,OAAhC;AACH;;AACD,SAAK,cAAL,GAAsB,IAAI,MAAJ,CAAW,gBAAgB,CAAC,KAA5B,EAAmC,GAAnC,CAAtB;AACA,UAAM,aAAa,GAAG,IAAI,gBAAgB,CAAC,SAAS,GAAG,qBAAA,CAAA,OAAA,CAAa,gBAAgB,CAAC,YAA9B,CAA2C,SAAlG;AACA,SAAK,aAAL,GAAqB,IAAI,MAAJ,CAAW,aAAX,CAArB;AACH;;AAED,MAAW,OAAX,CAAmB,OAAnB,EAAoC;AAChC,SAAK,QAAL,GAAgB,OAAhB;AACH;;AAEO,EAAA,WAAW,CAAC,UAAD,EAAqB,QAArB,EAAsC;AACrD,UAAM,WAAW,GAAG,QAAQ,GAAG,KAAK,gBAAL,CAAsB,YAAzB,GAAwC,KAAK,gBAAL,CAAsB,YAA1F;;AACA,QAAI,kBAAA,CAAA,OAAA,CAAU,WAAV,CAAJ,EAA4B;AACxB,aAAO,WAAP;AACH;;AACD,QAAI,KAAK,CAAC,OAAN,CAAc,WAAd,CAAJ,EAAgC;AAC5B,aAAO,WAAW,CAAC,UAAD,CAAlB;AACH;;AACD,QAAI,KAAK,QAAL,KAAkB,IAAtB,EAA4B;AACxB,aAAO,WAAW,CAAC,KAAK,QAAL,CAAc,UAAd,CAAD,CAAlB;AACH;;AACD,WAAO,KAAP;AACH;;AAEM,EAAA,MAAM,CAAC,KAAD,EAAgB,UAAhB,EAAoC,QAApC,EAAqD;AAC9D,UAAM,aAAa,GAAG,GAAG,cAAA,CAAA,OAAA,CAAM,KAAN,IAAe,EAAf,GAAoB,KAAK,EAA5B,CAA+B,OAA/B,CAAuC,KAAvC,EAA8C,EAA9C,CAAtB;AACA,UAAM;AAAE,MAAA;AAAF,QAAuB,IAA7B;;AACA,QAAI,gBAAgB,CAAC,KAAjB,KAA2B,EAA/B,EAAmC;AAC/B,YAAM,YAAY,GAAG,aAAa,CAAC,OAAd,CAAsB,gBAAgB,CAAC,KAAvC,MAAkD,CAAC,CAAxE;;AACA,UAAI,YAAJ,EAAkB;AACd,eAAO,KAAK,UAAL,CAAgB,aAAa,CAAC,OAAd,CAAsB,KAAK,cAA3B,EAA2C,gBAAgB,CAAC,YAA5D,CAAhB,CAAP;AACH;AACJ;;AACD,UAAM,mBAAmB,GAAG,aAAa,CAAC,MAAd,CAAqB,KAAK,aAA1B,MAA6C,CAAC,CAA1E;;AACA,QAAI,mBAAmB,IAAI,KAAK,WAAL,CAAiB,UAAjB,EAA6B,QAA7B,CAA3B,EAAmE;AAC/D,aAAO,KAAK,UAAL,CAAgB,aAAhB,CAAP;AACH;;AACD,WAAO,aAAP;AACH;;AAEO,EAAA,UAAU,CAAC,KAAD,EAAc;AAC5B,UAAM;AAAE,MAAA;AAAF,QAAY,KAAK,gBAAvB;AACA,WAAO,GAAG,KAAK,GAAG,KAAK,GAAG,KAAK,EAA/B;AACH;;AAxDsB;;AAA3B,OAAA,CAAA,cAAA,GAAA,cAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FieldFormatter = void 0;\nconst lodash_isboolean_1 = __importDefault(require(\"lodash.isboolean\"));\nconst lodash_isnil_1 = __importDefault(require(\"lodash.isnil\"));\nconst lodash_escaperegexp_1 = __importDefault(require(\"lodash.escaperegexp\"));\nclass FieldFormatter {\n    constructor(formatterOptions) {\n        this._headers = null;\n        this.formatterOptions = formatterOptions;\n        if (formatterOptions.headers !== null) {\n            this.headers = formatterOptions.headers;\n        }\n        this.REPLACE_REGEXP = new RegExp(formatterOptions.quote, 'g');\n        const escapePattern = `[${formatterOptions.delimiter}${lodash_escaperegexp_1.default(formatterOptions.rowDelimiter)}|\\r|\\n]`;\n        this.ESCAPE_REGEXP = new RegExp(escapePattern);\n    }\n    set headers(headers) {\n        this._headers = headers;\n    }\n    shouldQuote(fieldIndex, isHeader) {\n        const quoteConfig = isHeader ? this.formatterOptions.quoteHeaders : this.formatterOptions.quoteColumns;\n        if (lodash_isboolean_1.default(quoteConfig)) {\n            return quoteConfig;\n        }\n        if (Array.isArray(quoteConfig)) {\n            return quoteConfig[fieldIndex];\n        }\n        if (this._headers !== null) {\n            return quoteConfig[this._headers[fieldIndex]];\n        }\n        return false;\n    }\n    format(field, fieldIndex, isHeader) {\n        const preparedField = `${lodash_isnil_1.default(field) ? '' : field}`.replace(/\\0/g, '');\n        const { formatterOptions } = this;\n        if (formatterOptions.quote !== '') {\n            const shouldEscape = preparedField.indexOf(formatterOptions.quote) !== -1;\n            if (shouldEscape) {\n                return this.quoteField(preparedField.replace(this.REPLACE_REGEXP, formatterOptions.escapedQuote));\n            }\n        }\n        const hasEscapeCharacters = preparedField.search(this.ESCAPE_REGEXP) !== -1;\n        if (hasEscapeCharacters || this.shouldQuote(fieldIndex, isHeader)) {\n            return this.quoteField(preparedField);\n        }\n        return preparedField;\n    }\n    quoteField(field) {\n        const { quote } = this.formatterOptions;\n        return `${quote}${field}${quote}`;\n    }\n}\nexports.FieldFormatter = FieldFormatter;\n//# sourceMappingURL=FieldFormatter.js.map"]},"metadata":{},"sourceType":"script"}