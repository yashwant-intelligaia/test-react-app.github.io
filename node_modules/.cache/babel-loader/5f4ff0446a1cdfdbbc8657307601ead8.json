{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/home/yashwant-intelligaia/Documents/Official/TestTasks/my-react-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nvar events = require('events');\n\nvar JSZip = require('jszip');\n\nvar StreamBuf = require('./stream-buf');\n\nvar _require = require('./browser-buffer-encode'),\n    stringToBuffer = _require.stringToBuffer; // =============================================================================\n// The ZipWriter class\n// Packs streamed data into an output zip stream\n\n\nvar ZipWriter = /*#__PURE__*/function (_events$EventEmitter) {\n  _inherits(ZipWriter, _events$EventEmitter);\n\n  var _super = _createSuper(ZipWriter);\n\n  function ZipWriter(options) {\n    var _this;\n\n    _classCallCheck(this, ZipWriter);\n\n    _this = _super.call(this);\n    _this.options = Object.assign({\n      type: 'nodebuffer',\n      compression: 'DEFLATE'\n    }, options);\n    _this.zip = new JSZip();\n    _this.stream = new StreamBuf();\n    return _this;\n  }\n\n  _createClass(ZipWriter, [{\n    key: \"append\",\n    value: function append(data, options) {\n      if (options.hasOwnProperty('base64') && options.base64) {\n        this.zip.file(options.name, data, {\n          base64: true\n        });\n      } else {\n        // https://www.npmjs.com/package/process\n        if (process.browser && typeof data === 'string') {\n          // use TextEncoder in browser\n          data = stringToBuffer(data);\n        }\n\n        this.zip.file(options.name, data);\n      }\n    }\n  }, {\n    key: \"finalize\",\n    value: function () {\n      var _finalize = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var content;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this.zip.generateAsync(this.options);\n\n              case 2:\n                content = _context.sent;\n                this.stream.end(content);\n                this.emit('finish');\n\n              case 5:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function finalize() {\n        return _finalize.apply(this, arguments);\n      }\n\n      return finalize;\n    }() // ==========================================================================\n    // Stream.Readable interface\n\n  }, {\n    key: \"read\",\n    value: function read(size) {\n      return this.stream.read(size);\n    }\n  }, {\n    key: \"setEncoding\",\n    value: function setEncoding(encoding) {\n      return this.stream.setEncoding(encoding);\n    }\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      return this.stream.pause();\n    }\n  }, {\n    key: \"resume\",\n    value: function resume() {\n      return this.stream.resume();\n    }\n  }, {\n    key: \"isPaused\",\n    value: function isPaused() {\n      return this.stream.isPaused();\n    }\n  }, {\n    key: \"pipe\",\n    value: function pipe(destination, options) {\n      return this.stream.pipe(destination, options);\n    }\n  }, {\n    key: \"unpipe\",\n    value: function unpipe(destination) {\n      return this.stream.unpipe(destination);\n    }\n  }, {\n    key: \"unshift\",\n    value: function unshift(chunk) {\n      return this.stream.unshift(chunk);\n    }\n  }, {\n    key: \"wrap\",\n    value: function wrap(stream) {\n      return this.stream.wrap(stream);\n    }\n  }]);\n\n  return ZipWriter;\n}(events.EventEmitter); // =============================================================================\n\n\nmodule.exports = {\n  ZipWriter: ZipWriter\n};","map":{"version":3,"sources":["../../../lib/utils/zip-stream.js"],"names":["events","require","JSZip","StreamBuf","stringToBuffer","ZipWriter","EventEmitter","type","compression","data","options","base64","process","content","size","encoding","destination","chunk","stream","module"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAMA,MAAM,GAAGC,OAAO,CAAtB,QAAsB,CAAtB;;AACA,IAAMC,KAAK,GAAGD,OAAO,CAArB,OAAqB,CAArB;;AAEA,IAAME,SAAS,GAAGF,OAAO,CAAzB,cAAyB,CAAzB;;eACyBA,OAAO,CAAA,yBAAA,C;IAAzBG,c,YAAAA,c,EAEP;AACA;AACA;;;IACMC,S;;;;;AACJ,WAAA,SAAA,CAAA,OAAA,EAAqB;AAAA,QAAA,KAAA;;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,SAAA,CAAA;;AACnB,IAAA,KAAA,GAAA,MAAA,CAAA,IAAA,CAAA,IAAA,CAAA;AACA,IAAA,KAAA,CAAA,OAAA,GAAe,MAAM,CAAN,MAAA,CACb;AACEE,MAAAA,IAAI,EADN,YAAA;AAEEC,MAAAA,WAAW,EAAE;AAFf,KADa,EAAf,OAAe,CAAf;AAQA,IAAA,KAAA,CAAA,GAAA,GAAW,IAAX,KAAW,EAAX;AACA,IAAA,KAAA,CAAA,MAAA,GAAc,IAAd,SAAc,EAAd;AAXmB,WAAA,KAAA;AAYpB;;;;2BAEMC,I,EAAMC,O,EAAS;AACpB,UAAIA,OAAO,CAAPA,cAAAA,CAAAA,QAAAA,KAAoCA,OAAO,CAA/C,MAAA,EAAwD;AACtD,aAAA,GAAA,CAAA,IAAA,CAAcA,OAAO,CAArB,IAAA,EAAA,IAAA,EAAkC;AAACC,UAAAA,MAAM,EAAE;AAAT,SAAlC;AADF,OAAA,MAEO;AACL;AACA,YAAIC,OAAO,CAAPA,OAAAA,IAAmB,OAAA,IAAA,KAAvB,QAAA,EAAiD;AAC/C;AACAH,UAAAA,IAAI,GAAGL,cAAc,CAArBK,IAAqB,CAArBA;AACD;;AACD,aAAA,GAAA,CAAA,IAAA,CAAcC,OAAO,CAArB,IAAA,EAAA,IAAA;AACD;AACF;;;;;;;;;;;uBAGuB,KAAA,GAAA,CAAA,aAAA,CAAuB,KAAvB,OAAA,C;;;AAAhBG,gBAAAA,O,gBAAAA;AACN,qBAAA,MAAA,CAAA,GAAA,CAAA,OAAA;AACA,qBAAA,IAAA,CAAA,QAAA;;;;;;;;;;;;;;;QAGF;AACA;;;;yBACKC,I,EAAM;AACT,aAAO,KAAA,MAAA,CAAA,IAAA,CAAP,IAAO,CAAP;AACD;;;gCAEWC,Q,EAAU;AACpB,aAAO,KAAA,MAAA,CAAA,WAAA,CAAP,QAAO,CAAP;AACD;;;4BAEO;AACN,aAAO,KAAA,MAAA,CAAP,KAAO,EAAP;AACD;;;6BAEQ;AACP,aAAO,KAAA,MAAA,CAAP,MAAO,EAAP;AACD;;;+BAEU;AACT,aAAO,KAAA,MAAA,CAAP,QAAO,EAAP;AACD;;;yBAEIC,W,EAAaN,O,EAAS;AACzB,aAAO,KAAA,MAAA,CAAA,IAAA,CAAA,WAAA,EAAP,OAAO,CAAP;AACD;;;2BAEMM,W,EAAa;AAClB,aAAO,KAAA,MAAA,CAAA,MAAA,CAAP,WAAO,CAAP;AACD;;;4BAEOC,K,EAAO;AACb,aAAO,KAAA,MAAA,CAAA,OAAA,CAAP,KAAO,CAAP;AACD;;;yBAEIC,M,EAAQ;AACX,aAAO,KAAA,MAAA,CAAA,IAAA,CAAP,MAAO,CAAP;AACD;;;;EAtEqBlB,MAAM,CAACM,Y,GAyE/B;;;AAEAa,MAAM,CAANA,OAAAA,GAAiB;AACfd,EAAAA,SAAS,EAATA;AADe,CAAjBc","sourcesContent":["const events = require('events');\r\nconst JSZip = require('jszip');\r\n\r\nconst StreamBuf = require('./stream-buf');\r\nconst {stringToBuffer} = require('./browser-buffer-encode');\r\n\r\n// =============================================================================\r\n// The ZipWriter class\r\n// Packs streamed data into an output zip stream\r\nclass ZipWriter extends events.EventEmitter {\r\n  constructor(options) {\r\n    super();\r\n    this.options = Object.assign(\r\n      {\r\n        type: 'nodebuffer',\r\n        compression: 'DEFLATE',\r\n      },\r\n      options\r\n    );\r\n\r\n    this.zip = new JSZip();\r\n    this.stream = new StreamBuf();\r\n  }\r\n\r\n  append(data, options) {\r\n    if (options.hasOwnProperty('base64') && options.base64) {\r\n      this.zip.file(options.name, data, {base64: true});\r\n    } else {\r\n      // https://www.npmjs.com/package/process\r\n      if (process.browser && typeof data === 'string') {\r\n        // use TextEncoder in browser\r\n        data = stringToBuffer(data);\r\n      }\r\n      this.zip.file(options.name, data);\r\n    }\r\n  }\r\n\r\n  async finalize() {\r\n    const content = await this.zip.generateAsync(this.options);\r\n    this.stream.end(content);\r\n    this.emit('finish');\r\n  }\r\n\r\n  // ==========================================================================\r\n  // Stream.Readable interface\r\n  read(size) {\r\n    return this.stream.read(size);\r\n  }\r\n\r\n  setEncoding(encoding) {\r\n    return this.stream.setEncoding(encoding);\r\n  }\r\n\r\n  pause() {\r\n    return this.stream.pause();\r\n  }\r\n\r\n  resume() {\r\n    return this.stream.resume();\r\n  }\r\n\r\n  isPaused() {\r\n    return this.stream.isPaused();\r\n  }\r\n\r\n  pipe(destination, options) {\r\n    return this.stream.pipe(destination, options);\r\n  }\r\n\r\n  unpipe(destination) {\r\n    return this.stream.unpipe(destination);\r\n  }\r\n\r\n  unshift(chunk) {\r\n    return this.stream.unshift(chunk);\r\n  }\r\n\r\n  wrap(stream) {\r\n    return this.stream.wrap(stream);\r\n  }\r\n}\r\n\r\n// =============================================================================\r\n\r\nmodule.exports = {\r\n  ZipWriter,\r\n};\r\n"]},"metadata":{},"sourceType":"script"}