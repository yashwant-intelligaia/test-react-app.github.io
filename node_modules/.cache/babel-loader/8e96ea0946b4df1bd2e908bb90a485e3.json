{"ast":null,"code":"\"use strict\";\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nvar BaseXform = require('../base-xform');\n\nvar colCache = require('../../../utils/col-cache');\n\nvar DefinedNamesXform = /*#__PURE__*/function (_BaseXform) {\n  _inherits(DefinedNamesXform, _BaseXform);\n\n  var _super = _createSuper(DefinedNamesXform);\n\n  function DefinedNamesXform() {\n    _classCallCheck(this, DefinedNamesXform);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(DefinedNamesXform, [{\n    key: \"render\",\n    value: function render(xmlStream, model) {\n      // <definedNames>\n      //   <definedName name=\"name\">name.ranges.join(',')</definedName>\n      //   <definedName name=\"_xlnm.Print_Area\" localSheetId=\"0\">name.ranges.join(',')</definedName>\n      // </definedNames>\n      xmlStream.openNode('definedName', {\n        name: model.name,\n        localSheetId: model.localSheetId\n      });\n      xmlStream.writeText(model.ranges.join(','));\n      xmlStream.closeNode();\n    }\n  }, {\n    key: \"parseOpen\",\n    value: function parseOpen(node) {\n      switch (node.name) {\n        case 'definedName':\n          this._parsedName = node.attributes.name;\n          this._parsedLocalSheetId = node.attributes.localSheetId;\n          this._parsedText = [];\n          return true;\n\n        default:\n          return false;\n      }\n    }\n  }, {\n    key: \"parseText\",\n    value: function parseText(text) {\n      this._parsedText.push(text);\n    }\n  }, {\n    key: \"parseClose\",\n    value: function parseClose() {\n      this.model = {\n        name: this._parsedName,\n        ranges: extractRanges(this._parsedText.join(''))\n      };\n\n      if (this._parsedLocalSheetId !== undefined) {\n        this.model.localSheetId = parseInt(this._parsedLocalSheetId, 10);\n      }\n\n      return false;\n    }\n  }]);\n\n  return DefinedNamesXform;\n}(BaseXform);\n\nfunction isValidRange(range) {\n  try {\n    colCache.decodeEx(range);\n    return true;\n  } catch (err) {\n    return false;\n  }\n}\n\nfunction extractRanges(parsedText) {\n  var ranges = [];\n  var quotesOpened = false;\n  var last = '';\n  parsedText.split(',').forEach(function (item) {\n    if (!item) {\n      return;\n    }\n\n    var quotes = (item.match(/'/g) || []).length;\n\n    if (!quotes) {\n      if (quotesOpened) {\n        last += \"\".concat(item, \",\");\n      } else if (isValidRange(item)) {\n        ranges.push(item);\n      }\n\n      return;\n    }\n\n    var quotesEven = quotes % 2 === 0;\n\n    if (!quotesOpened && quotesEven && isValidRange(item)) {\n      ranges.push(item);\n    } else if (quotesOpened && !quotesEven) {\n      quotesOpened = false;\n\n      if (isValidRange(last + item)) {\n        ranges.push(last + item);\n      }\n\n      last = '';\n    } else {\n      quotesOpened = true;\n      last += \"\".concat(item, \",\");\n    }\n  });\n  return ranges;\n}\n\nmodule.exports = DefinedNamesXform;","map":{"version":3,"sources":["../../../../../lib/xlsx/xform/book/defined-name-xform.js"],"names":["BaseXform","require","colCache","DefinedNamesXform","xmlStream","model","name","localSheetId","node","text","ranges","extractRanges","parseInt","quotesOpened","last","parsedText","quotes","item","isValidRange","quotesEven","module"],"mappings":"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","sourcesContent":["const BaseXform = require('../base-xform');\r\nconst colCache = require('../../../utils/col-cache');\r\n\r\nclass DefinedNamesXform extends BaseXform {\r\n  render(xmlStream, model) {\r\n    // <definedNames>\r\n    //   <definedName name=\"name\">name.ranges.join(',')</definedName>\r\n    //   <definedName name=\"_xlnm.Print_Area\" localSheetId=\"0\">name.ranges.join(',')</definedName>\r\n    // </definedNames>\r\n    xmlStream.openNode('definedName', {\r\n      name: model.name,\r\n      localSheetId: model.localSheetId,\r\n    });\r\n    xmlStream.writeText(model.ranges.join(','));\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  parseOpen(node) {\r\n    switch (node.name) {\r\n      case 'definedName':\r\n        this._parsedName = node.attributes.name;\r\n        this._parsedLocalSheetId = node.attributes.localSheetId;\r\n        this._parsedText = [];\r\n        return true;\r\n      default:\r\n        return false;\r\n    }\r\n  }\r\n\r\n  parseText(text) {\r\n    this._parsedText.push(text);\r\n  }\r\n\r\n  parseClose() {\r\n    this.model = {\r\n      name: this._parsedName,\r\n      ranges: extractRanges(this._parsedText.join('')),\r\n    };\r\n    if (this._parsedLocalSheetId !== undefined) {\r\n      this.model.localSheetId = parseInt(this._parsedLocalSheetId, 10);\r\n    }\r\n    return false;\r\n  }\r\n}\r\n\r\nfunction isValidRange(range) {\r\n  try {\r\n    colCache.decodeEx(range);\r\n    return true;\r\n  } catch (err) {\r\n    return false;\r\n  }\r\n}\r\n\r\nfunction extractRanges(parsedText) {\r\n  const ranges = [];\r\n  let quotesOpened = false;\r\n  let last = '';\r\n  parsedText.split(',').forEach(item => {\r\n    if (!item) {\r\n      return;\r\n    }\r\n    const quotes = (item.match(/'/g) || []).length;\r\n\r\n    if (!quotes) {\r\n      if (quotesOpened) {\r\n        last += `${item},`;\r\n      } else if (isValidRange(item)) {\r\n        ranges.push(item);\r\n      }\r\n      return;\r\n    }\r\n    const quotesEven = quotes % 2 === 0;\r\n\r\n    if (!quotesOpened && quotesEven && isValidRange(item)) {\r\n      ranges.push(item);\r\n    } else if (quotesOpened && !quotesEven) {\r\n      quotesOpened = false;\r\n      if (isValidRange(last + item)) {\r\n        ranges.push(last + item);\r\n      }\r\n      last = '';\r\n    } else {\r\n      quotesOpened = true;\r\n      last += `${item},`;\r\n    }\r\n  });\r\n  return ranges;\r\n}\r\n\r\nmodule.exports = DefinedNamesXform;\r\n"]},"metadata":{},"sourceType":"script"}