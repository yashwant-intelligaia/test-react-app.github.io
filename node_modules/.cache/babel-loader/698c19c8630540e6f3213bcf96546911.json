{"ast":null,"code":"\"use strict\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nvar _ = require('../utils/under-dash');\n\nvar colCache = require('../utils/col-cache');\n\nvar Range = require('./range');\n\nvar Row = require('./row');\n\nvar Column = require('./column');\n\nvar Enums = require('./enums');\n\nvar Image = require('./image');\n\nvar Table = require('./table');\n\nvar DataValidations = require('./data-validations');\n\nvar Encryptor = require('../utils/encryptor'); // Worksheet requirements\n//  Operate as sheet inside workbook or standalone\n//  Load and Save from file and stream\n//  Access/Add/Delete individual cells\n//  Manage column widths and row heights\n\n\nvar Worksheet = /*#__PURE__*/function () {\n  function Worksheet(options) {\n    _classCallCheck(this, Worksheet);\n\n    options = options || {}; // in a workbook, each sheet will have a number\n\n    this.id = options.id;\n    this.orderNo = options.orderNo; // and a name\n\n    this.name = options.name || \"Sheet\".concat(this.id); // add a state\n\n    this.state = options.state || 'visible'; // rows allows access organised by row. Sparse array of arrays indexed by row-1, col\n    // Note: _rows is zero based. Must subtract 1 to go from cell.row to index\n\n    this._rows = []; // column definitions\n\n    this._columns = null; // column keys (addRow convenience): key ==> this._collumns index\n\n    this._keys = {}; // keep record of all merges\n\n    this._merges = {}; // record of all row and column pageBreaks\n\n    this.rowBreaks = [];\n    this._workbook = options.workbook; // for tabColor, default row height, outline levels, etc\n\n    this.properties = Object.assign({}, {\n      defaultRowHeight: 15,\n      dyDescent: 55,\n      outlineLevelCol: 0,\n      outlineLevelRow: 0\n    }, options.properties); // for all things printing\n\n    this.pageSetup = Object.assign({}, {\n      margins: {\n        left: 0.7,\n        right: 0.7,\n        top: 0.75,\n        bottom: 0.75,\n        header: 0.3,\n        footer: 0.3\n      },\n      orientation: 'portrait',\n      horizontalDpi: 4294967295,\n      verticalDpi: 4294967295,\n      fitToPage: !!(options.pageSetup && (options.pageSetup.fitToWidth || options.pageSetup.fitToHeight) && !options.pageSetup.scale),\n      pageOrder: 'downThenOver',\n      blackAndWhite: false,\n      draft: false,\n      cellComments: 'None',\n      errors: 'displayed',\n      scale: 100,\n      fitToWidth: 1,\n      fitToHeight: 1,\n      paperSize: undefined,\n      showRowColHeaders: false,\n      showGridLines: false,\n      firstPageNumber: undefined,\n      horizontalCentered: false,\n      verticalCentered: false,\n      rowBreaks: null,\n      colBreaks: null\n    }, options.pageSetup);\n    this.headerFooter = Object.assign({}, {\n      differentFirst: false,\n      differentOddEven: false,\n      oddHeader: null,\n      oddFooter: null,\n      evenHeader: null,\n      evenFooter: null,\n      firstHeader: null,\n      firstFooter: null\n    }, options.headerFooter);\n    this.dataValidations = new DataValidations(); // for freezepanes, split, zoom, gridlines, etc\n\n    this.views = options.views || [];\n    this.autoFilter = options.autoFilter || null; // for images, etc\n\n    this._media = []; // worksheet protection\n\n    this.sheetProtection = null; // for tables\n\n    this.tables = {};\n    this.conditionalFormattings = [];\n  }\n\n  _createClass(Worksheet, [{\n    key: \"destroy\",\n    // when you're done with this worksheet, call this to remove from workbook\n    value: function destroy() {\n      this._workbook.removeWorksheetEx(this);\n    } // Get the bounding range of the cells in this worksheet\n\n  }, {\n    key: \"getColumnKey\",\n    value: function getColumnKey(key) {\n      return this._keys[key];\n    }\n  }, {\n    key: \"setColumnKey\",\n    value: function setColumnKey(key, value) {\n      this._keys[key] = value;\n    }\n  }, {\n    key: \"deleteColumnKey\",\n    value: function deleteColumnKey(key) {\n      delete this._keys[key];\n    }\n  }, {\n    key: \"eachColumnKey\",\n    value: function eachColumnKey(f) {\n      _.each(this._keys, f);\n    } // get a single column by col number. If it doesn't exist, create it and any gaps before it\n\n  }, {\n    key: \"getColumn\",\n    value: function getColumn(c) {\n      if (typeof c === 'string') {\n        // if it matches a key'd column, return that\n        var col = this._keys[c];\n        if (col) return col; // otherwise, assume letter\n\n        c = colCache.l2n(c);\n      }\n\n      if (!this._columns) {\n        this._columns = [];\n      }\n\n      if (c > this._columns.length) {\n        var n = this._columns.length + 1;\n\n        while (n <= c) {\n          this._columns.push(new Column(this, n++));\n        }\n      }\n\n      return this._columns[c - 1];\n    }\n  }, {\n    key: \"spliceColumns\",\n    value: function spliceColumns(start, count) {\n      var _this = this;\n\n      var rows = this._rows;\n      var nRows = rows.length;\n\n      for (var _len = arguments.length, inserts = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n        inserts[_key - 2] = arguments[_key];\n      }\n\n      if (inserts.length > 0) {\n        var _loop = function _loop(i) {\n          var rowArguments = [start, count]; // eslint-disable-next-line no-loop-func\n\n          inserts.forEach(function (insert) {\n            rowArguments.push(insert[i] || null);\n          });\n\n          var row = _this.getRow(i + 1); // eslint-disable-next-line prefer-spread\n\n\n          row.splice.apply(row, rowArguments);\n        }; // must iterate over all rows whether they exist yet or not\n\n\n        for (var i = 0; i < nRows; i++) {\n          _loop(i);\n        }\n      } else {\n        // nothing to insert, so just splice all rows\n        this._rows.forEach(function (r) {\n          if (r) {\n            r.splice(start, count);\n          }\n        });\n      } // splice column definitions\n\n\n      var nExpand = inserts.length - count;\n      var nKeep = start + count;\n      var nEnd = this._columns.length;\n\n      if (nExpand < 0) {\n        for (var _i = start + inserts.length; _i <= nEnd; _i++) {\n          this.getColumn(_i).defn = this.getColumn(_i - nExpand).defn;\n        }\n      } else if (nExpand > 0) {\n        for (var _i2 = nEnd; _i2 >= nKeep; _i2--) {\n          this.getColumn(_i2 + nExpand).defn = this.getColumn(_i2).defn;\n        }\n      }\n\n      for (var _i3 = start; _i3 < start + inserts.length; _i3++) {\n        this.getColumn(_i3).defn = null;\n      } // account for defined names\n\n\n      this.workbook.definedNames.spliceColumns(this.name, start, count, inserts.length);\n    }\n  }, {\n    key: \"_commitRow\",\n    // =========================================================================\n    // Rows\n    value: function _commitRow() {// nop - allows streaming reader to fill a document\n    }\n  }, {\n    key: \"findRow\",\n    // find a row (if exists) by row number\n    value: function findRow(r) {\n      return this._rows[r - 1];\n    } // find multiple rows (if exists) by row number\n\n  }, {\n    key: \"findRows\",\n    value: function findRows(start, length) {\n      return this._rows.slice(start - 1, start - 1 + length);\n    }\n  }, {\n    key: \"getRow\",\n    // get a row by row number.\n    value: function getRow(r) {\n      var row = this._rows[r - 1];\n\n      if (!row) {\n        row = this._rows[r - 1] = new Row(this, r);\n      }\n\n      return row;\n    } // get multiple rows by row number.\n\n  }, {\n    key: \"getRows\",\n    value: function getRows(start, length) {\n      if (length < 1) return undefined;\n      var rows = [];\n\n      for (var i = start; i < start + length; i++) {\n        rows.push(this.getRow(i));\n      }\n\n      return rows;\n    }\n  }, {\n    key: \"addRow\",\n    value: function addRow(value) {\n      var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'n';\n      var rowNo = this._nextRow;\n      var row = this.getRow(rowNo);\n      row.values = value;\n\n      this._setStyleOption(rowNo, style[0] === 'i' ? style : 'n');\n\n      return row;\n    }\n  }, {\n    key: \"addRows\",\n    value: function addRows(value) {\n      var _this2 = this;\n\n      var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'n';\n      var rows = [];\n      value.forEach(function (row) {\n        rows.push(_this2.addRow(row, style));\n      });\n      return rows;\n    }\n  }, {\n    key: \"insertRow\",\n    value: function insertRow(pos, value) {\n      var style = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'n';\n      this.spliceRows(pos, 0, value);\n\n      this._setStyleOption(pos, style);\n\n      return this.getRow(pos);\n    }\n  }, {\n    key: \"insertRows\",\n    value: function insertRows(pos, values) {\n      var style = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'n';\n      this.spliceRows.apply(this, [pos, 0].concat(_toConsumableArray(values)));\n\n      if (style !== 'n') {\n        // copy over the styles\n        for (var i = 0; i < values.length; i++) {\n          if (style[0] === 'o' && this.findRow(values.length + pos + i) !== undefined) {\n            this._copyStyle(values.length + pos + i, pos + i, style[1] === '+');\n          } else if (style[0] === 'i' && this.findRow(pos - 1) !== undefined) {\n            this._copyStyle(pos - 1, pos + i, style[1] === '+');\n          }\n        }\n      }\n\n      return this.getRows(pos, values.length);\n    } // set row at position to same style as of either pervious row (option 'i') or next row (option 'o')\n\n  }, {\n    key: \"_setStyleOption\",\n    value: function _setStyleOption(pos) {\n      var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'n';\n\n      if (style[0] === 'o' && this.findRow(pos + 1) !== undefined) {\n        this._copyStyle(pos + 1, pos, style[1] === '+');\n      } else if (style[0] === 'i' && this.findRow(pos - 1) !== undefined) {\n        this._copyStyle(pos - 1, pos, style[1] === '+');\n      }\n    }\n  }, {\n    key: \"_copyStyle\",\n    value: function _copyStyle(src, dest) {\n      var styleEmpty = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var rSrc = this.getRow(src);\n      var rDst = this.getRow(dest);\n      rDst.style = Object.freeze(_objectSpread({}, rSrc.style)); // eslint-disable-next-line no-loop-func\n\n      rSrc.eachCell({\n        includeEmpty: styleEmpty\n      }, function (cell, colNumber) {\n        rDst.getCell(colNumber).style = Object.freeze(_objectSpread({}, cell.style));\n      });\n      rDst.height = rSrc.height;\n    }\n  }, {\n    key: \"duplicateRow\",\n    value: function duplicateRow(rowNum, count) {\n      var _this3 = this;\n\n      var insert = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false; // create count duplicates of rowNum\n      // either inserting new or overwriting existing rows\n\n      var rSrc = this._rows[rowNum - 1];\n      var inserts = new Array(count).fill(rSrc.values);\n      this.spliceRows.apply(this, [rowNum + 1, insert ? 0 : count].concat(_toConsumableArray(inserts))); // now copy styles...\n\n      var _loop2 = function _loop2(i) {\n        var rDst = _this3._rows[rowNum + i];\n        rDst.style = rSrc.style;\n        rDst.height = rSrc.height; // eslint-disable-next-line no-loop-func\n\n        rSrc.eachCell({\n          includeEmpty: true\n        }, function (cell, colNumber) {\n          rDst.getCell(colNumber).style = cell.style;\n        });\n      };\n\n      for (var i = 0; i < count; i++) {\n        _loop2(i);\n      }\n    }\n  }, {\n    key: \"spliceRows\",\n    value: function spliceRows(start, count) {\n      var _this4 = this; // same problem as row.splice, except worse.\n\n\n      var nKeep = start + count;\n\n      for (var _len2 = arguments.length, inserts = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n        inserts[_key2 - 2] = arguments[_key2];\n      }\n\n      var nInserts = inserts.length;\n      var nExpand = nInserts - count;\n      var nEnd = this._rows.length;\n      var i;\n      var rSrc;\n\n      if (nExpand < 0) {\n        // remove rows\n        for (i = nKeep; i <= nEnd; i++) {\n          rSrc = this._rows[i - 1];\n\n          if (rSrc) {\n            (function () {\n              var rDst = _this4.getRow(i + nExpand);\n\n              rDst.values = rSrc.values;\n              rDst.style = rSrc.style;\n              rDst.height = rSrc.height; // eslint-disable-next-line no-loop-func\n\n              rSrc.eachCell({\n                includeEmpty: true\n              }, function (cell, colNumber) {\n                rDst.getCell(colNumber).style = cell.style;\n              });\n              _this4._rows[i - 1] = undefined;\n            })();\n          } else {\n            this._rows[i + nExpand - 1] = undefined;\n          }\n        }\n      } else if (nExpand > 0) {\n        // insert new cells\n        for (i = nEnd; i >= nKeep; i--) {\n          rSrc = this._rows[i - 1];\n\n          if (rSrc) {\n            (function () {\n              var rDst = _this4.getRow(i + nExpand);\n\n              rDst.values = rSrc.values;\n              rDst.style = rSrc.style;\n              rDst.height = rSrc.height; // eslint-disable-next-line no-loop-func\n\n              rSrc.eachCell({\n                includeEmpty: true\n              }, function (cell, colNumber) {\n                rDst.getCell(colNumber).style = cell.style; // remerge cells accounting for insert offset\n\n                if (cell._value.constructor.name === 'MergeValue') {\n                  var cellToBeMerged = _this4.getRow(cell._row._number + nInserts).getCell(colNumber);\n\n                  var prevMaster = cell._value._master;\n\n                  var newMaster = _this4.getRow(prevMaster._row._number + nInserts).getCell(prevMaster._column._number);\n\n                  cellToBeMerged.merge(newMaster);\n                }\n              });\n            })();\n          } else {\n            this._rows[i + nExpand - 1] = undefined;\n          }\n        }\n      } // now copy over the new values\n\n\n      for (i = 0; i < nInserts; i++) {\n        var rDst = this.getRow(start + i);\n        rDst.style = {};\n        rDst.values = inserts[i];\n      } // account for defined names\n\n\n      this.workbook.definedNames.spliceRows(this.name, start, count, nInserts);\n    } // iterate over every row in the worksheet, including maybe empty rows\n\n  }, {\n    key: \"eachRow\",\n    value: function eachRow(options, iteratee) {\n      if (!iteratee) {\n        iteratee = options;\n        options = undefined;\n      }\n\n      if (options && options.includeEmpty) {\n        var n = this._rows.length;\n\n        for (var i = 1; i <= n; i++) {\n          iteratee(this.getRow(i), i);\n        }\n      } else {\n        this._rows.forEach(function (row) {\n          if (row && row.hasValues) {\n            iteratee(row, row.number);\n          }\n        });\n      }\n    } // return all rows as sparse array\n\n  }, {\n    key: \"getSheetValues\",\n    value: function getSheetValues() {\n      var rows = [];\n\n      this._rows.forEach(function (row) {\n        if (row) {\n          rows[row.number] = row.values;\n        }\n      });\n\n      return rows;\n    } // =========================================================================\n    // Cells\n    // returns the cell at [r,c] or address given by r. If not found, return undefined\n\n  }, {\n    key: \"findCell\",\n    value: function findCell(r, c) {\n      var address = colCache.getAddress(r, c);\n      var row = this._rows[address.row - 1];\n      return row ? row.findCell(address.col) : undefined;\n    } // return the cell at [r,c] or address given by r. If not found, create a new one.\n\n  }, {\n    key: \"getCell\",\n    value: function getCell(r, c) {\n      var address = colCache.getAddress(r, c);\n      var row = this.getRow(address.row);\n      return row.getCellEx(address);\n    } // =========================================================================\n    // Merge\n    // convert the range defined by ['tl:br'], [tl,br] or [t,l,b,r] into a single 'merged' cell\n\n  }, {\n    key: \"mergeCells\",\n    value: function mergeCells() {\n      for (var _len3 = arguments.length, cells = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        cells[_key3] = arguments[_key3];\n      }\n\n      var dimensions = new Range(cells);\n\n      this._mergeCellsInternal(dimensions);\n    }\n  }, {\n    key: \"mergeCellsWithoutStyle\",\n    value: function mergeCellsWithoutStyle() {\n      for (var _len4 = arguments.length, cells = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        cells[_key4] = arguments[_key4];\n      }\n\n      var dimensions = new Range(cells);\n\n      this._mergeCellsInternal(dimensions, true);\n    }\n  }, {\n    key: \"_mergeCellsInternal\",\n    value: function _mergeCellsInternal(dimensions, ignoreStyle) {\n      // check cells aren't already merged\n      _.each(this._merges, function (merge) {\n        if (merge.intersects(dimensions)) {\n          throw new Error('Cannot merge already merged cells');\n        }\n      }); // apply merge\n\n\n      var master = this.getCell(dimensions.top, dimensions.left);\n\n      for (var i = dimensions.top; i <= dimensions.bottom; i++) {\n        for (var j = dimensions.left; j <= dimensions.right; j++) {\n          // merge all but the master cell\n          if (i > dimensions.top || j > dimensions.left) {\n            this.getCell(i, j).merge(master, ignoreStyle);\n          }\n        }\n      } // index merge\n\n\n      this._merges[master.address] = dimensions;\n    }\n  }, {\n    key: \"_unMergeMaster\",\n    value: function _unMergeMaster(master) {\n      // master is always top left of a rectangle\n      var merge = this._merges[master.address];\n\n      if (merge) {\n        for (var i = merge.top; i <= merge.bottom; i++) {\n          for (var j = merge.left; j <= merge.right; j++) {\n            this.getCell(i, j).unmerge();\n          }\n        }\n\n        delete this._merges[master.address];\n      }\n    }\n  }, {\n    key: \"unMergeCells\",\n    // scan the range defined by ['tl:br'], [tl,br] or [t,l,b,r] and if any cell is part of a merge,\n    // un-merge the group. Note this function can affect multiple merges and merge-blocks are\n    // atomic - either they're all merged or all un-merged.\n    value: function unMergeCells() {\n      for (var _len5 = arguments.length, cells = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        cells[_key5] = arguments[_key5];\n      }\n\n      var dimensions = new Range(cells); // find any cells in that range and unmerge them\n\n      for (var i = dimensions.top; i <= dimensions.bottom; i++) {\n        for (var j = dimensions.left; j <= dimensions.right; j++) {\n          var cell = this.findCell(i, j);\n\n          if (cell) {\n            if (cell.type === Enums.ValueType.Merge) {\n              // this cell merges to another master\n              this._unMergeMaster(cell.master);\n            } else if (this._merges[cell.address]) {\n              // this cell is a master\n              this._unMergeMaster(cell);\n            }\n          }\n        }\n      }\n    } // ===========================================================================\n    // Shared/Array Formula\n\n  }, {\n    key: \"fillFormula\",\n    value: function fillFormula(range, formula, results) {\n      var shareType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'shared'; // Define formula for top-left cell and share to rest\n\n      var decoded = colCache.decode(range);\n      var top = decoded.top,\n          left = decoded.left,\n          bottom = decoded.bottom,\n          right = decoded.right;\n      var width = right - left + 1;\n      var masterAddress = colCache.encodeAddress(top, left);\n      var isShared = shareType === 'shared'; // work out result accessor\n\n      var getResult;\n\n      if (typeof results === 'function') {\n        getResult = results;\n      } else if (Array.isArray(results)) {\n        if (Array.isArray(results[0])) {\n          getResult = function getResult(row, col) {\n            return results[row - top][col - left];\n          };\n        } else {\n          // eslint-disable-next-line no-mixed-operators\n          getResult = function getResult(row, col) {\n            return results[(row - top) * width + (col - left)];\n          };\n        }\n      } else {\n        getResult = function getResult() {\n          return undefined;\n        };\n      }\n\n      var first = true;\n\n      for (var r = top; r <= bottom; r++) {\n        for (var c = left; c <= right; c++) {\n          if (first) {\n            this.getCell(r, c).value = {\n              shareType: shareType,\n              formula: formula,\n              ref: range,\n              result: getResult(r, c)\n            };\n            first = false;\n          } else {\n            this.getCell(r, c).value = isShared ? {\n              sharedFormula: masterAddress,\n              result: getResult(r, c)\n            } : getResult(r, c);\n          }\n        }\n      }\n    } // =========================================================================\n    // Images\n\n  }, {\n    key: \"addImage\",\n    value: function addImage(imageId, range) {\n      var model = {\n        type: 'image',\n        imageId: imageId,\n        range: range\n      };\n\n      this._media.push(new Image(this, model));\n    }\n  }, {\n    key: \"getImages\",\n    value: function getImages() {\n      return this._media.filter(function (m) {\n        return m.type === 'image';\n      });\n    }\n  }, {\n    key: \"addBackgroundImage\",\n    value: function addBackgroundImage(imageId) {\n      var model = {\n        type: 'background',\n        imageId: imageId\n      };\n\n      this._media.push(new Image(this, model));\n    }\n  }, {\n    key: \"getBackgroundImageId\",\n    value: function getBackgroundImageId() {\n      var image = this._media.find(function (m) {\n        return m.type === 'background';\n      });\n\n      return image && image.imageId;\n    } // =========================================================================\n    // Worksheet Protection\n\n  }, {\n    key: \"protect\",\n    value: function protect(password, options) {\n      var _this5 = this; // TODO: make this function truly async\n      // perhaps marshal to worker thread or something\n\n\n      return new Promise(function (resolve) {\n        _this5.sheetProtection = {\n          sheet: true\n        };\n\n        if (options && 'spinCount' in options) {\n          // force spinCount to be integer >= 0\n          options.spinCount = Number.isFinite(options.spinCount) ? Math.round(Math.max(0, options.spinCount)) : 100000;\n        }\n\n        if (password) {\n          _this5.sheetProtection.algorithmName = 'SHA-512';\n          _this5.sheetProtection.saltValue = Encryptor.randomBytes(16).toString('base64');\n          _this5.sheetProtection.spinCount = options && 'spinCount' in options ? options.spinCount : 100000; // allow user specified spinCount\n\n          _this5.sheetProtection.hashValue = Encryptor.convertPasswordToHash(password, 'SHA512', _this5.sheetProtection.saltValue, _this5.sheetProtection.spinCount);\n        }\n\n        if (options) {\n          _this5.sheetProtection = Object.assign(_this5.sheetProtection, options);\n\n          if (!password && 'spinCount' in options) {\n            delete _this5.sheetProtection.spinCount;\n          }\n        }\n\n        resolve();\n      });\n    }\n  }, {\n    key: \"unprotect\",\n    value: function unprotect() {\n      this.sheetProtection = null;\n    } // =========================================================================\n    // Tables\n\n  }, {\n    key: \"addTable\",\n    value: function addTable(model) {\n      var table = new Table(this, model);\n      this.tables[model.name] = table;\n      return table;\n    }\n  }, {\n    key: \"getTable\",\n    value: function getTable(name) {\n      return this.tables[name];\n    }\n  }, {\n    key: \"removeTable\",\n    value: function removeTable(name) {\n      delete this.tables[name];\n    }\n  }, {\n    key: \"getTables\",\n    value: function getTables() {\n      return Object.values(this.tables);\n    } // ===========================================================================\n    // Conditional Formatting\n\n  }, {\n    key: \"addConditionalFormatting\",\n    value: function addConditionalFormatting(cf) {\n      this.conditionalFormattings.push(cf);\n    }\n  }, {\n    key: \"removeConditionalFormatting\",\n    value: function removeConditionalFormatting(filter) {\n      if (typeof filter === 'number') {\n        this.conditionalFormattings.splice(filter, 1);\n      } else if (filter instanceof Function) {\n        this.conditionalFormattings = this.conditionalFormattings.filter(filter);\n      } else {\n        this.conditionalFormattings = [];\n      }\n    } // ===========================================================================\n    // Deprecated\n\n  }, {\n    key: \"_parseRows\",\n    value: function _parseRows(model) {\n      var _this6 = this;\n\n      this._rows = [];\n      model.rows.forEach(function (rowModel) {\n        var row = new Row(_this6, rowModel.number);\n        _this6._rows[row.number - 1] = row;\n        row.model = rowModel;\n      });\n    }\n  }, {\n    key: \"_parseMergeCells\",\n    value: function _parseMergeCells(model) {\n      var _this7 = this;\n\n      _.each(model.mergeCells, function (merge) {\n        // Do not merge styles when importing an Excel file\n        // since each cell may have different styles intentionally.\n        _this7.mergeCellsWithoutStyle(merge);\n      });\n    }\n  }, {\n    key: \"workbook\",\n    get: function get() {\n      return this._workbook;\n    }\n  }, {\n    key: \"dimensions\",\n    get: function get() {\n      var dimensions = new Range();\n\n      this._rows.forEach(function (row) {\n        if (row) {\n          var rowDims = row.dimensions;\n\n          if (rowDims) {\n            dimensions.expand(row.number, rowDims.min, row.number, rowDims.max);\n          }\n        }\n      });\n\n      return dimensions;\n    } // =========================================================================\n    // Columns\n    // get the current columns array.\n\n  }, {\n    key: \"columns\",\n    get: function get() {\n      return this._columns;\n    } // set the columns from an array of column definitions.\n    // Note: any headers defined will overwrite existing values.\n    ,\n    set: function set(value) {\n      var _this8 = this; // calculate max header row count\n\n\n      this._headerRowCount = value.reduce(function (pv, cv) {\n        var headerCount = cv.header && 1 || cv.headers && cv.headers.length || 0;\n        return Math.max(pv, headerCount);\n      }, 0); // construct Column objects\n\n      var count = 1;\n      var columns = this._columns = [];\n      value.forEach(function (defn) {\n        var column = new Column(_this8, count++, false);\n        columns.push(column);\n        column.defn = defn;\n      });\n    }\n  }, {\n    key: \"lastColumn\",\n    get: function get() {\n      return this.getColumn(this.columnCount);\n    }\n  }, {\n    key: \"columnCount\",\n    get: function get() {\n      var maxCount = 0;\n      this.eachRow(function (row) {\n        maxCount = Math.max(maxCount, row.cellCount);\n      });\n      return maxCount;\n    }\n  }, {\n    key: \"actualColumnCount\",\n    get: function get() {\n      // performance nightmare - for each row, counts all the columns used\n      var counts = [];\n      var count = 0;\n      this.eachRow(function (row) {\n        row.eachCell(function (_ref) {\n          var col = _ref.col;\n\n          if (!counts[col]) {\n            counts[col] = true;\n            count++;\n          }\n        });\n      });\n      return count;\n    }\n  }, {\n    key: \"_lastRowNumber\",\n    get: function get() {\n      // need to cope with results of splice\n      var rows = this._rows;\n      var n = rows.length;\n\n      while (n > 0 && rows[n - 1] === undefined) {\n        n--;\n      }\n\n      return n;\n    }\n  }, {\n    key: \"_nextRow\",\n    get: function get() {\n      return this._lastRowNumber + 1;\n    }\n  }, {\n    key: \"lastRow\",\n    get: function get() {\n      if (this._rows.length) {\n        return this._rows[this._rows.length - 1];\n      }\n\n      return undefined;\n    }\n  }, {\n    key: \"rowCount\",\n    get: function get() {\n      return this._lastRowNumber;\n    }\n  }, {\n    key: \"actualRowCount\",\n    get: function get() {\n      // counts actual rows that have actual data\n      var count = 0;\n      this.eachRow(function () {\n        count++;\n      });\n      return count;\n    }\n  }, {\n    key: \"hasMerges\",\n    get: function get() {\n      // return true if this._merges has a merge object\n      return _.some(this._merges, Boolean);\n    }\n  }, {\n    key: \"tabColor\",\n    get: function get() {\n      // eslint-disable-next-line no-console\n      console.trace('worksheet.tabColor property is now deprecated. Please use worksheet.properties.tabColor');\n      return this.properties.tabColor;\n    },\n    set: function set(value) {\n      // eslint-disable-next-line no-console\n      console.trace('worksheet.tabColor property is now deprecated. Please use worksheet.properties.tabColor');\n      this.properties.tabColor = value;\n    } // ===========================================================================\n    // Model\n\n  }, {\n    key: \"model\",\n    get: function get() {\n      var model = {\n        id: this.id,\n        name: this.name,\n        dataValidations: this.dataValidations.model,\n        properties: this.properties,\n        state: this.state,\n        pageSetup: this.pageSetup,\n        headerFooter: this.headerFooter,\n        rowBreaks: this.rowBreaks,\n        views: this.views,\n        autoFilter: this.autoFilter,\n        media: this._media.map(function (medium) {\n          return medium.model;\n        }),\n        sheetProtection: this.sheetProtection,\n        tables: Object.values(this.tables).map(function (table) {\n          return table.model;\n        }),\n        conditionalFormattings: this.conditionalFormattings\n      }; // =================================================\n      // columns\n\n      model.cols = Column.toModel(this.columns); // ==========================================================\n      // Rows\n\n      var rows = model.rows = [];\n      var dimensions = model.dimensions = new Range();\n\n      this._rows.forEach(function (row) {\n        var rowModel = row && row.model;\n\n        if (rowModel) {\n          dimensions.expand(rowModel.number, rowModel.min, rowModel.number, rowModel.max);\n          rows.push(rowModel);\n        }\n      }); // ==========================================================\n      // Merges\n\n\n      model.merges = [];\n\n      _.each(this._merges, function (merge) {\n        model.merges.push(merge.range);\n      });\n\n      return model;\n    },\n    set: function set(value) {\n      var _this9 = this;\n\n      this.name = value.name;\n      this._columns = Column.fromModel(this, value.cols);\n\n      this._parseRows(value);\n\n      this._parseMergeCells(value);\n\n      this.dataValidations = new DataValidations(value.dataValidations);\n      this.properties = value.properties;\n      this.pageSetup = value.pageSetup;\n      this.headerFooter = value.headerFooter;\n      this.views = value.views;\n      this.autoFilter = value.autoFilter;\n      this._media = value.media.map(function (medium) {\n        return new Image(_this9, medium);\n      });\n      this.sheetProtection = value.sheetProtection;\n      this.tables = value.tables.reduce(function (tables, table) {\n        var t = new Table();\n        t.model = table;\n        tables[table.name] = t;\n        return tables;\n      }, {});\n      this.conditionalFormattings = value.conditionalFormattings;\n    }\n  }]);\n\n  return Worksheet;\n}();\n\nmodule.exports = Worksheet;","map":{"version":3,"sources":["../../../lib/doc/worksheet.js"],"names":["_","require","colCache","Range","Row","Column","Enums","Image","Table","DataValidations","Encryptor","Worksheet","options","defaultRowHeight","dyDescent","outlineLevelCol","outlineLevelRow","margins","left","right","top","bottom","header","footer","orientation","horizontalDpi","verticalDpi","fitToPage","pageOrder","blackAndWhite","draft","cellComments","errors","scale","fitToWidth","fitToHeight","paperSize","showRowColHeaders","showGridLines","firstPageNumber","horizontalCentered","verticalCentered","rowBreaks","colBreaks","differentFirst","differentOddEven","oddHeader","oddFooter","evenHeader","evenFooter","firstHeader","firstFooter","dimensions","rowDims","row","value","headerCount","cv","Math","count","columns","column","key","f","c","col","n","start","inserts","rows","nRows","i","rowArguments","insert","r","nExpand","nKeep","nEnd","maxCount","counts","length","style","rowNo","pos","values","src","dest","styleEmpty","rSrc","rDst","Object","includeEmpty","cell","rowNum","nInserts","cellToBeMerged","prevMaster","newMaster","iteratee","address","cells","ignoreStyle","merge","master","j","range","formula","results","shareType","decoded","width","masterAddress","isShared","getResult","Array","first","ref","result","sharedFormula","imageId","model","type","m","image","password","sheet","Number","resolve","table","name","cf","filter","console","id","dataValidations","properties","state","pageSetup","headerFooter","views","autoFilter","media","medium","sheetProtection","tables","conditionalFormattings","rowModel","t","module"],"mappings":"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","sourcesContent":["const _ = require('../utils/under-dash');\r\n\r\nconst colCache = require('../utils/col-cache');\r\nconst Range = require('./range');\r\nconst Row = require('./row');\r\nconst Column = require('./column');\r\nconst Enums = require('./enums');\r\nconst Image = require('./image');\r\nconst Table = require('./table');\r\nconst DataValidations = require('./data-validations');\r\nconst Encryptor = require('../utils/encryptor');\r\n\r\n// Worksheet requirements\r\n//  Operate as sheet inside workbook or standalone\r\n//  Load and Save from file and stream\r\n//  Access/Add/Delete individual cells\r\n//  Manage column widths and row heights\r\n\r\nclass Worksheet {\r\n  constructor(options) {\r\n    options = options || {};\r\n\r\n    // in a workbook, each sheet will have a number\r\n    this.id = options.id;\r\n    this.orderNo = options.orderNo;\r\n\r\n    // and a name\r\n    this.name = options.name || `Sheet${this.id}`;\r\n\r\n    // add a state\r\n    this.state = options.state || 'visible';\r\n\r\n    // rows allows access organised by row. Sparse array of arrays indexed by row-1, col\r\n    // Note: _rows is zero based. Must subtract 1 to go from cell.row to index\r\n    this._rows = [];\r\n\r\n    // column definitions\r\n    this._columns = null;\r\n\r\n    // column keys (addRow convenience): key ==> this._collumns index\r\n    this._keys = {};\r\n\r\n    // keep record of all merges\r\n    this._merges = {};\r\n\r\n    // record of all row and column pageBreaks\r\n    this.rowBreaks = [];\r\n\r\n    this._workbook = options.workbook;\r\n\r\n    // for tabColor, default row height, outline levels, etc\r\n    this.properties = Object.assign(\r\n      {},\r\n      {\r\n        defaultRowHeight: 15,\r\n        dyDescent: 55,\r\n        outlineLevelCol: 0,\r\n        outlineLevelRow: 0,\r\n      },\r\n      options.properties\r\n    );\r\n\r\n    // for all things printing\r\n    this.pageSetup = Object.assign(\r\n      {},\r\n      {\r\n        margins: {left: 0.7, right: 0.7, top: 0.75, bottom: 0.75, header: 0.3, footer: 0.3},\r\n        orientation: 'portrait',\r\n        horizontalDpi: 4294967295,\r\n        verticalDpi: 4294967295,\r\n        fitToPage: !!(\r\n          options.pageSetup &&\r\n          (options.pageSetup.fitToWidth || options.pageSetup.fitToHeight) &&\r\n          !options.pageSetup.scale\r\n        ),\r\n        pageOrder: 'downThenOver',\r\n        blackAndWhite: false,\r\n        draft: false,\r\n        cellComments: 'None',\r\n        errors: 'displayed',\r\n        scale: 100,\r\n        fitToWidth: 1,\r\n        fitToHeight: 1,\r\n        paperSize: undefined,\r\n        showRowColHeaders: false,\r\n        showGridLines: false,\r\n        firstPageNumber: undefined,\r\n        horizontalCentered: false,\r\n        verticalCentered: false,\r\n        rowBreaks: null,\r\n        colBreaks: null,\r\n      },\r\n      options.pageSetup\r\n    );\r\n\r\n    this.headerFooter = Object.assign(\r\n      {},\r\n      {\r\n        differentFirst: false,\r\n        differentOddEven: false,\r\n        oddHeader: null,\r\n        oddFooter: null,\r\n        evenHeader: null,\r\n        evenFooter: null,\r\n        firstHeader: null,\r\n        firstFooter: null,\r\n      },\r\n      options.headerFooter\r\n    );\r\n\r\n    this.dataValidations = new DataValidations();\r\n\r\n    // for freezepanes, split, zoom, gridlines, etc\r\n    this.views = options.views || [];\r\n\r\n    this.autoFilter = options.autoFilter || null;\r\n\r\n    // for images, etc\r\n    this._media = [];\r\n\r\n    // worksheet protection\r\n    this.sheetProtection = null;\r\n\r\n    // for tables\r\n    this.tables = {};\r\n\r\n    this.conditionalFormattings = [];\r\n  }\r\n\r\n  get workbook() {\r\n    return this._workbook;\r\n  }\r\n\r\n  // when you're done with this worksheet, call this to remove from workbook\r\n  destroy() {\r\n    this._workbook.removeWorksheetEx(this);\r\n  }\r\n\r\n  // Get the bounding range of the cells in this worksheet\r\n  get dimensions() {\r\n    const dimensions = new Range();\r\n    this._rows.forEach(row => {\r\n      if (row) {\r\n        const rowDims = row.dimensions;\r\n        if (rowDims) {\r\n          dimensions.expand(row.number, rowDims.min, row.number, rowDims.max);\r\n        }\r\n      }\r\n    });\r\n    return dimensions;\r\n  }\r\n\r\n  // =========================================================================\r\n  // Columns\r\n\r\n  // get the current columns array.\r\n  get columns() {\r\n    return this._columns;\r\n  }\r\n\r\n  // set the columns from an array of column definitions.\r\n  // Note: any headers defined will overwrite existing values.\r\n  set columns(value) {\r\n    // calculate max header row count\r\n    this._headerRowCount = value.reduce((pv, cv) => {\r\n      const headerCount = (cv.header && 1) || (cv.headers && cv.headers.length) || 0;\r\n      return Math.max(pv, headerCount);\r\n    }, 0);\r\n\r\n    // construct Column objects\r\n    let count = 1;\r\n    const columns = (this._columns = []);\r\n    value.forEach(defn => {\r\n      const column = new Column(this, count++, false);\r\n      columns.push(column);\r\n      column.defn = defn;\r\n    });\r\n  }\r\n\r\n  getColumnKey(key) {\r\n    return this._keys[key];\r\n  }\r\n\r\n  setColumnKey(key, value) {\r\n    this._keys[key] = value;\r\n  }\r\n\r\n  deleteColumnKey(key) {\r\n    delete this._keys[key];\r\n  }\r\n\r\n  eachColumnKey(f) {\r\n    _.each(this._keys, f);\r\n  }\r\n\r\n  // get a single column by col number. If it doesn't exist, create it and any gaps before it\r\n  getColumn(c) {\r\n    if (typeof c === 'string') {\r\n      // if it matches a key'd column, return that\r\n      const col = this._keys[c];\r\n      if (col) return col;\r\n\r\n      // otherwise, assume letter\r\n      c = colCache.l2n(c);\r\n    }\r\n    if (!this._columns) {\r\n      this._columns = [];\r\n    }\r\n    if (c > this._columns.length) {\r\n      let n = this._columns.length + 1;\r\n      while (n <= c) {\r\n        this._columns.push(new Column(this, n++));\r\n      }\r\n    }\r\n    return this._columns[c - 1];\r\n  }\r\n\r\n  spliceColumns(start, count, ...inserts) {\r\n    const rows = this._rows;\r\n    const nRows = rows.length;\r\n    if (inserts.length > 0) {\r\n      // must iterate over all rows whether they exist yet or not\r\n      for (let i = 0; i < nRows; i++) {\r\n        const rowArguments = [start, count];\r\n        // eslint-disable-next-line no-loop-func\r\n        inserts.forEach(insert => {\r\n          rowArguments.push(insert[i] || null);\r\n        });\r\n        const row = this.getRow(i + 1);\r\n        // eslint-disable-next-line prefer-spread\r\n        row.splice.apply(row, rowArguments);\r\n      }\r\n    } else {\r\n      // nothing to insert, so just splice all rows\r\n      this._rows.forEach(r => {\r\n        if (r) {\r\n          r.splice(start, count);\r\n        }\r\n      });\r\n    }\r\n\r\n    // splice column definitions\r\n    const nExpand = inserts.length - count;\r\n    const nKeep = start + count;\r\n    const nEnd = this._columns.length;\r\n    if (nExpand < 0) {\r\n      for (let i = start + inserts.length; i <= nEnd; i++) {\r\n        this.getColumn(i).defn = this.getColumn(i - nExpand).defn;\r\n      }\r\n    } else if (nExpand > 0) {\r\n      for (let i = nEnd; i >= nKeep; i--) {\r\n        this.getColumn(i + nExpand).defn = this.getColumn(i).defn;\r\n      }\r\n    }\r\n    for (let i = start; i < start + inserts.length; i++) {\r\n      this.getColumn(i).defn = null;\r\n    }\r\n\r\n    // account for defined names\r\n    this.workbook.definedNames.spliceColumns(this.name, start, count, inserts.length);\r\n  }\r\n\r\n  get lastColumn() {\r\n    return this.getColumn(this.columnCount);\r\n  }\r\n\r\n  get columnCount() {\r\n    let maxCount = 0;\r\n    this.eachRow(row => {\r\n      maxCount = Math.max(maxCount, row.cellCount);\r\n    });\r\n    return maxCount;\r\n  }\r\n\r\n  get actualColumnCount() {\r\n    // performance nightmare - for each row, counts all the columns used\r\n    const counts = [];\r\n    let count = 0;\r\n    this.eachRow(row => {\r\n      row.eachCell(({col}) => {\r\n        if (!counts[col]) {\r\n          counts[col] = true;\r\n          count++;\r\n        }\r\n      });\r\n    });\r\n    return count;\r\n  }\r\n\r\n  // =========================================================================\r\n  // Rows\r\n\r\n  _commitRow() {\r\n    // nop - allows streaming reader to fill a document\r\n  }\r\n\r\n  get _lastRowNumber() {\r\n    // need to cope with results of splice\r\n    const rows = this._rows;\r\n    let n = rows.length;\r\n    while (n > 0 && rows[n - 1] === undefined) {\r\n      n--;\r\n    }\r\n    return n;\r\n  }\r\n\r\n  get _nextRow() {\r\n    return this._lastRowNumber + 1;\r\n  }\r\n\r\n  get lastRow() {\r\n    if (this._rows.length) {\r\n      return this._rows[this._rows.length - 1];\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  // find a row (if exists) by row number\r\n  findRow(r) {\r\n    return this._rows[r - 1];\r\n  }\r\n\r\n  // find multiple rows (if exists) by row number\r\n  findRows(start, length) {\r\n    return this._rows.slice(start - 1, start - 1 + length);\r\n  }\r\n\r\n  get rowCount() {\r\n    return this._lastRowNumber;\r\n  }\r\n\r\n  get actualRowCount() {\r\n    // counts actual rows that have actual data\r\n    let count = 0;\r\n    this.eachRow(() => {\r\n      count++;\r\n    });\r\n    return count;\r\n  }\r\n\r\n  // get a row by row number.\r\n  getRow(r) {\r\n    let row = this._rows[r - 1];\r\n    if (!row) {\r\n      row = this._rows[r - 1] = new Row(this, r);\r\n    }\r\n    return row;\r\n  }\r\n\r\n  // get multiple rows by row number.\r\n  getRows(start, length) {\r\n    if (length < 1) return undefined;\r\n    const rows = [];\r\n    for (let i = start; i < start + length; i++) {\r\n      rows.push(this.getRow(i));\r\n    }\r\n    return rows;\r\n  }\r\n\r\n  addRow(value, style = 'n') {\r\n    const rowNo = this._nextRow;\r\n    const row = this.getRow(rowNo);\r\n    row.values = value;\r\n    this._setStyleOption(rowNo, style[0] === 'i' ? style : 'n');\r\n    return row;\r\n  }\r\n\r\n  addRows(value, style = 'n') {\r\n    const rows = [];\r\n    value.forEach(row => {\r\n      rows.push(this.addRow(row, style));\r\n    });\r\n    return rows;\r\n  }\r\n\r\n  insertRow(pos, value, style = 'n') {\r\n    this.spliceRows(pos, 0, value);\r\n    this._setStyleOption(pos, style);\r\n    return this.getRow(pos);\r\n  }\r\n\r\n  insertRows(pos, values, style = 'n') {\r\n    this.spliceRows(pos, 0, ...values);\r\n    if (style !== 'n') {\r\n      // copy over the styles\r\n      for (let i = 0; i < values.length; i++) {\r\n        if (style[0] === 'o' && this.findRow(values.length + pos + i) !== undefined) {\r\n          this._copyStyle(values.length + pos + i, pos + i, style[1] === '+');\r\n        } else if (style[0] === 'i' && this.findRow(pos - 1) !== undefined) {\r\n          this._copyStyle(pos - 1, pos + i, style[1] === '+');\r\n        }\r\n      }\r\n    }\r\n    return this.getRows(pos, values.length);\r\n  }\r\n\r\n  // set row at position to same style as of either pervious row (option 'i') or next row (option 'o')\r\n  _setStyleOption(pos, style = 'n') {\r\n    if (style[0] === 'o' && this.findRow(pos + 1) !== undefined) {\r\n      this._copyStyle(pos + 1, pos, style[1] === '+');\r\n    } else if (style[0] === 'i' && this.findRow(pos - 1) !== undefined) {\r\n      this._copyStyle(pos - 1, pos, style[1] === '+');\r\n    }\r\n  }\r\n\r\n  _copyStyle(src, dest, styleEmpty = false) {\r\n    const rSrc = this.getRow(src);\r\n    const rDst = this.getRow(dest);\r\n    rDst.style = Object.freeze({...rSrc.style});\r\n    // eslint-disable-next-line no-loop-func\r\n    rSrc.eachCell({includeEmpty: styleEmpty}, (cell, colNumber) => {\r\n      rDst.getCell(colNumber).style = Object.freeze({...cell.style});\r\n    });\r\n    rDst.height = rSrc.height;\r\n  }\r\n\r\n  duplicateRow(rowNum, count, insert = false) {\r\n    // create count duplicates of rowNum\r\n    // either inserting new or overwriting existing rows\r\n\r\n    const rSrc = this._rows[rowNum - 1];\r\n    const inserts = new Array(count).fill(rSrc.values);\r\n    this.spliceRows(rowNum + 1, insert ? 0 : count, ...inserts);\r\n\r\n    // now copy styles...\r\n    for (let i = 0; i < count; i++) {\r\n      const rDst = this._rows[rowNum + i];\r\n      rDst.style = rSrc.style;\r\n      rDst.height = rSrc.height;\r\n      // eslint-disable-next-line no-loop-func\r\n      rSrc.eachCell({includeEmpty: true}, (cell, colNumber) => {\r\n        rDst.getCell(colNumber).style = cell.style;\r\n      });\r\n    }\r\n  }\r\n\r\n  spliceRows(start, count, ...inserts) {\r\n    // same problem as row.splice, except worse.\r\n    const nKeep = start + count;\r\n    const nInserts = inserts.length;\r\n    const nExpand = nInserts - count;\r\n    const nEnd = this._rows.length;\r\n    let i;\r\n    let rSrc;\r\n    if (nExpand < 0) {\r\n      // remove rows\r\n      for (i = nKeep; i <= nEnd; i++) {\r\n        rSrc = this._rows[i - 1];\r\n        if (rSrc) {\r\n          const rDst = this.getRow(i + nExpand);\r\n          rDst.values = rSrc.values;\r\n          rDst.style = rSrc.style;\r\n          rDst.height = rSrc.height;\r\n          // eslint-disable-next-line no-loop-func\r\n          rSrc.eachCell({includeEmpty: true}, (cell, colNumber) => {\r\n            rDst.getCell(colNumber).style = cell.style;\r\n          });\r\n          this._rows[i - 1] = undefined;\r\n        } else {\r\n          this._rows[i + nExpand - 1] = undefined;\r\n        }\r\n      }\r\n    } else if (nExpand > 0) {\r\n      // insert new cells\r\n      for (i = nEnd; i >= nKeep; i--) {\r\n        rSrc = this._rows[i - 1];\r\n        if (rSrc) {\r\n          const rDst = this.getRow(i + nExpand);\r\n          rDst.values = rSrc.values;\r\n          rDst.style = rSrc.style;\r\n          rDst.height = rSrc.height;\r\n          // eslint-disable-next-line no-loop-func\r\n          rSrc.eachCell({includeEmpty: true}, (cell, colNumber) => {\r\n            rDst.getCell(colNumber).style = cell.style;\r\n\r\n            // remerge cells accounting for insert offset\r\n            if (cell._value.constructor.name === 'MergeValue') {\r\n              const cellToBeMerged = this.getRow(cell._row._number + nInserts).getCell(colNumber);\r\n              const prevMaster = cell._value._master;\r\n              const newMaster = this\r\n                .getRow(prevMaster._row._number + nInserts)\r\n                .getCell(prevMaster._column._number)\r\n              cellToBeMerged.merge(newMaster);\r\n            }\r\n          });\r\n        } else {\r\n          this._rows[i + nExpand - 1] = undefined;\r\n        }\r\n      }\r\n    }\r\n\r\n    // now copy over the new values\r\n    for (i = 0; i < nInserts; i++) {\r\n      const rDst = this.getRow(start + i);\r\n      rDst.style = {};\r\n      rDst.values = inserts[i];\r\n    }\r\n\r\n    // account for defined names\r\n    this.workbook.definedNames.spliceRows(this.name, start, count, nInserts);\r\n  }\r\n\r\n  // iterate over every row in the worksheet, including maybe empty rows\r\n  eachRow(options, iteratee) {\r\n    if (!iteratee) {\r\n      iteratee = options;\r\n      options = undefined;\r\n    }\r\n    if (options && options.includeEmpty) {\r\n      const n = this._rows.length;\r\n      for (let i = 1; i <= n; i++) {\r\n        iteratee(this.getRow(i), i);\r\n      }\r\n    } else {\r\n      this._rows.forEach(row => {\r\n        if (row && row.hasValues) {\r\n          iteratee(row, row.number);\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  // return all rows as sparse array\r\n  getSheetValues() {\r\n    const rows = [];\r\n    this._rows.forEach(row => {\r\n      if (row) {\r\n        rows[row.number] = row.values;\r\n      }\r\n    });\r\n    return rows;\r\n  }\r\n\r\n  // =========================================================================\r\n  // Cells\r\n\r\n  // returns the cell at [r,c] or address given by r. If not found, return undefined\r\n  findCell(r, c) {\r\n    const address = colCache.getAddress(r, c);\r\n    const row = this._rows[address.row - 1];\r\n    return row ? row.findCell(address.col) : undefined;\r\n  }\r\n\r\n  // return the cell at [r,c] or address given by r. If not found, create a new one.\r\n  getCell(r, c) {\r\n    const address = colCache.getAddress(r, c);\r\n    const row = this.getRow(address.row);\r\n    return row.getCellEx(address);\r\n  }\r\n\r\n  // =========================================================================\r\n  // Merge\r\n\r\n  // convert the range defined by ['tl:br'], [tl,br] or [t,l,b,r] into a single 'merged' cell\r\n  mergeCells(...cells) {\r\n    const dimensions = new Range(cells);\r\n    this._mergeCellsInternal(dimensions);\r\n  }\r\n\r\n  mergeCellsWithoutStyle(...cells) {\r\n    const dimensions = new Range(cells);\r\n    this._mergeCellsInternal(dimensions, true);\r\n  }\r\n\r\n  _mergeCellsInternal(dimensions, ignoreStyle) {\r\n    // check cells aren't already merged\r\n    _.each(this._merges, merge => {\r\n      if (merge.intersects(dimensions)) {\r\n        throw new Error('Cannot merge already merged cells');\r\n      }\r\n    });\r\n\r\n    // apply merge\r\n    const master = this.getCell(dimensions.top, dimensions.left);\r\n    for (let i = dimensions.top; i <= dimensions.bottom; i++) {\r\n      for (let j = dimensions.left; j <= dimensions.right; j++) {\r\n        // merge all but the master cell\r\n        if (i > dimensions.top || j > dimensions.left) {\r\n          this.getCell(i, j).merge(master, ignoreStyle);\r\n        }\r\n      }\r\n    }\r\n\r\n    // index merge\r\n    this._merges[master.address] = dimensions;\r\n  }\r\n\r\n  _unMergeMaster(master) {\r\n    // master is always top left of a rectangle\r\n    const merge = this._merges[master.address];\r\n    if (merge) {\r\n      for (let i = merge.top; i <= merge.bottom; i++) {\r\n        for (let j = merge.left; j <= merge.right; j++) {\r\n          this.getCell(i, j).unmerge();\r\n        }\r\n      }\r\n      delete this._merges[master.address];\r\n    }\r\n  }\r\n\r\n  get hasMerges() {\r\n    // return true if this._merges has a merge object\r\n    return _.some(this._merges, Boolean);\r\n  }\r\n\r\n  // scan the range defined by ['tl:br'], [tl,br] or [t,l,b,r] and if any cell is part of a merge,\r\n  // un-merge the group. Note this function can affect multiple merges and merge-blocks are\r\n  // atomic - either they're all merged or all un-merged.\r\n  unMergeCells(...cells) {\r\n    const dimensions = new Range(cells);\r\n\r\n    // find any cells in that range and unmerge them\r\n    for (let i = dimensions.top; i <= dimensions.bottom; i++) {\r\n      for (let j = dimensions.left; j <= dimensions.right; j++) {\r\n        const cell = this.findCell(i, j);\r\n        if (cell) {\r\n          if (cell.type === Enums.ValueType.Merge) {\r\n            // this cell merges to another master\r\n            this._unMergeMaster(cell.master);\r\n          } else if (this._merges[cell.address]) {\r\n            // this cell is a master\r\n            this._unMergeMaster(cell);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // ===========================================================================\r\n  // Shared/Array Formula\r\n  fillFormula(range, formula, results, shareType = 'shared') {\r\n    // Define formula for top-left cell and share to rest\r\n    const decoded = colCache.decode(range);\r\n    const {top, left, bottom, right} = decoded;\r\n    const width = right - left + 1;\r\n    const masterAddress = colCache.encodeAddress(top, left);\r\n    const isShared = shareType === 'shared';\r\n\r\n    // work out result accessor\r\n    let getResult;\r\n    if (typeof results === 'function') {\r\n      getResult = results;\r\n    } else if (Array.isArray(results)) {\r\n      if (Array.isArray(results[0])) {\r\n        getResult = (row, col) => results[row - top][col - left];\r\n      } else {\r\n        // eslint-disable-next-line no-mixed-operators\r\n        getResult = (row, col) => results[(row - top) * width + (col - left)];\r\n      }\r\n    } else {\r\n      getResult = () => undefined;\r\n    }\r\n    let first = true;\r\n    for (let r = top; r <= bottom; r++) {\r\n      for (let c = left; c <= right; c++) {\r\n        if (first) {\r\n          this.getCell(r, c).value = {\r\n            shareType,\r\n            formula,\r\n            ref: range,\r\n            result: getResult(r, c),\r\n          };\r\n          first = false;\r\n        } else {\r\n          this.getCell(r, c).value = isShared\r\n            ? {\r\n                sharedFormula: masterAddress,\r\n                result: getResult(r, c),\r\n              }\r\n            : getResult(r, c);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // =========================================================================\r\n  // Images\r\n  addImage(imageId, range) {\r\n    const model = {\r\n      type: 'image',\r\n      imageId,\r\n      range,\r\n    };\r\n    this._media.push(new Image(this, model));\r\n  }\r\n\r\n  getImages() {\r\n    return this._media.filter(m => m.type === 'image');\r\n  }\r\n\r\n  addBackgroundImage(imageId) {\r\n    const model = {\r\n      type: 'background',\r\n      imageId,\r\n    };\r\n    this._media.push(new Image(this, model));\r\n  }\r\n\r\n  getBackgroundImageId() {\r\n    const image = this._media.find(m => m.type === 'background');\r\n    return image && image.imageId;\r\n  }\r\n\r\n  // =========================================================================\r\n  // Worksheet Protection\r\n  protect(password, options) {\r\n    // TODO: make this function truly async\r\n    // perhaps marshal to worker thread or something\r\n    return new Promise(resolve => {\r\n      this.sheetProtection = {\r\n        sheet: true,\r\n      };\r\n      if (options && 'spinCount' in options) {\r\n        // force spinCount to be integer >= 0\r\n        options.spinCount = Number.isFinite(options.spinCount)\r\n          ? Math.round(Math.max(0, options.spinCount))\r\n          : 100000;\r\n      }\r\n      if (password) {\r\n        this.sheetProtection.algorithmName = 'SHA-512';\r\n        this.sheetProtection.saltValue = Encryptor.randomBytes(16).toString('base64');\r\n        this.sheetProtection.spinCount =\r\n          options && 'spinCount' in options ? options.spinCount : 100000; // allow user specified spinCount\r\n        this.sheetProtection.hashValue = Encryptor.convertPasswordToHash(\r\n          password,\r\n          'SHA512',\r\n          this.sheetProtection.saltValue,\r\n          this.sheetProtection.spinCount\r\n        );\r\n      }\r\n      if (options) {\r\n        this.sheetProtection = Object.assign(this.sheetProtection, options);\r\n        if (!password && 'spinCount' in options) {\r\n          delete this.sheetProtection.spinCount;\r\n        }\r\n      }\r\n      resolve();\r\n    });\r\n  }\r\n\r\n  unprotect() {\r\n    this.sheetProtection = null;\r\n  }\r\n\r\n  // =========================================================================\r\n  // Tables\r\n  addTable(model) {\r\n    const table = new Table(this, model);\r\n    this.tables[model.name] = table;\r\n    return table;\r\n  }\r\n\r\n  getTable(name) {\r\n    return this.tables[name];\r\n  }\r\n\r\n  removeTable(name) {\r\n    delete this.tables[name];\r\n  }\r\n\r\n  getTables() {\r\n    return Object.values(this.tables);\r\n  }\r\n\r\n  // ===========================================================================\r\n  // Conditional Formatting\r\n  addConditionalFormatting(cf) {\r\n    this.conditionalFormattings.push(cf);\r\n  }\r\n\r\n  removeConditionalFormatting(filter) {\r\n    if (typeof filter === 'number') {\r\n      this.conditionalFormattings.splice(filter, 1);\r\n    } else if (filter instanceof Function) {\r\n      this.conditionalFormattings = this.conditionalFormattings.filter(filter);\r\n    } else {\r\n      this.conditionalFormattings = [];\r\n    }\r\n  }\r\n\r\n  // ===========================================================================\r\n  // Deprecated\r\n  get tabColor() {\r\n    // eslint-disable-next-line no-console\r\n    console.trace(\r\n      'worksheet.tabColor property is now deprecated. Please use worksheet.properties.tabColor'\r\n    );\r\n    return this.properties.tabColor;\r\n  }\r\n\r\n  set tabColor(value) {\r\n    // eslint-disable-next-line no-console\r\n    console.trace(\r\n      'worksheet.tabColor property is now deprecated. Please use worksheet.properties.tabColor'\r\n    );\r\n    this.properties.tabColor = value;\r\n  }\r\n\r\n  // ===========================================================================\r\n  // Model\r\n\r\n  get model() {\r\n    const model = {\r\n      id: this.id,\r\n      name: this.name,\r\n      dataValidations: this.dataValidations.model,\r\n      properties: this.properties,\r\n      state: this.state,\r\n      pageSetup: this.pageSetup,\r\n      headerFooter: this.headerFooter,\r\n      rowBreaks: this.rowBreaks,\r\n      views: this.views,\r\n      autoFilter: this.autoFilter,\r\n      media: this._media.map(medium => medium.model),\r\n      sheetProtection: this.sheetProtection,\r\n      tables: Object.values(this.tables).map(table => table.model),\r\n      conditionalFormattings: this.conditionalFormattings,\r\n    };\r\n\r\n    // =================================================\r\n    // columns\r\n    model.cols = Column.toModel(this.columns);\r\n\r\n    // ==========================================================\r\n    // Rows\r\n    const rows = (model.rows = []);\r\n    const dimensions = (model.dimensions = new Range());\r\n    this._rows.forEach(row => {\r\n      const rowModel = row && row.model;\r\n      if (rowModel) {\r\n        dimensions.expand(rowModel.number, rowModel.min, rowModel.number, rowModel.max);\r\n        rows.push(rowModel);\r\n      }\r\n    });\r\n\r\n    // ==========================================================\r\n    // Merges\r\n    model.merges = [];\r\n    _.each(this._merges, merge => {\r\n      model.merges.push(merge.range);\r\n    });\r\n\r\n    return model;\r\n  }\r\n\r\n  _parseRows(model) {\r\n    this._rows = [];\r\n    model.rows.forEach(rowModel => {\r\n      const row = new Row(this, rowModel.number);\r\n      this._rows[row.number - 1] = row;\r\n      row.model = rowModel;\r\n    });\r\n  }\r\n\r\n  _parseMergeCells(model) {\r\n    _.each(model.mergeCells, merge => {\r\n      // Do not merge styles when importing an Excel file\r\n      // since each cell may have different styles intentionally.\r\n      this.mergeCellsWithoutStyle(merge);\r\n    });\r\n  }\r\n\r\n  set model(value) {\r\n    this.name = value.name;\r\n    this._columns = Column.fromModel(this, value.cols);\r\n    this._parseRows(value);\r\n\r\n    this._parseMergeCells(value);\r\n    this.dataValidations = new DataValidations(value.dataValidations);\r\n    this.properties = value.properties;\r\n    this.pageSetup = value.pageSetup;\r\n    this.headerFooter = value.headerFooter;\r\n    this.views = value.views;\r\n    this.autoFilter = value.autoFilter;\r\n    this._media = value.media.map(medium => new Image(this, medium));\r\n    this.sheetProtection = value.sheetProtection;\r\n    this.tables = value.tables.reduce((tables, table) => {\r\n      const t = new Table();\r\n      t.model = table;\r\n      tables[table.name] = t;\r\n      return tables;\r\n    }, {});\r\n    this.conditionalFormattings = value.conditionalFormattings;\r\n  }\r\n}\r\n\r\nmodule.exports = Worksheet;\r\n"]},"metadata":{},"sourceType":"script"}