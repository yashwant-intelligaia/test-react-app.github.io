{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Parser = void 0;\n\nconst Scanner_1 = require(\"./Scanner\");\n\nconst RowParser_1 = require(\"./RowParser\");\n\nconst Token_1 = require(\"./Token\");\n\nconst EMPTY_ROW_REGEXP = /^\\s*(?:''|\"\")?\\s*(?:,\\s*(?:''|\"\")?\\s*)*$/;\n\nclass Parser {\n  constructor(parserOptions) {\n    this.parserOptions = parserOptions;\n    this.rowParser = new RowParser_1.RowParser(this.parserOptions);\n  }\n\n  static removeBOM(line) {\n    // Catches EFBBBF (UTF-8 BOM) because the buffer-to-string\n    // conversion translates it to FEFF (UTF-16 BOM)\n    if (line && line.charCodeAt(0) === 0xfeff) {\n      return line.slice(1);\n    }\n\n    return line;\n  }\n\n  parse(line, hasMoreData) {\n    const scanner = new Scanner_1.Scanner({\n      line: Parser.removeBOM(line),\n      parserOptions: this.parserOptions,\n      hasMoreData\n    });\n\n    if (this.parserOptions.supportsComments) {\n      return this.parseWithComments(scanner);\n    }\n\n    return this.parseWithoutComments(scanner);\n  }\n\n  parseWithoutComments(scanner) {\n    const rows = [];\n    let shouldContinue = true;\n\n    while (shouldContinue) {\n      shouldContinue = this.parseRow(scanner, rows);\n    }\n\n    return {\n      line: scanner.line,\n      rows\n    };\n  }\n\n  parseWithComments(scanner) {\n    const {\n      parserOptions\n    } = this;\n    const rows = [];\n\n    for (let nextToken = scanner.nextCharacterToken; nextToken !== null; nextToken = scanner.nextCharacterToken) {\n      if (Token_1.Token.isTokenComment(nextToken, parserOptions)) {\n        const cursor = scanner.advancePastLine();\n\n        if (cursor === null) {\n          return {\n            line: scanner.lineFromCursor,\n            rows\n          };\n        }\n\n        if (!scanner.hasMoreCharacters) {\n          return {\n            line: scanner.lineFromCursor,\n            rows\n          };\n        }\n\n        scanner.truncateToCursor();\n      } else if (!this.parseRow(scanner, rows)) {\n        break;\n      }\n    }\n\n    return {\n      line: scanner.line,\n      rows\n    };\n  }\n\n  parseRow(scanner, rows) {\n    const nextToken = scanner.nextNonSpaceToken;\n\n    if (!nextToken) {\n      return false;\n    }\n\n    const row = this.rowParser.parse(scanner);\n\n    if (row === null) {\n      return false;\n    }\n\n    if (this.parserOptions.ignoreEmpty && EMPTY_ROW_REGEXP.test(row.join(''))) {\n      return true;\n    }\n\n    rows.push(row);\n    return true;\n  }\n\n}\n\nexports.Parser = Parser;","map":{"version":3,"sources":["../../../src/parser/Parser.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Parser = void 0;\nconst Scanner_1 = require(\"./Scanner\");\nconst RowParser_1 = require(\"./RowParser\");\nconst Token_1 = require(\"./Token\");\nconst EMPTY_ROW_REGEXP = /^\\s*(?:''|\"\")?\\s*(?:,\\s*(?:''|\"\")?\\s*)*$/;\nclass Parser {\n    constructor(parserOptions) {\n        this.parserOptions = parserOptions;\n        this.rowParser = new RowParser_1.RowParser(this.parserOptions);\n    }\n    static removeBOM(line) {\n        // Catches EFBBBF (UTF-8 BOM) because the buffer-to-string\n        // conversion translates it to FEFF (UTF-16 BOM)\n        if (line && line.charCodeAt(0) === 0xfeff) {\n            return line.slice(1);\n        }\n        return line;\n    }\n    parse(line, hasMoreData) {\n        const scanner = new Scanner_1.Scanner({\n            line: Parser.removeBOM(line),\n            parserOptions: this.parserOptions,\n            hasMoreData,\n        });\n        if (this.parserOptions.supportsComments) {\n            return this.parseWithComments(scanner);\n        }\n        return this.parseWithoutComments(scanner);\n    }\n    parseWithoutComments(scanner) {\n        const rows = [];\n        let shouldContinue = true;\n        while (shouldContinue) {\n            shouldContinue = this.parseRow(scanner, rows);\n        }\n        return { line: scanner.line, rows };\n    }\n    parseWithComments(scanner) {\n        const { parserOptions } = this;\n        const rows = [];\n        for (let nextToken = scanner.nextCharacterToken; nextToken !== null; nextToken = scanner.nextCharacterToken) {\n            if (Token_1.Token.isTokenComment(nextToken, parserOptions)) {\n                const cursor = scanner.advancePastLine();\n                if (cursor === null) {\n                    return { line: scanner.lineFromCursor, rows };\n                }\n                if (!scanner.hasMoreCharacters) {\n                    return { line: scanner.lineFromCursor, rows };\n                }\n                scanner.truncateToCursor();\n            }\n            else if (!this.parseRow(scanner, rows)) {\n                break;\n            }\n        }\n        return { line: scanner.line, rows };\n    }\n    parseRow(scanner, rows) {\n        const nextToken = scanner.nextNonSpaceToken;\n        if (!nextToken) {\n            return false;\n        }\n        const row = this.rowParser.parse(scanner);\n        if (row === null) {\n            return false;\n        }\n        if (this.parserOptions.ignoreEmpty && EMPTY_ROW_REGEXP.test(row.join(''))) {\n            return true;\n        }\n        rows.push(row);\n        return true;\n    }\n}\nexports.Parser = Parser;\n//# sourceMappingURL=Parser.js.map"]},"metadata":{},"sourceType":"script"}