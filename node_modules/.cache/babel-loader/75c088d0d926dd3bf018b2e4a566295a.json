{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CsvParserStream = void 0;\n\nconst string_decoder_1 = require(\"string_decoder\");\n\nconst stream_1 = require(\"stream\");\n\nconst transforms_1 = require(\"./transforms\");\n\nconst parser_1 = require(\"./parser\");\n\nclass CsvParserStream extends stream_1.Transform {\n  constructor(parserOptions) {\n    super({\n      objectMode: parserOptions.objectMode\n    });\n    this.lines = '';\n    this.rowCount = 0;\n    this.parsedRowCount = 0;\n    this.parsedLineCount = 0;\n    this.endEmitted = false;\n    this.headersEmitted = false;\n    this.parserOptions = parserOptions;\n    this.parser = new parser_1.Parser(parserOptions);\n    this.headerTransformer = new transforms_1.HeaderTransformer(parserOptions);\n    this.decoder = new string_decoder_1.StringDecoder(parserOptions.encoding);\n    this.rowTransformerValidator = new transforms_1.RowTransformerValidator();\n  }\n\n  get hasHitRowLimit() {\n    return this.parserOptions.limitRows && this.rowCount >= this.parserOptions.maxRows;\n  }\n\n  get shouldEmitRows() {\n    return this.parsedRowCount > this.parserOptions.skipRows;\n  }\n\n  get shouldSkipLine() {\n    return this.parsedLineCount <= this.parserOptions.skipLines;\n  }\n\n  transform(transformFunction) {\n    this.rowTransformerValidator.rowTransform = transformFunction;\n    return this;\n  }\n\n  validate(validateFunction) {\n    this.rowTransformerValidator.rowValidator = validateFunction;\n    return this;\n  } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  emit(event, ...rest) {\n    if (event === 'end') {\n      if (!this.endEmitted) {\n        this.endEmitted = true;\n        super.emit('end', this.rowCount);\n      }\n\n      return false;\n    }\n\n    return super.emit(event, ...rest);\n  }\n\n  _transform(data, encoding, done) {\n    // if we have hit our maxRows parsing limit then skip parsing\n    if (this.hasHitRowLimit) {\n      return done();\n    }\n\n    const wrappedCallback = CsvParserStream.wrapDoneCallback(done);\n\n    try {\n      const {\n        lines\n      } = this;\n      const newLine = lines + this.decoder.write(data);\n      const rows = this.parse(newLine, true);\n      return this.processRows(rows, wrappedCallback);\n    } catch (e) {\n      return wrappedCallback(e);\n    }\n  }\n\n  _flush(done) {\n    const wrappedCallback = CsvParserStream.wrapDoneCallback(done); // if we have hit our maxRows parsing limit then skip parsing\n\n    if (this.hasHitRowLimit) {\n      return wrappedCallback();\n    }\n\n    try {\n      const newLine = this.lines + this.decoder.end();\n      const rows = this.parse(newLine, false);\n      return this.processRows(rows, wrappedCallback);\n    } catch (e) {\n      return wrappedCallback(e);\n    }\n  }\n\n  parse(data, hasMoreData) {\n    if (!data) {\n      return [];\n    }\n\n    const {\n      line,\n      rows\n    } = this.parser.parse(data, hasMoreData);\n    this.lines = line;\n    return rows;\n  }\n\n  processRows(rows, cb) {\n    const rowsLength = rows.length;\n\n    const iterate = i => {\n      const callNext = err => {\n        if (err) {\n          return cb(err);\n        }\n\n        if (i % 100 === 0) {\n          // incase the transform are sync insert a next tick to prevent stack overflow\n          setImmediate(() => iterate(i + 1));\n          return undefined;\n        }\n\n        return iterate(i + 1);\n      };\n\n      this.checkAndEmitHeaders(); // if we have emitted all rows or we have hit the maxRows limit option\n      // then end\n\n      if (i >= rowsLength || this.hasHitRowLimit) {\n        return cb();\n      }\n\n      this.parsedLineCount += 1;\n\n      if (this.shouldSkipLine) {\n        return callNext();\n      }\n\n      const row = rows[i];\n      this.rowCount += 1;\n      this.parsedRowCount += 1;\n      const nextRowCount = this.rowCount;\n      return this.transformRow(row, (err, transformResult) => {\n        if (err) {\n          this.rowCount -= 1;\n          return callNext(err);\n        }\n\n        if (!transformResult) {\n          return callNext(new Error('expected transform result'));\n        }\n\n        if (!transformResult.isValid) {\n          this.emit('data-invalid', transformResult.row, nextRowCount, transformResult.reason);\n        } else if (transformResult.row) {\n          return this.pushRow(transformResult.row, callNext);\n        }\n\n        return callNext();\n      });\n    };\n\n    iterate(0);\n  }\n\n  transformRow(parsedRow, cb) {\n    try {\n      this.headerTransformer.transform(parsedRow, (err, withHeaders) => {\n        if (err) {\n          return cb(err);\n        }\n\n        if (!withHeaders) {\n          return cb(new Error('Expected result from header transform'));\n        }\n\n        if (!withHeaders.isValid) {\n          if (this.shouldEmitRows) {\n            return cb(null, {\n              isValid: false,\n              row: parsedRow\n            });\n          } // skipped because of skipRows option remove from total row count\n\n\n          return this.skipRow(cb);\n        }\n\n        if (withHeaders.row) {\n          if (this.shouldEmitRows) {\n            return this.rowTransformerValidator.transformAndValidate(withHeaders.row, cb);\n          } // skipped because of skipRows option remove from total row count\n\n\n          return this.skipRow(cb);\n        } // this is a header row dont include in the rowCount or parsedRowCount\n\n\n        this.rowCount -= 1;\n        this.parsedRowCount -= 1;\n        return cb(null, {\n          row: null,\n          isValid: true\n        });\n      });\n    } catch (e) {\n      cb(e);\n    }\n  }\n\n  checkAndEmitHeaders() {\n    if (!this.headersEmitted && this.headerTransformer.headers) {\n      this.headersEmitted = true;\n      this.emit('headers', this.headerTransformer.headers);\n    }\n  }\n\n  skipRow(cb) {\n    // skipped because of skipRows option remove from total row count\n    this.rowCount -= 1;\n    return cb(null, {\n      row: null,\n      isValid: true\n    });\n  }\n\n  pushRow(row, cb) {\n    try {\n      if (!this.parserOptions.objectMode) {\n        this.push(JSON.stringify(row));\n      } else {\n        this.push(row);\n      }\n\n      cb();\n    } catch (e) {\n      cb(e);\n    }\n  }\n\n  static wrapDoneCallback(done) {\n    let errorCalled = false; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n    return (err, ...args) => {\n      if (err) {\n        if (errorCalled) {\n          throw err;\n        }\n\n        errorCalled = true;\n        done(err);\n        return;\n      }\n\n      done(...args);\n    };\n  }\n\n}\n\nexports.CsvParserStream = CsvParserStream;","map":{"version":3,"sources":["../../src/CsvParserStream.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CsvParserStream = void 0;\nconst string_decoder_1 = require(\"string_decoder\");\nconst stream_1 = require(\"stream\");\nconst transforms_1 = require(\"./transforms\");\nconst parser_1 = require(\"./parser\");\nclass CsvParserStream extends stream_1.Transform {\n    constructor(parserOptions) {\n        super({ objectMode: parserOptions.objectMode });\n        this.lines = '';\n        this.rowCount = 0;\n        this.parsedRowCount = 0;\n        this.parsedLineCount = 0;\n        this.endEmitted = false;\n        this.headersEmitted = false;\n        this.parserOptions = parserOptions;\n        this.parser = new parser_1.Parser(parserOptions);\n        this.headerTransformer = new transforms_1.HeaderTransformer(parserOptions);\n        this.decoder = new string_decoder_1.StringDecoder(parserOptions.encoding);\n        this.rowTransformerValidator = new transforms_1.RowTransformerValidator();\n    }\n    get hasHitRowLimit() {\n        return this.parserOptions.limitRows && this.rowCount >= this.parserOptions.maxRows;\n    }\n    get shouldEmitRows() {\n        return this.parsedRowCount > this.parserOptions.skipRows;\n    }\n    get shouldSkipLine() {\n        return this.parsedLineCount <= this.parserOptions.skipLines;\n    }\n    transform(transformFunction) {\n        this.rowTransformerValidator.rowTransform = transformFunction;\n        return this;\n    }\n    validate(validateFunction) {\n        this.rowTransformerValidator.rowValidator = validateFunction;\n        return this;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    emit(event, ...rest) {\n        if (event === 'end') {\n            if (!this.endEmitted) {\n                this.endEmitted = true;\n                super.emit('end', this.rowCount);\n            }\n            return false;\n        }\n        return super.emit(event, ...rest);\n    }\n    _transform(data, encoding, done) {\n        // if we have hit our maxRows parsing limit then skip parsing\n        if (this.hasHitRowLimit) {\n            return done();\n        }\n        const wrappedCallback = CsvParserStream.wrapDoneCallback(done);\n        try {\n            const { lines } = this;\n            const newLine = lines + this.decoder.write(data);\n            const rows = this.parse(newLine, true);\n            return this.processRows(rows, wrappedCallback);\n        }\n        catch (e) {\n            return wrappedCallback(e);\n        }\n    }\n    _flush(done) {\n        const wrappedCallback = CsvParserStream.wrapDoneCallback(done);\n        // if we have hit our maxRows parsing limit then skip parsing\n        if (this.hasHitRowLimit) {\n            return wrappedCallback();\n        }\n        try {\n            const newLine = this.lines + this.decoder.end();\n            const rows = this.parse(newLine, false);\n            return this.processRows(rows, wrappedCallback);\n        }\n        catch (e) {\n            return wrappedCallback(e);\n        }\n    }\n    parse(data, hasMoreData) {\n        if (!data) {\n            return [];\n        }\n        const { line, rows } = this.parser.parse(data, hasMoreData);\n        this.lines = line;\n        return rows;\n    }\n    processRows(rows, cb) {\n        const rowsLength = rows.length;\n        const iterate = (i) => {\n            const callNext = (err) => {\n                if (err) {\n                    return cb(err);\n                }\n                if (i % 100 === 0) {\n                    // incase the transform are sync insert a next tick to prevent stack overflow\n                    setImmediate(() => iterate(i + 1));\n                    return undefined;\n                }\n                return iterate(i + 1);\n            };\n            this.checkAndEmitHeaders();\n            // if we have emitted all rows or we have hit the maxRows limit option\n            // then end\n            if (i >= rowsLength || this.hasHitRowLimit) {\n                return cb();\n            }\n            this.parsedLineCount += 1;\n            if (this.shouldSkipLine) {\n                return callNext();\n            }\n            const row = rows[i];\n            this.rowCount += 1;\n            this.parsedRowCount += 1;\n            const nextRowCount = this.rowCount;\n            return this.transformRow(row, (err, transformResult) => {\n                if (err) {\n                    this.rowCount -= 1;\n                    return callNext(err);\n                }\n                if (!transformResult) {\n                    return callNext(new Error('expected transform result'));\n                }\n                if (!transformResult.isValid) {\n                    this.emit('data-invalid', transformResult.row, nextRowCount, transformResult.reason);\n                }\n                else if (transformResult.row) {\n                    return this.pushRow(transformResult.row, callNext);\n                }\n                return callNext();\n            });\n        };\n        iterate(0);\n    }\n    transformRow(parsedRow, cb) {\n        try {\n            this.headerTransformer.transform(parsedRow, (err, withHeaders) => {\n                if (err) {\n                    return cb(err);\n                }\n                if (!withHeaders) {\n                    return cb(new Error('Expected result from header transform'));\n                }\n                if (!withHeaders.isValid) {\n                    if (this.shouldEmitRows) {\n                        return cb(null, { isValid: false, row: parsedRow });\n                    }\n                    // skipped because of skipRows option remove from total row count\n                    return this.skipRow(cb);\n                }\n                if (withHeaders.row) {\n                    if (this.shouldEmitRows) {\n                        return this.rowTransformerValidator.transformAndValidate(withHeaders.row, cb);\n                    }\n                    // skipped because of skipRows option remove from total row count\n                    return this.skipRow(cb);\n                }\n                // this is a header row dont include in the rowCount or parsedRowCount\n                this.rowCount -= 1;\n                this.parsedRowCount -= 1;\n                return cb(null, { row: null, isValid: true });\n            });\n        }\n        catch (e) {\n            cb(e);\n        }\n    }\n    checkAndEmitHeaders() {\n        if (!this.headersEmitted && this.headerTransformer.headers) {\n            this.headersEmitted = true;\n            this.emit('headers', this.headerTransformer.headers);\n        }\n    }\n    skipRow(cb) {\n        // skipped because of skipRows option remove from total row count\n        this.rowCount -= 1;\n        return cb(null, { row: null, isValid: true });\n    }\n    pushRow(row, cb) {\n        try {\n            if (!this.parserOptions.objectMode) {\n                this.push(JSON.stringify(row));\n            }\n            else {\n                this.push(row);\n            }\n            cb();\n        }\n        catch (e) {\n            cb(e);\n        }\n    }\n    static wrapDoneCallback(done) {\n        let errorCalled = false;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return (err, ...args) => {\n            if (err) {\n                if (errorCalled) {\n                    throw err;\n                }\n                errorCalled = true;\n                done(err);\n                return;\n            }\n            done(...args);\n        };\n    }\n}\nexports.CsvParserStream = CsvParserStream;\n//# sourceMappingURL=CsvParserStream.js.map"]},"metadata":{},"sourceType":"script"}