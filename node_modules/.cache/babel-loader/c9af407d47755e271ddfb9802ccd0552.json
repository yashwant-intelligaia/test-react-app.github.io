{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.QuotedColumnParser = void 0;\n\nconst ColumnFormatter_1 = require(\"./ColumnFormatter\");\n\nconst Token_1 = require(\"../Token\");\n\nclass QuotedColumnParser {\n  constructor(parserOptions) {\n    this.parserOptions = parserOptions;\n    this.columnFormatter = new ColumnFormatter_1.ColumnFormatter(parserOptions);\n  }\n\n  parse(scanner) {\n    if (!scanner.hasMoreCharacters) {\n      return null;\n    }\n\n    const originalCursor = scanner.cursor;\n    const {\n      foundClosingQuote,\n      col\n    } = this.gatherDataBetweenQuotes(scanner);\n\n    if (!foundClosingQuote) {\n      // reset the cursor to the original\n      scanner.advanceTo(originalCursor); // if we didnt find a closing quote but we potentially have more data then skip the parsing\n      // and return the original scanner.\n\n      if (!scanner.hasMoreData) {\n        throw new Error(`Parse Error: missing closing: '${this.parserOptions.quote || ''}' in line: at '${scanner.lineFromCursor.replace(/[\\r\\n]/g, \"\\\\n'\")}'`);\n      }\n\n      return null;\n    }\n\n    this.checkForMalformedColumn(scanner);\n    return col;\n  }\n\n  gatherDataBetweenQuotes(scanner) {\n    const {\n      parserOptions\n    } = this;\n    let foundStartingQuote = false;\n    let foundClosingQuote = false;\n    const characters = [];\n    let nextToken = scanner.nextCharacterToken;\n\n    for (; !foundClosingQuote && nextToken !== null; nextToken = scanner.nextCharacterToken) {\n      const isQuote = Token_1.Token.isTokenQuote(nextToken, parserOptions); // ignore first quote\n\n      if (!foundStartingQuote && isQuote) {\n        foundStartingQuote = true;\n      } else if (foundStartingQuote) {\n        if (Token_1.Token.isTokenEscapeCharacter(nextToken, parserOptions)) {\n          // advance past the escape character so we can get the next one in line\n          scanner.advancePastToken(nextToken);\n          const tokenFollowingEscape = scanner.nextCharacterToken; // if the character following the escape is a quote character then just add\n          // the quote and advance to that character\n\n          if (tokenFollowingEscape !== null && (Token_1.Token.isTokenQuote(tokenFollowingEscape, parserOptions) || Token_1.Token.isTokenEscapeCharacter(tokenFollowingEscape, parserOptions))) {\n            characters.push(tokenFollowingEscape.token);\n            nextToken = tokenFollowingEscape;\n          } else if (isQuote) {\n            // if the escape is also a quote then we found our closing quote and finish early\n            foundClosingQuote = true;\n          } else {\n            // other wise add the escape token to the characters since it wast escaping anything\n            characters.push(nextToken.token);\n          }\n        } else if (isQuote) {\n          // we found our closing quote!\n          foundClosingQuote = true;\n        } else {\n          // add the token to the characters\n          characters.push(nextToken.token);\n        }\n      }\n\n      scanner.advancePastToken(nextToken);\n    }\n\n    return {\n      col: this.columnFormatter.format(characters.join('')),\n      foundClosingQuote\n    };\n  }\n\n  checkForMalformedColumn(scanner) {\n    const {\n      parserOptions\n    } = this;\n    const {\n      nextNonSpaceToken\n    } = scanner;\n\n    if (nextNonSpaceToken) {\n      const isNextTokenADelimiter = Token_1.Token.isTokenDelimiter(nextNonSpaceToken, parserOptions);\n      const isNextTokenARowDelimiter = Token_1.Token.isTokenRowDelimiter(nextNonSpaceToken);\n\n      if (!(isNextTokenADelimiter || isNextTokenARowDelimiter)) {\n        // if the final quote was NOT followed by a column (,) or row(\\n) delimiter then its a bad column\n        // tldr: only part of the column was quoted\n        const linePreview = scanner.lineFromCursor.substr(0, 10).replace(/[\\r\\n]/g, \"\\\\n'\");\n        throw new Error(`Parse Error: expected: '${parserOptions.escapedDelimiter}' OR new line got: '${nextNonSpaceToken.token}'. at '${linePreview}`);\n      }\n\n      scanner.advanceToToken(nextNonSpaceToken);\n    } else if (!scanner.hasMoreData) {\n      scanner.advancePastLine();\n    }\n  }\n\n}\n\nexports.QuotedColumnParser = QuotedColumnParser;","map":{"version":3,"sources":["../../../../src/parser/column/QuotedColumnParser.ts"],"names":[],"mappings":";;;;;;;AAAA,MAAA,iBAAA,GAAA,OAAA,CAAA,mBAAA,CAAA;;AAGA,MAAA,OAAA,GAAA,OAAA,CAAA,UAAA,CAAA;;AAOA,MAAa,kBAAb,CAA+B;AAK3B,EAAA,WAAA,CAAmB,aAAnB,EAA+C;AAC3C,SAAK,aAAL,GAAqB,aAArB;AACA,SAAK,eAAL,GAAuB,IAAI,iBAAA,CAAA,eAAJ,CAAoB,aAApB,CAAvB;AACH;;AAEM,EAAA,KAAK,CAAC,OAAD,EAAiB;AACzB,QAAI,CAAC,OAAO,CAAC,iBAAb,EAAgC;AAC5B,aAAO,IAAP;AACH;;AACD,UAAM,cAAc,GAAG,OAAO,CAAC,MAA/B;AACA,UAAM;AAAE,MAAA,iBAAF;AAAqB,MAAA;AAArB,QAA6B,KAAK,uBAAL,CAA6B,OAA7B,CAAnC;;AACA,QAAI,CAAC,iBAAL,EAAwB;AACpB;AACA,MAAA,OAAO,CAAC,SAAR,CAAkB,cAAlB,EAFoB,CAGpB;AACA;;AACA,UAAI,CAAC,OAAO,CAAC,WAAb,EAA0B;AACtB,cAAM,IAAI,KAAJ,CACF,kCACI,KAAK,aAAL,CAAmB,KAAnB,IAA4B,EAChC,kBAAkB,OAAO,CAAC,cAAR,CAAuB,OAAvB,CAA+B,SAA/B,EAA0C,MAA1C,CAAiD,GAHjE,CAAN;AAKH;;AACD,aAAO,IAAP;AACH;;AACD,SAAK,uBAAL,CAA6B,OAA7B;AACA,WAAO,GAAP;AACH;;AAEO,EAAA,uBAAuB,CAAC,OAAD,EAAiB;AAC5C,UAAM;AAAE,MAAA;AAAF,QAAoB,IAA1B;AACA,QAAI,kBAAkB,GAAG,KAAzB;AACA,QAAI,iBAAiB,GAAG,KAAxB;AACA,UAAM,UAAU,GAAG,EAAnB;AACA,QAAI,SAAS,GAAiB,OAAO,CAAC,kBAAtC;;AACA,WAAO,CAAC,iBAAD,IAAsB,SAAS,KAAK,IAA3C,EAAiD,SAAS,GAAG,OAAO,CAAC,kBAArE,EAAyF;AACrF,YAAM,OAAO,GAAG,OAAA,CAAA,KAAA,CAAM,YAAN,CAAmB,SAAnB,EAA8B,aAA9B,CAAhB,CADqF,CAErF;;AACA,UAAI,CAAC,kBAAD,IAAuB,OAA3B,EAAoC;AAChC,QAAA,kBAAkB,GAAG,IAArB;AACH,OAFD,MAEO,IAAI,kBAAJ,EAAwB;AAC3B,YAAI,OAAA,CAAA,KAAA,CAAM,sBAAN,CAA6B,SAA7B,EAAwC,aAAxC,CAAJ,EAA4D;AACxD;AACA,UAAA,OAAO,CAAC,gBAAR,CAAyB,SAAzB;AACA,gBAAM,oBAAoB,GAAG,OAAO,CAAC,kBAArC,CAHwD,CAIxD;AACA;;AACA,cACI,oBAAoB,KAAK,IAAzB,KACC,OAAA,CAAA,KAAA,CAAM,YAAN,CAAmB,oBAAnB,EAAyC,aAAzC,KACG,OAAA,CAAA,KAAA,CAAM,sBAAN,CAA6B,oBAA7B,EAAmD,aAAnD,CAFJ,CADJ,EAIE;AACE,YAAA,UAAU,CAAC,IAAX,CAAgB,oBAAoB,CAAC,KAArC;AACA,YAAA,SAAS,GAAG,oBAAZ;AACH,WAPD,MAOO,IAAI,OAAJ,EAAa;AAChB;AACA,YAAA,iBAAiB,GAAG,IAApB;AACH,WAHM,MAGA;AACH;AACA,YAAA,UAAU,CAAC,IAAX,CAAgB,SAAS,CAAC,KAA1B;AACH;AACJ,SApBD,MAoBO,IAAI,OAAJ,EAAa;AAChB;AACA,UAAA,iBAAiB,GAAG,IAApB;AACH,SAHM,MAGA;AACH;AACA,UAAA,UAAU,CAAC,IAAX,CAAgB,SAAS,CAAC,KAA1B;AACH;AACJ;;AACD,MAAA,OAAO,CAAC,gBAAR,CAAyB,SAAzB;AACH;;AACD,WAAO;AAAE,MAAA,GAAG,EAAE,KAAK,eAAL,CAAqB,MAArB,CAA4B,UAAU,CAAC,IAAX,CAAgB,EAAhB,CAA5B,CAAP;AAAyD,MAAA;AAAzD,KAAP;AACH;;AAEO,EAAA,uBAAuB,CAAC,OAAD,EAAiB;AAC5C,UAAM;AAAE,MAAA;AAAF,QAAoB,IAA1B;AACA,UAAM;AAAE,MAAA;AAAF,QAAwB,OAA9B;;AACA,QAAI,iBAAJ,EAAuB;AACnB,YAAM,qBAAqB,GAAG,OAAA,CAAA,KAAA,CAAM,gBAAN,CAAuB,iBAAvB,EAA0C,aAA1C,CAA9B;AACA,YAAM,wBAAwB,GAAG,OAAA,CAAA,KAAA,CAAM,mBAAN,CAA0B,iBAA1B,CAAjC;;AACA,UAAI,EAAE,qBAAqB,IAAI,wBAA3B,CAAJ,EAA0D;AACtD;AACA;AACA,cAAM,WAAW,GAAG,OAAO,CAAC,cAAR,CAAuB,MAAvB,CAA8B,CAA9B,EAAiC,EAAjC,EAAqC,OAArC,CAA6C,SAA7C,EAAwD,MAAxD,CAApB;AACA,cAAM,IAAI,KAAJ,CACF,2BAA2B,aAAa,CAAC,gBAAgB,uBAAuB,iBAAiB,CAAC,KAAK,UAAU,WAAW,EAD1H,CAAN;AAGH;;AACD,MAAA,OAAO,CAAC,cAAR,CAAuB,iBAAvB;AACH,KAZD,MAYO,IAAI,CAAC,OAAO,CAAC,WAAb,EAA0B;AAC7B,MAAA,OAAO,CAAC,eAAR;AACH;AACJ;;AAjG0B;;AAA/B,OAAA,CAAA,kBAAA,GAAA,kBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.QuotedColumnParser = void 0;\nconst ColumnFormatter_1 = require(\"./ColumnFormatter\");\nconst Token_1 = require(\"../Token\");\nclass QuotedColumnParser {\n    constructor(parserOptions) {\n        this.parserOptions = parserOptions;\n        this.columnFormatter = new ColumnFormatter_1.ColumnFormatter(parserOptions);\n    }\n    parse(scanner) {\n        if (!scanner.hasMoreCharacters) {\n            return null;\n        }\n        const originalCursor = scanner.cursor;\n        const { foundClosingQuote, col } = this.gatherDataBetweenQuotes(scanner);\n        if (!foundClosingQuote) {\n            // reset the cursor to the original\n            scanner.advanceTo(originalCursor);\n            // if we didnt find a closing quote but we potentially have more data then skip the parsing\n            // and return the original scanner.\n            if (!scanner.hasMoreData) {\n                throw new Error(`Parse Error: missing closing: '${this.parserOptions.quote || ''}' in line: at '${scanner.lineFromCursor.replace(/[\\r\\n]/g, \"\\\\n'\")}'`);\n            }\n            return null;\n        }\n        this.checkForMalformedColumn(scanner);\n        return col;\n    }\n    gatherDataBetweenQuotes(scanner) {\n        const { parserOptions } = this;\n        let foundStartingQuote = false;\n        let foundClosingQuote = false;\n        const characters = [];\n        let nextToken = scanner.nextCharacterToken;\n        for (; !foundClosingQuote && nextToken !== null; nextToken = scanner.nextCharacterToken) {\n            const isQuote = Token_1.Token.isTokenQuote(nextToken, parserOptions);\n            // ignore first quote\n            if (!foundStartingQuote && isQuote) {\n                foundStartingQuote = true;\n            }\n            else if (foundStartingQuote) {\n                if (Token_1.Token.isTokenEscapeCharacter(nextToken, parserOptions)) {\n                    // advance past the escape character so we can get the next one in line\n                    scanner.advancePastToken(nextToken);\n                    const tokenFollowingEscape = scanner.nextCharacterToken;\n                    // if the character following the escape is a quote character then just add\n                    // the quote and advance to that character\n                    if (tokenFollowingEscape !== null &&\n                        (Token_1.Token.isTokenQuote(tokenFollowingEscape, parserOptions) ||\n                            Token_1.Token.isTokenEscapeCharacter(tokenFollowingEscape, parserOptions))) {\n                        characters.push(tokenFollowingEscape.token);\n                        nextToken = tokenFollowingEscape;\n                    }\n                    else if (isQuote) {\n                        // if the escape is also a quote then we found our closing quote and finish early\n                        foundClosingQuote = true;\n                    }\n                    else {\n                        // other wise add the escape token to the characters since it wast escaping anything\n                        characters.push(nextToken.token);\n                    }\n                }\n                else if (isQuote) {\n                    // we found our closing quote!\n                    foundClosingQuote = true;\n                }\n                else {\n                    // add the token to the characters\n                    characters.push(nextToken.token);\n                }\n            }\n            scanner.advancePastToken(nextToken);\n        }\n        return { col: this.columnFormatter.format(characters.join('')), foundClosingQuote };\n    }\n    checkForMalformedColumn(scanner) {\n        const { parserOptions } = this;\n        const { nextNonSpaceToken } = scanner;\n        if (nextNonSpaceToken) {\n            const isNextTokenADelimiter = Token_1.Token.isTokenDelimiter(nextNonSpaceToken, parserOptions);\n            const isNextTokenARowDelimiter = Token_1.Token.isTokenRowDelimiter(nextNonSpaceToken);\n            if (!(isNextTokenADelimiter || isNextTokenARowDelimiter)) {\n                // if the final quote was NOT followed by a column (,) or row(\\n) delimiter then its a bad column\n                // tldr: only part of the column was quoted\n                const linePreview = scanner.lineFromCursor.substr(0, 10).replace(/[\\r\\n]/g, \"\\\\n'\");\n                throw new Error(`Parse Error: expected: '${parserOptions.escapedDelimiter}' OR new line got: '${nextNonSpaceToken.token}'. at '${linePreview}`);\n            }\n            scanner.advanceToToken(nextNonSpaceToken);\n        }\n        else if (!scanner.hasMoreData) {\n            scanner.advancePastLine();\n        }\n    }\n}\nexports.QuotedColumnParser = QuotedColumnParser;\n//# sourceMappingURL=QuotedColumnParser.js.map"]},"metadata":{},"sourceType":"script"}