{"ast":null,"code":"'use strict';\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nvar _ = require('../utils/under-dash');\n\nvar Enums = require('./enums');\n\nvar colCache = require('../utils/col-cache');\n\nvar Cell = require('./cell');\n\nvar Row = /*#__PURE__*/function () {\n  function Row(worksheet, number) {\n    _classCallCheck(this, Row);\n\n    this._worksheet = worksheet;\n    this._number = number;\n    this._cells = [];\n    this.style = {};\n    this.outlineLevel = 0;\n  } // return the row number\n\n\n  _createClass(Row, [{\n    key: \"commit\",\n    // Inform Streaming Writer that this row (and all rows before it) are complete\n    // and ready to write. Has no effect on Worksheet document\n    value: function commit() {\n      this._worksheet._commitRow(this); // eslint-disable-line no-underscore-dangle\n\n    } // helps GC by breaking cyclic references\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      delete this._worksheet;\n      delete this._cells;\n      delete this.style;\n    }\n  }, {\n    key: \"findCell\",\n    value: function findCell(colNumber) {\n      return this._cells[colNumber - 1];\n    } // given {address, row, col}, find or create new cell\n\n  }, {\n    key: \"getCellEx\",\n    value: function getCellEx(address) {\n      var cell = this._cells[address.col - 1];\n\n      if (!cell) {\n        var column = this._worksheet.getColumn(address.col);\n\n        cell = new Cell(this, column, address.address);\n        this._cells[address.col - 1] = cell;\n      }\n\n      return cell;\n    } // get cell by key, letter or column number\n\n  }, {\n    key: \"getCell\",\n    value: function getCell(col) {\n      if (typeof col === 'string') {\n        // is it a key?\n        var column = this._worksheet.getColumnKey(col);\n\n        if (column) {\n          col = column.number;\n        } else {\n          col = colCache.l2n(col);\n        }\n      }\n\n      return this._cells[col - 1] || this.getCellEx({\n        address: colCache.encodeAddress(this._number, col),\n        row: this._number,\n        col: col\n      });\n    } // remove cell(s) and shift all higher cells down by count\n\n  }, {\n    key: \"splice\",\n    value: function splice(start, count) {\n      var nKeep = start + count;\n\n      for (var _len = arguments.length, inserts = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n        inserts[_key - 2] = arguments[_key];\n      }\n\n      var nExpand = inserts.length - count;\n      var nEnd = this._cells.length;\n      var i;\n      var cSrc;\n      var cDst;\n\n      if (nExpand < 0) {\n        // remove cells\n        for (i = start + inserts.length; i <= nEnd; i++) {\n          cDst = this._cells[i - 1];\n          cSrc = this._cells[i - nExpand - 1];\n\n          if (cSrc) {\n            cDst = this.getCell(i);\n            cDst.value = cSrc.value;\n            cDst.style = cSrc.style; // eslint-disable-next-line no-underscore-dangle\n\n            cDst._comment = cSrc._comment;\n          } else if (cDst) {\n            cDst.value = null;\n            cDst.style = {}; // eslint-disable-next-line no-underscore-dangle\n\n            cDst._comment = undefined;\n          }\n        }\n      } else if (nExpand > 0) {\n        // insert new cells\n        for (i = nEnd; i >= nKeep; i--) {\n          cSrc = this._cells[i - 1];\n\n          if (cSrc) {\n            cDst = this.getCell(i + nExpand);\n            cDst.value = cSrc.value;\n            cDst.style = cSrc.style; // eslint-disable-next-line no-underscore-dangle\n\n            cDst._comment = cSrc._comment;\n          } else {\n            this._cells[i + nExpand - 1] = undefined;\n          }\n        }\n      } // now add the new values\n\n\n      for (i = 0; i < inserts.length; i++) {\n        cDst = this.getCell(start + i);\n        cDst.value = inserts[i];\n        cDst.style = {}; // eslint-disable-next-line no-underscore-dangle\n\n        cDst._comment = undefined;\n      }\n    } // Iterate over all non-null cells in this row\n\n  }, {\n    key: \"eachCell\",\n    value: function eachCell(options, iteratee) {\n      if (!iteratee) {\n        iteratee = options;\n        options = null;\n      }\n\n      if (options && options.includeEmpty) {\n        var n = this._cells.length;\n\n        for (var i = 1; i <= n; i++) {\n          iteratee(this.getCell(i), i);\n        }\n      } else {\n        this._cells.forEach(function (cell, index) {\n          if (cell && cell.type !== Enums.ValueType.Null) {\n            iteratee(cell, index + 1);\n          }\n        });\n      }\n    } // ===========================================================================\n    // Page Breaks\n\n  }, {\n    key: \"addPageBreak\",\n    value: function addPageBreak(lft, rght) {\n      var ws = this._worksheet;\n      var left = Math.max(0, lft - 1) || 0;\n      var right = Math.max(0, rght - 1) || 16838;\n      var pb = {\n        id: this._number,\n        max: right,\n        man: 1\n      };\n      if (left) pb.min = left;\n      ws.rowBreaks.push(pb);\n    } // return a sparse array of cell values\n\n  }, {\n    key: \"_applyStyle\",\n    // =========================================================================\n    // styles\n    value: function _applyStyle(name, value) {\n      this.style[name] = value;\n\n      this._cells.forEach(function (cell) {\n        if (cell) {\n          cell[name] = value;\n        }\n      });\n\n      return value;\n    }\n  }, {\n    key: \"number\",\n    get: function get() {\n      return this._number;\n    }\n  }, {\n    key: \"worksheet\",\n    get: function get() {\n      return this._worksheet;\n    }\n  }, {\n    key: \"values\",\n    get: function get() {\n      var values = [];\n\n      this._cells.forEach(function (cell) {\n        if (cell && cell.type !== Enums.ValueType.Null) {\n          values[cell.col] = cell.value;\n        }\n      });\n\n      return values;\n    } // set the values by contiguous or sparse array, or by key'd object literal\n    ,\n    set: function set(value) {\n      var _this = this; // this operation is not additive - any prior cells are removed\n\n\n      this._cells = [];\n\n      if (!value) {// empty row\n      } else if (value instanceof Array) {\n        var offset = 0;\n\n        if (value.hasOwnProperty('0')) {\n          // contiguous array - start at column 1\n          offset = 1;\n        }\n\n        value.forEach(function (item, index) {\n          if (item !== undefined) {\n            _this.getCellEx({\n              address: colCache.encodeAddress(_this._number, index + offset),\n              row: _this._number,\n              col: index + offset\n            }).value = item;\n          }\n        });\n      } else {\n        // assume object with column keys\n        this._worksheet.eachColumnKey(function (column, key) {\n          if (value[key] !== undefined) {\n            _this.getCellEx({\n              address: colCache.encodeAddress(_this._number, column.number),\n              row: _this._number,\n              col: column.number\n            }).value = value[key];\n          }\n        });\n      }\n    } // returns true if the row includes at least one cell with a value\n\n  }, {\n    key: \"hasValues\",\n    get: function get() {\n      return _.some(this._cells, function (cell) {\n        return cell && cell.type !== Enums.ValueType.Null;\n      });\n    }\n  }, {\n    key: \"cellCount\",\n    get: function get() {\n      return this._cells.length;\n    }\n  }, {\n    key: \"actualCellCount\",\n    get: function get() {\n      var count = 0;\n      this.eachCell(function () {\n        count++;\n      });\n      return count;\n    } // get the min and max column number for the non-null cells in this row or null\n\n  }, {\n    key: \"dimensions\",\n    get: function get() {\n      var min = 0;\n      var max = 0;\n\n      this._cells.forEach(function (cell) {\n        if (cell && cell.type !== Enums.ValueType.Null) {\n          if (!min || min > cell.col) {\n            min = cell.col;\n          }\n\n          if (max < cell.col) {\n            max = cell.col;\n          }\n        }\n      });\n\n      return min > 0 ? {\n        min: min,\n        max: max\n      } : null;\n    }\n  }, {\n    key: \"numFmt\",\n    get: function get() {\n      return this.style.numFmt;\n    },\n    set: function set(value) {\n      this._applyStyle('numFmt', value);\n    }\n  }, {\n    key: \"font\",\n    get: function get() {\n      return this.style.font;\n    },\n    set: function set(value) {\n      this._applyStyle('font', value);\n    }\n  }, {\n    key: \"alignment\",\n    get: function get() {\n      return this.style.alignment;\n    },\n    set: function set(value) {\n      this._applyStyle('alignment', value);\n    }\n  }, {\n    key: \"protection\",\n    get: function get() {\n      return this.style.protection;\n    },\n    set: function set(value) {\n      this._applyStyle('protection', value);\n    }\n  }, {\n    key: \"border\",\n    get: function get() {\n      return this.style.border;\n    },\n    set: function set(value) {\n      this._applyStyle('border', value);\n    }\n  }, {\n    key: \"fill\",\n    get: function get() {\n      return this.style.fill;\n    },\n    set: function set(value) {\n      this._applyStyle('fill', value);\n    }\n  }, {\n    key: \"hidden\",\n    get: function get() {\n      return !!this._hidden;\n    },\n    set: function set(value) {\n      this._hidden = value;\n    }\n  }, {\n    key: \"outlineLevel\",\n    get: function get() {\n      return this._outlineLevel || 0;\n    },\n    set: function set(value) {\n      this._outlineLevel = value;\n    }\n  }, {\n    key: \"collapsed\",\n    get: function get() {\n      return !!(this._outlineLevel && this._outlineLevel >= this._worksheet.properties.outlineLevelRow);\n    } // =========================================================================\n\n  }, {\n    key: \"model\",\n    get: function get() {\n      var cells = [];\n      var min = 0;\n      var max = 0;\n\n      this._cells.forEach(function (cell) {\n        if (cell) {\n          var cellModel = cell.model;\n\n          if (cellModel) {\n            if (!min || min > cell.col) {\n              min = cell.col;\n            }\n\n            if (max < cell.col) {\n              max = cell.col;\n            }\n\n            cells.push(cellModel);\n          }\n        }\n      });\n\n      return this.height || cells.length ? {\n        cells: cells,\n        number: this.number,\n        min: min,\n        max: max,\n        height: this.height,\n        style: this.style,\n        hidden: this.hidden,\n        outlineLevel: this.outlineLevel,\n        collapsed: this.collapsed\n      } : null;\n    },\n    set: function set(value) {\n      var _this2 = this;\n\n      if (value.number !== this._number) {\n        throw new Error('Invalid row number in model');\n      }\n\n      this._cells = [];\n      var previousAddress;\n      value.cells.forEach(function (cellModel) {\n        switch (cellModel.type) {\n          case Cell.Types.Merge:\n            // special case - don't add this types\n            break;\n\n          default:\n            {\n              var address;\n\n              if (cellModel.address) {\n                address = colCache.decodeAddress(cellModel.address);\n              } else if (previousAddress) {\n                // This is a <c> element without an r attribute\n                // Assume that it's the cell for the next column\n                var _previousAddress = previousAddress,\n                    row = _previousAddress.row;\n                var col = previousAddress.col + 1;\n                address = {\n                  row: row,\n                  col: col,\n                  address: colCache.encodeAddress(row, col),\n                  $col$row: \"$\".concat(colCache.n2l(col), \"$\").concat(row)\n                };\n              }\n\n              previousAddress = address;\n\n              var cell = _this2.getCellEx(address);\n\n              cell.model = cellModel;\n              break;\n            }\n        }\n      });\n\n      if (value.height) {\n        this.height = value.height;\n      } else {\n        delete this.height;\n      }\n\n      this.hidden = value.hidden;\n      this.outlineLevel = value.outlineLevel || 0;\n      this.style = value.style && JSON.parse(JSON.stringify(value.style)) || {};\n    }\n  }]);\n\n  return Row;\n}();\n\nmodule.exports = Row;","map":{"version":3,"sources":["../../../lib/doc/row.js"],"names":["_","require","Enums","colCache","Cell","Row","colNumber","address","cell","column","col","row","start","count","inserts","nKeep","nExpand","nEnd","i","cDst","cSrc","options","iteratee","n","index","lft","rght","ws","left","Math","right","pb","id","max","man","values","value","offset","item","number","min","name","cells","cellModel","height","style","hidden","outlineLevel","collapsed","previousAddress","$col$row","JSON","module"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nconst _ = require('../utils/under-dash');\r\n\r\nconst Enums = require('./enums');\r\nconst colCache = require('../utils/col-cache');\r\nconst Cell = require('./cell');\r\n\r\nclass Row {\r\n  constructor(worksheet, number) {\r\n    this._worksheet = worksheet;\r\n    this._number = number;\r\n    this._cells = [];\r\n    this.style = {};\r\n    this.outlineLevel = 0;\r\n  }\r\n\r\n  // return the row number\r\n  get number() {\r\n    return this._number;\r\n  }\r\n\r\n  get worksheet() {\r\n    return this._worksheet;\r\n  }\r\n\r\n  // Inform Streaming Writer that this row (and all rows before it) are complete\r\n  // and ready to write. Has no effect on Worksheet document\r\n  commit() {\r\n    this._worksheet._commitRow(this); // eslint-disable-line no-underscore-dangle\r\n  }\r\n\r\n  // helps GC by breaking cyclic references\r\n  destroy() {\r\n    delete this._worksheet;\r\n    delete this._cells;\r\n    delete this.style;\r\n  }\r\n\r\n  findCell(colNumber) {\r\n    return this._cells[colNumber - 1];\r\n  }\r\n\r\n  // given {address, row, col}, find or create new cell\r\n  getCellEx(address) {\r\n    let cell = this._cells[address.col - 1];\r\n    if (!cell) {\r\n      const column = this._worksheet.getColumn(address.col);\r\n      cell = new Cell(this, column, address.address);\r\n      this._cells[address.col - 1] = cell;\r\n    }\r\n    return cell;\r\n  }\r\n\r\n  // get cell by key, letter or column number\r\n  getCell(col) {\r\n    if (typeof col === 'string') {\r\n      // is it a key?\r\n      const column = this._worksheet.getColumnKey(col);\r\n      if (column) {\r\n        col = column.number;\r\n      } else {\r\n        col = colCache.l2n(col);\r\n      }\r\n    }\r\n    return (\r\n      this._cells[col - 1] ||\r\n      this.getCellEx({\r\n        address: colCache.encodeAddress(this._number, col),\r\n        row: this._number,\r\n        col,\r\n      })\r\n    );\r\n  }\r\n\r\n  // remove cell(s) and shift all higher cells down by count\r\n  splice(start, count, ...inserts) {\r\n    const nKeep = start + count;\r\n    const nExpand = inserts.length - count;\r\n    const nEnd = this._cells.length;\r\n    let i;\r\n    let cSrc;\r\n    let cDst;\r\n\r\n    if (nExpand < 0) {\r\n      // remove cells\r\n      for (i = start + inserts.length; i <= nEnd; i++) {\r\n        cDst = this._cells[i - 1];\r\n        cSrc = this._cells[i - nExpand - 1];\r\n        if (cSrc) {\r\n          cDst = this.getCell(i);\r\n          cDst.value = cSrc.value;\r\n          cDst.style = cSrc.style;\r\n          // eslint-disable-next-line no-underscore-dangle\r\n          cDst._comment = cSrc._comment;\r\n        } else if (cDst) {\r\n          cDst.value = null;\r\n          cDst.style = {};\r\n          // eslint-disable-next-line no-underscore-dangle\r\n          cDst._comment = undefined;\r\n        }\r\n      }\r\n    } else if (nExpand > 0) {\r\n      // insert new cells\r\n      for (i = nEnd; i >= nKeep; i--) {\r\n        cSrc = this._cells[i - 1];\r\n        if (cSrc) {\r\n          cDst = this.getCell(i + nExpand);\r\n          cDst.value = cSrc.value;\r\n          cDst.style = cSrc.style;\r\n          // eslint-disable-next-line no-underscore-dangle\r\n          cDst._comment = cSrc._comment;\r\n        } else {\r\n          this._cells[i + nExpand - 1] = undefined;\r\n        }\r\n      }\r\n    }\r\n\r\n    // now add the new values\r\n    for (i = 0; i < inserts.length; i++) {\r\n      cDst = this.getCell(start + i);\r\n      cDst.value = inserts[i];\r\n      cDst.style = {};\r\n      // eslint-disable-next-line no-underscore-dangle\r\n      cDst._comment = undefined;\r\n    }\r\n  }\r\n\r\n  // Iterate over all non-null cells in this row\r\n  eachCell(options, iteratee) {\r\n    if (!iteratee) {\r\n      iteratee = options;\r\n      options = null;\r\n    }\r\n    if (options && options.includeEmpty) {\r\n      const n = this._cells.length;\r\n      for (let i = 1; i <= n; i++) {\r\n        iteratee(this.getCell(i), i);\r\n      }\r\n    } else {\r\n      this._cells.forEach((cell, index) => {\r\n        if (cell && cell.type !== Enums.ValueType.Null) {\r\n          iteratee(cell, index + 1);\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  // ===========================================================================\r\n  // Page Breaks\r\n  addPageBreak(lft, rght) {\r\n    const ws = this._worksheet;\r\n    const left = Math.max(0, lft - 1) || 0;\r\n    const right = Math.max(0, rght - 1) || 16838;\r\n    const pb = {\r\n      id: this._number,\r\n      max: right,\r\n      man: 1,\r\n    };\r\n    if (left) pb.min = left;\r\n\r\n    ws.rowBreaks.push(pb);\r\n  }\r\n\r\n  // return a sparse array of cell values\r\n  get values() {\r\n    const values = [];\r\n    this._cells.forEach(cell => {\r\n      if (cell && cell.type !== Enums.ValueType.Null) {\r\n        values[cell.col] = cell.value;\r\n      }\r\n    });\r\n    return values;\r\n  }\r\n\r\n  // set the values by contiguous or sparse array, or by key'd object literal\r\n  set values(value) {\r\n    // this operation is not additive - any prior cells are removed\r\n    this._cells = [];\r\n    if (!value) {\r\n      // empty row\r\n    } else if (value instanceof Array) {\r\n      let offset = 0;\r\n      if (value.hasOwnProperty('0')) {\r\n        // contiguous array - start at column 1\r\n        offset = 1;\r\n      }\r\n      value.forEach((item, index) => {\r\n        if (item !== undefined) {\r\n          this.getCellEx({\r\n            address: colCache.encodeAddress(this._number, index + offset),\r\n            row: this._number,\r\n            col: index + offset,\r\n          }).value = item;\r\n        }\r\n      });\r\n    } else {\r\n      // assume object with column keys\r\n      this._worksheet.eachColumnKey((column, key) => {\r\n        if (value[key] !== undefined) {\r\n          this.getCellEx({\r\n            address: colCache.encodeAddress(this._number, column.number),\r\n            row: this._number,\r\n            col: column.number,\r\n          }).value = value[key];\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  // returns true if the row includes at least one cell with a value\r\n  get hasValues() {\r\n    return _.some(this._cells, cell => cell && cell.type !== Enums.ValueType.Null);\r\n  }\r\n\r\n  get cellCount() {\r\n    return this._cells.length;\r\n  }\r\n\r\n  get actualCellCount() {\r\n    let count = 0;\r\n    this.eachCell(() => {\r\n      count++;\r\n    });\r\n    return count;\r\n  }\r\n\r\n  // get the min and max column number for the non-null cells in this row or null\r\n  get dimensions() {\r\n    let min = 0;\r\n    let max = 0;\r\n    this._cells.forEach(cell => {\r\n      if (cell && cell.type !== Enums.ValueType.Null) {\r\n        if (!min || min > cell.col) {\r\n          min = cell.col;\r\n        }\r\n        if (max < cell.col) {\r\n          max = cell.col;\r\n        }\r\n      }\r\n    });\r\n    return min > 0\r\n      ? {\r\n          min,\r\n          max,\r\n        }\r\n      : null;\r\n  }\r\n\r\n  // =========================================================================\r\n  // styles\r\n  _applyStyle(name, value) {\r\n    this.style[name] = value;\r\n    this._cells.forEach(cell => {\r\n      if (cell) {\r\n        cell[name] = value;\r\n      }\r\n    });\r\n    return value;\r\n  }\r\n\r\n  get numFmt() {\r\n    return this.style.numFmt;\r\n  }\r\n\r\n  set numFmt(value) {\r\n    this._applyStyle('numFmt', value);\r\n  }\r\n\r\n  get font() {\r\n    return this.style.font;\r\n  }\r\n\r\n  set font(value) {\r\n    this._applyStyle('font', value);\r\n  }\r\n\r\n  get alignment() {\r\n    return this.style.alignment;\r\n  }\r\n\r\n  set alignment(value) {\r\n    this._applyStyle('alignment', value);\r\n  }\r\n\r\n  get protection() {\r\n    return this.style.protection;\r\n  }\r\n\r\n  set protection(value) {\r\n    this._applyStyle('protection', value);\r\n  }\r\n\r\n  get border() {\r\n    return this.style.border;\r\n  }\r\n\r\n  set border(value) {\r\n    this._applyStyle('border', value);\r\n  }\r\n\r\n  get fill() {\r\n    return this.style.fill;\r\n  }\r\n\r\n  set fill(value) {\r\n    this._applyStyle('fill', value);\r\n  }\r\n\r\n  get hidden() {\r\n    return !!this._hidden;\r\n  }\r\n\r\n  set hidden(value) {\r\n    this._hidden = value;\r\n  }\r\n\r\n  get outlineLevel() {\r\n    return this._outlineLevel || 0;\r\n  }\r\n\r\n  set outlineLevel(value) {\r\n    this._outlineLevel = value;\r\n  }\r\n\r\n  get collapsed() {\r\n    return !!(\r\n      this._outlineLevel && this._outlineLevel >= this._worksheet.properties.outlineLevelRow\r\n    );\r\n  }\r\n\r\n  // =========================================================================\r\n  get model() {\r\n    const cells = [];\r\n    let min = 0;\r\n    let max = 0;\r\n    this._cells.forEach(cell => {\r\n      if (cell) {\r\n        const cellModel = cell.model;\r\n        if (cellModel) {\r\n          if (!min || min > cell.col) {\r\n            min = cell.col;\r\n          }\r\n          if (max < cell.col) {\r\n            max = cell.col;\r\n          }\r\n          cells.push(cellModel);\r\n        }\r\n      }\r\n    });\r\n\r\n    return this.height || cells.length\r\n      ? {\r\n          cells,\r\n          number: this.number,\r\n          min,\r\n          max,\r\n          height: this.height,\r\n          style: this.style,\r\n          hidden: this.hidden,\r\n          outlineLevel: this.outlineLevel,\r\n          collapsed: this.collapsed,\r\n        }\r\n      : null;\r\n  }\r\n\r\n  set model(value) {\r\n    if (value.number !== this._number) {\r\n      throw new Error('Invalid row number in model');\r\n    }\r\n    this._cells = [];\r\n    let previousAddress;\r\n    value.cells.forEach(cellModel => {\r\n      switch (cellModel.type) {\r\n        case Cell.Types.Merge:\r\n          // special case - don't add this types\r\n          break;\r\n        default: {\r\n          let address;\r\n          if (cellModel.address) {\r\n            address = colCache.decodeAddress(cellModel.address);\r\n          } else if (previousAddress) {\r\n            // This is a <c> element without an r attribute\r\n            // Assume that it's the cell for the next column\r\n            const {row} = previousAddress;\r\n            const col = previousAddress.col + 1;\r\n            address = {\r\n              row,\r\n              col,\r\n              address: colCache.encodeAddress(row, col),\r\n              $col$row: `$${colCache.n2l(col)}$${row}`,\r\n            };\r\n          }\r\n          previousAddress = address;\r\n          const cell = this.getCellEx(address);\r\n          cell.model = cellModel;\r\n          break;\r\n        }\r\n      }\r\n    });\r\n\r\n    if (value.height) {\r\n      this.height = value.height;\r\n    } else {\r\n      delete this.height;\r\n    }\r\n\r\n    this.hidden = value.hidden;\r\n    this.outlineLevel = value.outlineLevel || 0;\r\n\r\n    this.style = (value.style && JSON.parse(JSON.stringify(value.style))) || {};\r\n  }\r\n}\r\n\r\nmodule.exports = Row;\r\n"]},"metadata":{},"sourceType":"script"}