{"ast":null,"code":"\"use strict\";\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nvar _ = require('./under-dash');\n\nvar colCache = require('./col-cache');\n\nvar CellMatrix = /*#__PURE__*/function () {\n  function CellMatrix(template) {\n    _classCallCheck(this, CellMatrix);\n\n    this.template = template;\n    this.sheets = {};\n  }\n\n  _createClass(CellMatrix, [{\n    key: \"addCell\",\n    value: function addCell(addressStr) {\n      this.addCellEx(colCache.decodeEx(addressStr));\n    }\n  }, {\n    key: \"getCell\",\n    value: function getCell(addressStr) {\n      return this.findCellEx(colCache.decodeEx(addressStr), true);\n    }\n  }, {\n    key: \"findCell\",\n    value: function findCell(addressStr) {\n      return this.findCellEx(colCache.decodeEx(addressStr), false);\n    }\n  }, {\n    key: \"findCellAt\",\n    value: function findCellAt(sheetName, rowNumber, colNumber) {\n      var sheet = this.sheets[sheetName];\n      var row = sheet && sheet[rowNumber];\n      return row && row[colNumber];\n    }\n  }, {\n    key: \"addCellEx\",\n    value: function addCellEx(address) {\n      if (address.top) {\n        for (var row = address.top; row <= address.bottom; row++) {\n          for (var col = address.left; col <= address.right; col++) {\n            this.getCellAt(address.sheetName, row, col);\n          }\n        }\n      } else {\n        this.findCellEx(address, true);\n      }\n    }\n  }, {\n    key: \"getCellEx\",\n    value: function getCellEx(address) {\n      return this.findCellEx(address, true);\n    }\n  }, {\n    key: \"findCellEx\",\n    value: function findCellEx(address, create) {\n      var sheet = this.findSheet(address, create);\n      var row = this.findSheetRow(sheet, address, create);\n      return this.findRowCell(row, address, create);\n    }\n  }, {\n    key: \"getCellAt\",\n    value: function getCellAt(sheetName, rowNumber, colNumber) {\n      var sheet = this.sheets[sheetName] || (this.sheets[sheetName] = []);\n      var row = sheet[rowNumber] || (sheet[rowNumber] = []);\n      var cell = row[colNumber] || (row[colNumber] = {\n        sheetName: sheetName,\n        address: colCache.n2l(colNumber) + rowNumber,\n        row: rowNumber,\n        col: colNumber\n      });\n      return cell;\n    }\n  }, {\n    key: \"removeCellEx\",\n    value: function removeCellEx(address) {\n      var sheet = this.findSheet(address);\n\n      if (!sheet) {\n        return;\n      }\n\n      var row = this.findSheetRow(sheet, address);\n\n      if (!row) {\n        return;\n      }\n\n      delete row[address.col];\n    }\n  }, {\n    key: \"forEachInSheet\",\n    value: function forEachInSheet(sheetName, callback) {\n      var sheet = this.sheets[sheetName];\n\n      if (sheet) {\n        sheet.forEach(function (row, rowNumber) {\n          if (row) {\n            row.forEach(function (cell, colNumber) {\n              if (cell) {\n                callback(cell, rowNumber, colNumber);\n              }\n            });\n          }\n        });\n      }\n    }\n  }, {\n    key: \"forEach\",\n    value: function forEach(callback) {\n      var _this = this;\n\n      _.each(this.sheets, function (sheet, sheetName) {\n        _this.forEachInSheet(sheetName, callback);\n      });\n    }\n  }, {\n    key: \"map\",\n    value: function map(callback) {\n      var results = [];\n      this.forEach(function (cell) {\n        results.push(callback(cell));\n      });\n      return results;\n    }\n  }, {\n    key: \"findSheet\",\n    value: function findSheet(address, create) {\n      var name = address.sheetName;\n\n      if (this.sheets[name]) {\n        return this.sheets[name];\n      }\n\n      if (create) {\n        return this.sheets[name] = [];\n      }\n\n      return undefined;\n    }\n  }, {\n    key: \"findSheetRow\",\n    value: function findSheetRow(sheet, address, create) {\n      var row = address.row;\n\n      if (sheet && sheet[row]) {\n        return sheet[row];\n      }\n\n      if (create) {\n        return sheet[row] = [];\n      }\n\n      return undefined;\n    }\n  }, {\n    key: \"findRowCell\",\n    value: function findRowCell(row, address, create) {\n      var col = address.col;\n\n      if (row && row[col]) {\n        return row[col];\n      }\n\n      if (create) {\n        return row[col] = this.template ? Object.assign(address, JSON.parse(JSON.stringify(this.template))) : address;\n      }\n\n      return undefined;\n    }\n  }, {\n    key: \"spliceRows\",\n    value: function spliceRows(sheetName, start, numDelete, numInsert) {\n      var sheet = this.sheets[sheetName];\n\n      if (sheet) {\n        var inserts = [];\n\n        for (var i = 0; i < numInsert; i++) {\n          inserts.push([]);\n        }\n\n        sheet.splice.apply(sheet, [start, numDelete].concat(inserts));\n      }\n    }\n  }, {\n    key: \"spliceColumns\",\n    value: function spliceColumns(sheetName, start, numDelete, numInsert) {\n      var sheet = this.sheets[sheetName];\n\n      if (sheet) {\n        var inserts = [];\n\n        for (var i = 0; i < numInsert; i++) {\n          inserts.push(null);\n        }\n\n        _.each(sheet, function (row) {\n          row.splice.apply(row, [start, numDelete].concat(inserts));\n        });\n      }\n    }\n  }]);\n\n  return CellMatrix;\n}();\n\nmodule.exports = CellMatrix;","map":{"version":3,"sources":["../../../lib/utils/cell-matrix.js"],"names":["_","require","colCache","CellMatrix","addressStr","sheetName","rowNumber","colNumber","sheet","row","address","col","create","cell","callback","results","name","Object","JSON","start","numDelete","numInsert","inserts","i","module"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAMA,CAAC,GAAGC,OAAO,CAAjB,cAAiB,CAAjB;;AACA,IAAMC,QAAQ,GAAGD,OAAO,CAAxB,aAAwB,CAAxB;;IAEME,U;AACJ,WAAA,UAAA,CAAA,QAAA,EAAsB;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,UAAA,CAAA;;AACpB,SAAA,QAAA,GAAA,QAAA;AACA,SAAA,MAAA,GAAA,EAAA;AACD;;;;4BAEOC,U,EAAY;AAClB,WAAA,SAAA,CAAeF,QAAQ,CAARA,QAAAA,CAAf,UAAeA,CAAf;AACD;;;4BAEOE,U,EAAY;AAClB,aAAO,KAAA,UAAA,CAAgBF,QAAQ,CAARA,QAAAA,CAAhB,UAAgBA,CAAhB,EAAP,IAAO,CAAP;AACD;;;6BAEQE,U,EAAY;AACnB,aAAO,KAAA,UAAA,CAAgBF,QAAQ,CAARA,QAAAA,CAAhB,UAAgBA,CAAhB,EAAP,KAAO,CAAP;AACD;;;+BAEUG,S,EAAWC,S,EAAWC,S,EAAW;AAC1C,UAAMC,KAAK,GAAG,KAAA,MAAA,CAAd,SAAc,CAAd;AACA,UAAMC,GAAG,GAAGD,KAAK,IAAIA,KAAK,CAA1B,SAA0B,CAA1B;AACA,aAAOC,GAAG,IAAIA,GAAG,CAAjB,SAAiB,CAAjB;AACD;;;8BAESC,O,EAAS;AACjB,UAAIA,OAAO,CAAX,GAAA,EAAiB;AACf,aAAK,IAAID,GAAG,GAAGC,OAAO,CAAtB,GAAA,EAA4BD,GAAG,IAAIC,OAAO,CAA1C,MAAA,EAAmDD,GAAnD,EAAA,EAA0D;AACxD,eAAK,IAAIE,GAAG,GAAGD,OAAO,CAAtB,IAAA,EAA6BC,GAAG,IAAID,OAAO,CAA3C,KAAA,EAAmDC,GAAnD,EAAA,EAA0D;AACxD,iBAAA,SAAA,CAAeD,OAAO,CAAtB,SAAA,EAAA,GAAA,EAAA,GAAA;AACD;AACF;AALH,OAAA,MAMO;AACL,aAAA,UAAA,CAAA,OAAA,EAAA,IAAA;AACD;AACF;;;8BAESA,O,EAAS;AACjB,aAAO,KAAA,UAAA,CAAA,OAAA,EAAP,IAAO,CAAP;AACD;;;+BAEUA,O,EAASE,M,EAAQ;AAC1B,UAAMJ,KAAK,GAAG,KAAA,SAAA,CAAA,OAAA,EAAd,MAAc,CAAd;AACA,UAAMC,GAAG,GAAG,KAAA,YAAA,CAAA,KAAA,EAAA,OAAA,EAAZ,MAAY,CAAZ;AACA,aAAO,KAAA,WAAA,CAAA,GAAA,EAAA,OAAA,EAAP,MAAO,CAAP;AACD;;;8BAESJ,S,EAAWC,S,EAAWC,S,EAAW;AACzC,UAAMC,KAAK,GAAG,KAAA,MAAA,CAAA,SAAA,MAA2B,KAAA,MAAA,CAAA,SAAA,IAAzC,EAAc,CAAd;AACA,UAAMC,GAAG,GAAGD,KAAK,CAALA,SAAK,CAALA,KAAqBA,KAAK,CAALA,SAAK,CAALA,GAAjC,EAAYA,CAAZ;AACA,UAAMK,IAAI,GACR,GAAG,CAAH,SAAG,CAAH,KACCJ,GAAG,CAAHA,SAAG,CAAHA,GAAiB;AAChBJ,QAAAA,SAAS,EADO,SAAA;AAEhBK,QAAAA,OAAO,EAAER,QAAQ,CAARA,GAAAA,CAAAA,SAAAA,IAFO,SAAA;AAGhBO,QAAAA,GAAG,EAHa,SAAA;AAIhBE,QAAAA,GAAG,EAAEJ;AAJW,OADlB,CADF;AAQA,aAAA,IAAA;AACD;;;iCAEYG,O,EAAS;AACpB,UAAMF,KAAK,GAAG,KAAA,SAAA,CAAd,OAAc,CAAd;;AACA,UAAI,CAAJ,KAAA,EAAY;AACV;AACD;;AACD,UAAMC,GAAG,GAAG,KAAA,YAAA,CAAA,KAAA,EAAZ,OAAY,CAAZ;;AACA,UAAI,CAAJ,GAAA,EAAU;AACR;AACD;;AACD,aAAOA,GAAG,CAACC,OAAO,CAAlB,GAAU,CAAV;AACD;;;mCAEcL,S,EAAWS,Q,EAAU;AAClC,UAAMN,KAAK,GAAG,KAAA,MAAA,CAAd,SAAc,CAAd;;AACA,UAAA,KAAA,EAAW;AACTA,QAAAA,KAAK,CAALA,OAAAA,CAAc,UAAA,GAAA,EAAA,SAAA,EAAoB;AAChC,cAAA,GAAA,EAAS;AACPC,YAAAA,GAAG,CAAHA,OAAAA,CAAY,UAAA,IAAA,EAAA,SAAA,EAAqB;AAC/B,kBAAA,IAAA,EAAU;AACRK,gBAAAA,QAAQ,CAAA,IAAA,EAAA,SAAA,EAARA,SAAQ,CAARA;AACD;AAHHL,aAAAA;AAKD;AAPHD,SAAAA;AASD;AACF;;;4BAEOM,Q,EAAU;AAAA,UAAA,KAAA,GAAA,IAAA;;AAChBd,MAAAA,CAAC,CAADA,IAAAA,CAAO,KAAPA,MAAAA,EAAoB,UAAA,KAAA,EAAA,SAAA,EAAsB;AACxC,QAAA,KAAI,CAAJ,cAAA,CAAA,SAAA,EAAA,QAAA;AADFA,OAAAA;AAGD;;;wBAEGc,Q,EAAU;AACZ,UAAMC,OAAO,GAAb,EAAA;AACA,WAAA,OAAA,CAAa,UAAA,IAAA,EAAQ;AACnBA,QAAAA,OAAO,CAAPA,IAAAA,CAAaD,QAAQ,CAArBC,IAAqB,CAArBA;AADF,OAAA;AAGA,aAAA,OAAA;AACD;;;8BAESL,O,EAASE,M,EAAQ;AACzB,UAAMI,IAAI,GAAGN,OAAO,CAApB,SAAA;;AACA,UAAI,KAAA,MAAA,CAAJ,IAAI,CAAJ,EAAuB;AACrB,eAAO,KAAA,MAAA,CAAP,IAAO,CAAP;AACD;;AACD,UAAA,MAAA,EAAY;AACV,eAAQ,KAAA,MAAA,CAAA,IAAA,IAAR,EAAA;AACD;;AACD,aAAA,SAAA;AACD;;;iCAEYF,K,EAAOE,O,EAASE,M,EAAQ;AAAA,UAC5BH,GAD4B,GACrBC,OADqB,CAAA,GAAA;;AAEnC,UAAIF,KAAK,IAAIA,KAAK,CAAlB,GAAkB,CAAlB,EAAyB;AACvB,eAAOA,KAAK,CAAZ,GAAY,CAAZ;AACD;;AACD,UAAA,MAAA,EAAY;AACV,eAAQA,KAAK,CAALA,GAAK,CAALA,GAAR,EAAA;AACD;;AACD,aAAA,SAAA;AACD;;;gCAEWC,G,EAAKC,O,EAASE,M,EAAQ;AAAA,UACzBD,GADyB,GAClBD,OADkB,CAAA,GAAA;;AAEhC,UAAID,GAAG,IAAIA,GAAG,CAAd,GAAc,CAAd,EAAqB;AACnB,eAAOA,GAAG,CAAV,GAAU,CAAV;AACD;;AACD,UAAA,MAAA,EAAY;AACV,eAAQA,GAAG,CAAHA,GAAG,CAAHA,GAAW,KAAA,QAAA,GACfQ,MAAM,CAANA,MAAAA,CAAAA,OAAAA,EAAuBC,IAAI,CAAJA,KAAAA,CAAWA,IAAI,CAAJA,SAAAA,CAAe,KADlC,QACmBA,CAAXA,CAAvBD,CADe,GAAnB,OAAA;AAGD;;AACD,aAAA,SAAA;AACD;;;+BAEUZ,S,EAAWc,K,EAAOC,S,EAAWC,S,EAAW;AACjD,UAAMb,KAAK,GAAG,KAAA,MAAA,CAAd,SAAc,CAAd;;AACA,UAAA,KAAA,EAAW;AACT,YAAMc,OAAO,GAAb,EAAA;;AACA,aAAK,IAAIC,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAjB,SAAA,EAA+BA,CAA/B,EAAA,EAAoC;AAClCD,UAAAA,OAAO,CAAPA,IAAAA,CAAAA,EAAAA;AACD;;AACDd,QAAAA,KAAK,CAALA,MAAAA,CAAAA,KAAAA,CAAAA,KAAAA,EAAK,CAAA,KAAA,EAAA,SAAA,EAAA,MAAA,CAALA,OAAK,CAALA;AACD;AACF;;;kCAEaH,S,EAAWc,K,EAAOC,S,EAAWC,S,EAAW;AACpD,UAAMb,KAAK,GAAG,KAAA,MAAA,CAAd,SAAc,CAAd;;AACA,UAAA,KAAA,EAAW;AACT,YAAMc,OAAO,GAAb,EAAA;;AACA,aAAK,IAAIC,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAjB,SAAA,EAA+BA,CAA/B,EAAA,EAAoC;AAClCD,UAAAA,OAAO,CAAPA,IAAAA,CAAAA,IAAAA;AACD;;AACDtB,QAAAA,CAAC,CAADA,IAAAA,CAAAA,KAAAA,EAAc,UAAA,GAAA,EAAO;AACnBS,UAAAA,GAAG,CAAHA,MAAAA,CAAAA,KAAAA,CAAAA,GAAAA,EAAG,CAAA,KAAA,EAAA,SAAA,EAAA,MAAA,CAAHA,OAAG,CAAHA;AADFT,SAAAA;AAGD;AACF;;;;;;AAGHwB,MAAM,CAANA,OAAAA,GAAAA,UAAAA","sourcesContent":["const _ = require('./under-dash');\r\nconst colCache = require('./col-cache');\r\n\r\nclass CellMatrix {\r\n  constructor(template) {\r\n    this.template = template;\r\n    this.sheets = {};\r\n  }\r\n\r\n  addCell(addressStr) {\r\n    this.addCellEx(colCache.decodeEx(addressStr));\r\n  }\r\n\r\n  getCell(addressStr) {\r\n    return this.findCellEx(colCache.decodeEx(addressStr), true);\r\n  }\r\n\r\n  findCell(addressStr) {\r\n    return this.findCellEx(colCache.decodeEx(addressStr), false);\r\n  }\r\n\r\n  findCellAt(sheetName, rowNumber, colNumber) {\r\n    const sheet = this.sheets[sheetName];\r\n    const row = sheet && sheet[rowNumber];\r\n    return row && row[colNumber];\r\n  }\r\n\r\n  addCellEx(address) {\r\n    if (address.top) {\r\n      for (let row = address.top; row <= address.bottom; row++) {\r\n        for (let col = address.left; col <= address.right; col++) {\r\n          this.getCellAt(address.sheetName, row, col);\r\n        }\r\n      }\r\n    } else {\r\n      this.findCellEx(address, true);\r\n    }\r\n  }\r\n\r\n  getCellEx(address) {\r\n    return this.findCellEx(address, true);\r\n  }\r\n\r\n  findCellEx(address, create) {\r\n    const sheet = this.findSheet(address, create);\r\n    const row = this.findSheetRow(sheet, address, create);\r\n    return this.findRowCell(row, address, create);\r\n  }\r\n\r\n  getCellAt(sheetName, rowNumber, colNumber) {\r\n    const sheet = this.sheets[sheetName] || (this.sheets[sheetName] = []);\r\n    const row = sheet[rowNumber] || (sheet[rowNumber] = []);\r\n    const cell =\r\n      row[colNumber] ||\r\n      (row[colNumber] = {\r\n        sheetName,\r\n        address: colCache.n2l(colNumber) + rowNumber,\r\n        row: rowNumber,\r\n        col: colNumber,\r\n      });\r\n    return cell;\r\n  }\r\n\r\n  removeCellEx(address) {\r\n    const sheet = this.findSheet(address);\r\n    if (!sheet) {\r\n      return;\r\n    }\r\n    const row = this.findSheetRow(sheet, address);\r\n    if (!row) {\r\n      return;\r\n    }\r\n    delete row[address.col];\r\n  }\r\n\r\n  forEachInSheet(sheetName, callback) {\r\n    const sheet = this.sheets[sheetName];\r\n    if (sheet) {\r\n      sheet.forEach((row, rowNumber) => {\r\n        if (row) {\r\n          row.forEach((cell, colNumber) => {\r\n            if (cell) {\r\n              callback(cell, rowNumber, colNumber);\r\n            }\r\n          });\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  forEach(callback) {\r\n    _.each(this.sheets, (sheet, sheetName) => {\r\n      this.forEachInSheet(sheetName, callback);\r\n    });\r\n  }\r\n\r\n  map(callback) {\r\n    const results = [];\r\n    this.forEach(cell => {\r\n      results.push(callback(cell));\r\n    });\r\n    return results;\r\n  }\r\n\r\n  findSheet(address, create) {\r\n    const name = address.sheetName;\r\n    if (this.sheets[name]) {\r\n      return this.sheets[name];\r\n    }\r\n    if (create) {\r\n      return (this.sheets[name] = []);\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  findSheetRow(sheet, address, create) {\r\n    const {row} = address;\r\n    if (sheet && sheet[row]) {\r\n      return sheet[row];\r\n    }\r\n    if (create) {\r\n      return (sheet[row] = []);\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  findRowCell(row, address, create) {\r\n    const {col} = address;\r\n    if (row && row[col]) {\r\n      return row[col];\r\n    }\r\n    if (create) {\r\n      return (row[col] = this.template\r\n        ? Object.assign(address, JSON.parse(JSON.stringify(this.template)))\r\n        : address);\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  spliceRows(sheetName, start, numDelete, numInsert) {\r\n    const sheet = this.sheets[sheetName];\r\n    if (sheet) {\r\n      const inserts = [];\r\n      for (let i = 0; i < numInsert; i++) {\r\n        inserts.push([]);\r\n      }\r\n      sheet.splice(start, numDelete, ...inserts);\r\n    }\r\n  }\r\n\r\n  spliceColumns(sheetName, start, numDelete, numInsert) {\r\n    const sheet = this.sheets[sheetName];\r\n    if (sheet) {\r\n      const inserts = [];\r\n      for (let i = 0; i < numInsert; i++) {\r\n        inserts.push(null);\r\n      }\r\n      _.each(sheet, row => {\r\n        row.splice(start, numDelete, ...inserts);\r\n      });\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = CellMatrix;\r\n"]},"metadata":{},"sourceType":"script"}