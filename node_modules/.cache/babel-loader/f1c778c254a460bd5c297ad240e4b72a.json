{"ast":null,"code":"\"use strict\";\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n/* eslint-disable max-classes-per-file */\n\n\nvar BaseXform = require('../base-xform');\n\nvar ColorXform = require('./color-xform');\n\nvar StopXform = /*#__PURE__*/function (_BaseXform) {\n  _inherits(StopXform, _BaseXform);\n\n  var _super = _createSuper(StopXform);\n\n  function StopXform() {\n    var _this;\n\n    _classCallCheck(this, StopXform);\n\n    _this = _super.call(this);\n    _this.map = {\n      color: new ColorXform()\n    };\n    return _this;\n  }\n\n  _createClass(StopXform, [{\n    key: \"render\",\n    value: function render(xmlStream, model) {\n      xmlStream.openNode('stop');\n      xmlStream.addAttribute('position', model.position);\n      this.map.color.render(xmlStream, model.color);\n      xmlStream.closeNode();\n    }\n  }, {\n    key: \"parseOpen\",\n    value: function parseOpen(node) {\n      if (this.parser) {\n        this.parser.parseOpen(node);\n        return true;\n      }\n\n      switch (node.name) {\n        case 'stop':\n          this.model = {\n            position: parseFloat(node.attributes.position)\n          };\n          return true;\n\n        case 'color':\n          this.parser = this.map.color;\n          this.parser.parseOpen(node);\n          return true;\n\n        default:\n          return false;\n      }\n    }\n  }, {\n    key: \"parseText\",\n    value: function parseText() {}\n  }, {\n    key: \"parseClose\",\n    value: function parseClose(name) {\n      if (this.parser) {\n        if (!this.parser.parseClose(name)) {\n          this.model.color = this.parser.model;\n          this.parser = undefined;\n        }\n\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"tag\",\n    get: function get() {\n      return 'stop';\n    }\n  }]);\n\n  return StopXform;\n}(BaseXform);\n\nvar PatternFillXform = /*#__PURE__*/function (_BaseXform2) {\n  _inherits(PatternFillXform, _BaseXform2);\n\n  var _super2 = _createSuper(PatternFillXform);\n\n  function PatternFillXform() {\n    var _this2;\n\n    _classCallCheck(this, PatternFillXform);\n\n    _this2 = _super2.call(this);\n    _this2.map = {\n      fgColor: new ColorXform('fgColor'),\n      bgColor: new ColorXform('bgColor')\n    };\n    return _this2;\n  }\n\n  _createClass(PatternFillXform, [{\n    key: \"render\",\n    value: function render(xmlStream, model) {\n      xmlStream.openNode('patternFill');\n      xmlStream.addAttribute('patternType', model.pattern);\n\n      if (model.fgColor) {\n        this.map.fgColor.render(xmlStream, model.fgColor);\n      }\n\n      if (model.bgColor) {\n        this.map.bgColor.render(xmlStream, model.bgColor);\n      }\n\n      xmlStream.closeNode();\n    }\n  }, {\n    key: \"parseOpen\",\n    value: function parseOpen(node) {\n      if (this.parser) {\n        this.parser.parseOpen(node);\n        return true;\n      }\n\n      switch (node.name) {\n        case 'patternFill':\n          this.model = {\n            type: 'pattern',\n            pattern: node.attributes.patternType\n          };\n          return true;\n\n        default:\n          this.parser = this.map[node.name];\n\n          if (this.parser) {\n            this.parser.parseOpen(node);\n            return true;\n          }\n\n          return false;\n      }\n    }\n  }, {\n    key: \"parseText\",\n    value: function parseText(text) {\n      if (this.parser) {\n        this.parser.parseText(text);\n      }\n    }\n  }, {\n    key: \"parseClose\",\n    value: function parseClose(name) {\n      if (this.parser) {\n        if (!this.parser.parseClose(name)) {\n          if (this.parser.model) {\n            this.model[name] = this.parser.model;\n          }\n\n          this.parser = undefined;\n        }\n\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"name\",\n    get: function get() {\n      return 'pattern';\n    }\n  }, {\n    key: \"tag\",\n    get: function get() {\n      return 'patternFill';\n    }\n  }]);\n\n  return PatternFillXform;\n}(BaseXform);\n\nvar GradientFillXform = /*#__PURE__*/function (_BaseXform3) {\n  _inherits(GradientFillXform, _BaseXform3);\n\n  var _super3 = _createSuper(GradientFillXform);\n\n  function GradientFillXform() {\n    var _this3;\n\n    _classCallCheck(this, GradientFillXform);\n\n    _this3 = _super3.call(this);\n    _this3.map = {\n      stop: new StopXform()\n    }; // if (model) {\n    //   this.gradient = model.gradient;\n    //   if (model.center) {\n    //     this.center = model.center;\n    //   }\n    //   if (model.degree !== undefined) {\n    //     this.degree = model.degree;\n    //   }\n    //   this.stops = model.stops.map(function(stop) { return new StopXform(stop); });\n    // } else {\n    //   this.stops = [];\n    // }\n\n    return _this3;\n  }\n\n  _createClass(GradientFillXform, [{\n    key: \"render\",\n    value: function render(xmlStream, model) {\n      xmlStream.openNode('gradientFill');\n\n      switch (model.gradient) {\n        case 'angle':\n          xmlStream.addAttribute('degree', model.degree);\n          break;\n\n        case 'path':\n          xmlStream.addAttribute('type', 'path');\n\n          if (model.center.left) {\n            xmlStream.addAttribute('left', model.center.left);\n\n            if (model.center.right === undefined) {\n              xmlStream.addAttribute('right', model.center.left);\n            }\n          }\n\n          if (model.center.right) {\n            xmlStream.addAttribute('right', model.center.right);\n          }\n\n          if (model.center.top) {\n            xmlStream.addAttribute('top', model.center.top);\n\n            if (model.center.bottom === undefined) {\n              xmlStream.addAttribute('bottom', model.center.top);\n            }\n          }\n\n          if (model.center.bottom) {\n            xmlStream.addAttribute('bottom', model.center.bottom);\n          }\n\n          break;\n\n        default:\n          break;\n      }\n\n      var stopXform = this.map.stop;\n      model.stops.forEach(function (stopModel) {\n        stopXform.render(xmlStream, stopModel);\n      });\n      xmlStream.closeNode();\n    }\n  }, {\n    key: \"parseOpen\",\n    value: function parseOpen(node) {\n      if (this.parser) {\n        this.parser.parseOpen(node);\n        return true;\n      }\n\n      switch (node.name) {\n        case 'gradientFill':\n          {\n            var model = this.model = {\n              stops: []\n            };\n\n            if (node.attributes.degree) {\n              model.gradient = 'angle';\n              model.degree = parseInt(node.attributes.degree, 10);\n            } else if (node.attributes.type === 'path') {\n              model.gradient = 'path';\n              model.center = {\n                left: node.attributes.left ? parseFloat(node.attributes.left) : 0,\n                top: node.attributes.top ? parseFloat(node.attributes.top) : 0\n              };\n\n              if (node.attributes.right !== node.attributes.left) {\n                model.center.right = node.attributes.right ? parseFloat(node.attributes.right) : 0;\n              }\n\n              if (node.attributes.bottom !== node.attributes.top) {\n                model.center.bottom = node.attributes.bottom ? parseFloat(node.attributes.bottom) : 0;\n              }\n            }\n\n            return true;\n          }\n\n        case 'stop':\n          this.parser = this.map.stop;\n          this.parser.parseOpen(node);\n          return true;\n\n        default:\n          return false;\n      }\n    }\n  }, {\n    key: \"parseText\",\n    value: function parseText(text) {\n      if (this.parser) {\n        this.parser.parseText(text);\n      }\n    }\n  }, {\n    key: \"parseClose\",\n    value: function parseClose(name) {\n      if (this.parser) {\n        if (!this.parser.parseClose(name)) {\n          this.model.stops.push(this.parser.model);\n          this.parser = undefined;\n        }\n\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"name\",\n    get: function get() {\n      return 'gradient';\n    }\n  }, {\n    key: \"tag\",\n    get: function get() {\n      return 'gradientFill';\n    }\n  }]);\n\n  return GradientFillXform;\n}(BaseXform); // Fill encapsulates translation from fill model to/from xlsx\n\n\nvar FillXform = /*#__PURE__*/function (_BaseXform4) {\n  _inherits(FillXform, _BaseXform4);\n\n  var _super4 = _createSuper(FillXform);\n\n  function FillXform() {\n    var _this4;\n\n    _classCallCheck(this, FillXform);\n\n    _this4 = _super4.call(this);\n    _this4.map = {\n      patternFill: new PatternFillXform(),\n      gradientFill: new GradientFillXform()\n    };\n    return _this4;\n  }\n\n  _createClass(FillXform, [{\n    key: \"render\",\n    value: function render(xmlStream, model) {\n      xmlStream.addRollback();\n      xmlStream.openNode('fill');\n\n      switch (model.type) {\n        case 'pattern':\n          this.map.patternFill.render(xmlStream, model);\n          break;\n\n        case 'gradient':\n          this.map.gradientFill.render(xmlStream, model);\n          break;\n\n        default:\n          xmlStream.rollback();\n          return;\n      }\n\n      xmlStream.closeNode();\n      xmlStream.commit();\n    }\n  }, {\n    key: \"parseOpen\",\n    value: function parseOpen(node) {\n      if (this.parser) {\n        this.parser.parseOpen(node);\n        return true;\n      }\n\n      switch (node.name) {\n        case 'fill':\n          this.model = {};\n          return true;\n\n        default:\n          this.parser = this.map[node.name];\n\n          if (this.parser) {\n            this.parser.parseOpen(node);\n            return true;\n          }\n\n          return false;\n      }\n    }\n  }, {\n    key: \"parseText\",\n    value: function parseText(text) {\n      if (this.parser) {\n        this.parser.parseText(text);\n      }\n    }\n  }, {\n    key: \"parseClose\",\n    value: function parseClose(name) {\n      if (this.parser) {\n        if (!this.parser.parseClose(name)) {\n          this.model = this.parser.model;\n          this.model.type = this.parser.name;\n          this.parser = undefined;\n        }\n\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"validStyle\",\n    value: function validStyle(value) {\n      return FillXform.validPatternValues[value];\n    }\n  }, {\n    key: \"tag\",\n    get: function get() {\n      return 'fill';\n    }\n  }]);\n\n  return FillXform;\n}(BaseXform);\n\nFillXform.validPatternValues = ['none', 'solid', 'darkVertical', 'darkGray', 'mediumGray', 'lightGray', 'gray125', 'gray0625', 'darkHorizontal', 'darkVertical', 'darkDown', 'darkUp', 'darkGrid', 'darkTrellis', 'lightHorizontal', 'lightVertical', 'lightDown', 'lightUp', 'lightGrid', 'lightTrellis', 'lightGrid'].reduce(function (p, v) {\n  p[v] = true;\n  return p;\n}, {});\nFillXform.StopXform = StopXform;\nFillXform.PatternFillXform = PatternFillXform;\nFillXform.GradientFillXform = GradientFillXform;\nmodule.exports = FillXform;","map":{"version":3,"sources":["../../../../../lib/xlsx/xform/style/fill-xform.js"],"names":["BaseXform","require","ColorXform","StopXform","color","xmlStream","model","node","position","parseFloat","name","PatternFillXform","fgColor","bgColor","type","pattern","patternType","text","GradientFillXform","stop","stopXform","stops","parseInt","left","top","FillXform","patternFill","gradientFill","value","p","module"],"mappings":"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","sourcesContent":["/* eslint-disable max-classes-per-file */\r\nconst BaseXform = require('../base-xform');\r\n\r\nconst ColorXform = require('./color-xform');\r\n\r\nclass StopXform extends BaseXform {\r\n  constructor() {\r\n    super();\r\n\r\n    this.map = {\r\n      color: new ColorXform(),\r\n    };\r\n  }\r\n\r\n  get tag() {\r\n    return 'stop';\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    xmlStream.openNode('stop');\r\n    xmlStream.addAttribute('position', model.position);\r\n    this.map.color.render(xmlStream, model.color);\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  parseOpen(node) {\r\n    if (this.parser) {\r\n      this.parser.parseOpen(node);\r\n      return true;\r\n    }\r\n    switch (node.name) {\r\n      case 'stop':\r\n        this.model = {\r\n          position: parseFloat(node.attributes.position),\r\n        };\r\n        return true;\r\n      case 'color':\r\n        this.parser = this.map.color;\r\n        this.parser.parseOpen(node);\r\n        return true;\r\n      default:\r\n        return false;\r\n    }\r\n  }\r\n\r\n  parseText() {}\r\n\r\n  parseClose(name) {\r\n    if (this.parser) {\r\n      if (!this.parser.parseClose(name)) {\r\n        this.model.color = this.parser.model;\r\n        this.parser = undefined;\r\n      }\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n}\r\n\r\nclass PatternFillXform extends BaseXform {\r\n  constructor() {\r\n    super();\r\n\r\n    this.map = {\r\n      fgColor: new ColorXform('fgColor'),\r\n      bgColor: new ColorXform('bgColor'),\r\n    };\r\n  }\r\n\r\n  get name() {\r\n    return 'pattern';\r\n  }\r\n\r\n  get tag() {\r\n    return 'patternFill';\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    xmlStream.openNode('patternFill');\r\n    xmlStream.addAttribute('patternType', model.pattern);\r\n    if (model.fgColor) {\r\n      this.map.fgColor.render(xmlStream, model.fgColor);\r\n    }\r\n    if (model.bgColor) {\r\n      this.map.bgColor.render(xmlStream, model.bgColor);\r\n    }\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  parseOpen(node) {\r\n    if (this.parser) {\r\n      this.parser.parseOpen(node);\r\n      return true;\r\n    }\r\n    switch (node.name) {\r\n      case 'patternFill':\r\n        this.model = {\r\n          type: 'pattern',\r\n          pattern: node.attributes.patternType,\r\n        };\r\n        return true;\r\n      default:\r\n        this.parser = this.map[node.name];\r\n        if (this.parser) {\r\n          this.parser.parseOpen(node);\r\n          return true;\r\n        }\r\n        return false;\r\n    }\r\n  }\r\n\r\n  parseText(text) {\r\n    if (this.parser) {\r\n      this.parser.parseText(text);\r\n    }\r\n  }\r\n\r\n  parseClose(name) {\r\n    if (this.parser) {\r\n      if (!this.parser.parseClose(name)) {\r\n        if (this.parser.model) {\r\n          this.model[name] = this.parser.model;\r\n        }\r\n        this.parser = undefined;\r\n      }\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n}\r\n\r\nclass GradientFillXform extends BaseXform {\r\n  constructor() {\r\n    super();\r\n\r\n    this.map = {\r\n      stop: new StopXform(),\r\n    };\r\n    // if (model) {\r\n    //   this.gradient = model.gradient;\r\n    //   if (model.center) {\r\n    //     this.center = model.center;\r\n    //   }\r\n    //   if (model.degree !== undefined) {\r\n    //     this.degree = model.degree;\r\n    //   }\r\n    //   this.stops = model.stops.map(function(stop) { return new StopXform(stop); });\r\n    // } else {\r\n    //   this.stops = [];\r\n    // }\r\n  }\r\n\r\n  get name() {\r\n    return 'gradient';\r\n  }\r\n\r\n  get tag() {\r\n    return 'gradientFill';\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    xmlStream.openNode('gradientFill');\r\n    switch (model.gradient) {\r\n      case 'angle':\r\n        xmlStream.addAttribute('degree', model.degree);\r\n        break;\r\n      case 'path':\r\n        xmlStream.addAttribute('type', 'path');\r\n        if (model.center.left) {\r\n          xmlStream.addAttribute('left', model.center.left);\r\n          if (model.center.right === undefined) {\r\n            xmlStream.addAttribute('right', model.center.left);\r\n          }\r\n        }\r\n        if (model.center.right) {\r\n          xmlStream.addAttribute('right', model.center.right);\r\n        }\r\n        if (model.center.top) {\r\n          xmlStream.addAttribute('top', model.center.top);\r\n          if (model.center.bottom === undefined) {\r\n            xmlStream.addAttribute('bottom', model.center.top);\r\n          }\r\n        }\r\n        if (model.center.bottom) {\r\n          xmlStream.addAttribute('bottom', model.center.bottom);\r\n        }\r\n        break;\r\n\r\n      default:\r\n        break;\r\n    }\r\n\r\n    const stopXform = this.map.stop;\r\n    model.stops.forEach(stopModel => {\r\n      stopXform.render(xmlStream, stopModel);\r\n    });\r\n\r\n    xmlStream.closeNode();\r\n  }\r\n\r\n  parseOpen(node) {\r\n    if (this.parser) {\r\n      this.parser.parseOpen(node);\r\n      return true;\r\n    }\r\n    switch (node.name) {\r\n      case 'gradientFill': {\r\n        const model = (this.model = {\r\n          stops: [],\r\n        });\r\n        if (node.attributes.degree) {\r\n          model.gradient = 'angle';\r\n          model.degree = parseInt(node.attributes.degree, 10);\r\n        } else if (node.attributes.type === 'path') {\r\n          model.gradient = 'path';\r\n          model.center = {\r\n            left: node.attributes.left ? parseFloat(node.attributes.left) : 0,\r\n            top: node.attributes.top ? parseFloat(node.attributes.top) : 0,\r\n          };\r\n          if (node.attributes.right !== node.attributes.left) {\r\n            model.center.right = node.attributes.right ? parseFloat(node.attributes.right) : 0;\r\n          }\r\n          if (node.attributes.bottom !== node.attributes.top) {\r\n            model.center.bottom = node.attributes.bottom ? parseFloat(node.attributes.bottom) : 0;\r\n          }\r\n        }\r\n        return true;\r\n      }\r\n\r\n      case 'stop':\r\n        this.parser = this.map.stop;\r\n        this.parser.parseOpen(node);\r\n        return true;\r\n\r\n      default:\r\n        return false;\r\n    }\r\n  }\r\n\r\n  parseText(text) {\r\n    if (this.parser) {\r\n      this.parser.parseText(text);\r\n    }\r\n  }\r\n\r\n  parseClose(name) {\r\n    if (this.parser) {\r\n      if (!this.parser.parseClose(name)) {\r\n        this.model.stops.push(this.parser.model);\r\n        this.parser = undefined;\r\n      }\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n}\r\n\r\n// Fill encapsulates translation from fill model to/from xlsx\r\nclass FillXform extends BaseXform {\r\n  constructor() {\r\n    super();\r\n\r\n    this.map = {\r\n      patternFill: new PatternFillXform(),\r\n      gradientFill: new GradientFillXform(),\r\n    };\r\n  }\r\n\r\n  get tag() {\r\n    return 'fill';\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    xmlStream.addRollback();\r\n    xmlStream.openNode('fill');\r\n    switch (model.type) {\r\n      case 'pattern':\r\n        this.map.patternFill.render(xmlStream, model);\r\n        break;\r\n      case 'gradient':\r\n        this.map.gradientFill.render(xmlStream, model);\r\n        break;\r\n      default:\r\n        xmlStream.rollback();\r\n        return;\r\n    }\r\n    xmlStream.closeNode();\r\n    xmlStream.commit();\r\n  }\r\n\r\n  parseOpen(node) {\r\n    if (this.parser) {\r\n      this.parser.parseOpen(node);\r\n      return true;\r\n    }\r\n    switch (node.name) {\r\n      case 'fill':\r\n        this.model = {};\r\n        return true;\r\n      default:\r\n        this.parser = this.map[node.name];\r\n        if (this.parser) {\r\n          this.parser.parseOpen(node);\r\n          return true;\r\n        }\r\n        return false;\r\n    }\r\n  }\r\n\r\n  parseText(text) {\r\n    if (this.parser) {\r\n      this.parser.parseText(text);\r\n    }\r\n  }\r\n\r\n  parseClose(name) {\r\n    if (this.parser) {\r\n      if (!this.parser.parseClose(name)) {\r\n        this.model = this.parser.model;\r\n        this.model.type = this.parser.name;\r\n        this.parser = undefined;\r\n      }\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  validStyle(value) {\r\n    return FillXform.validPatternValues[value];\r\n  }\r\n}\r\n\r\nFillXform.validPatternValues = [\r\n  'none',\r\n  'solid',\r\n  'darkVertical',\r\n  'darkGray',\r\n  'mediumGray',\r\n  'lightGray',\r\n  'gray125',\r\n  'gray0625',\r\n  'darkHorizontal',\r\n  'darkVertical',\r\n  'darkDown',\r\n  'darkUp',\r\n  'darkGrid',\r\n  'darkTrellis',\r\n  'lightHorizontal',\r\n  'lightVertical',\r\n  'lightDown',\r\n  'lightUp',\r\n  'lightGrid',\r\n  'lightTrellis',\r\n  'lightGrid',\r\n].reduce((p, v) => {\r\n  p[v] = true;\r\n  return p;\r\n}, {});\r\n\r\nFillXform.StopXform = StopXform;\r\nFillXform.PatternFillXform = PatternFillXform;\r\nFillXform.GradientFillXform = GradientFillXform;\r\n\r\nmodule.exports = FillXform;\r\n"]},"metadata":{},"sourceType":"script"}