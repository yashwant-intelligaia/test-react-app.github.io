{"ast":null,"code":"\"use strict\";\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nvar BaseXform = require('../base-xform'); // render the triangle in the cell for the comment\n\n\nvar VmlAnchorXform = /*#__PURE__*/function (_BaseXform) {\n  _inherits(VmlAnchorXform, _BaseXform);\n\n  var _super = _createSuper(VmlAnchorXform);\n\n  function VmlAnchorXform() {\n    _classCallCheck(this, VmlAnchorXform);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(VmlAnchorXform, [{\n    key: \"getAnchorRect\",\n    value: function getAnchorRect(anchor) {\n      var l = Math.floor(anchor.left);\n      var lf = Math.floor((anchor.left - l) * 68);\n      var t = Math.floor(anchor.top);\n      var tf = Math.floor((anchor.top - t) * 18);\n      var r = Math.floor(anchor.right);\n      var rf = Math.floor((anchor.right - r) * 68);\n      var b = Math.floor(anchor.bottom);\n      var bf = Math.floor((anchor.bottom - b) * 18);\n      return [l, lf, t, tf, r, rf, b, bf];\n    }\n  }, {\n    key: \"getDefaultRect\",\n    value: function getDefaultRect(ref) {\n      var l = ref.col;\n      var lf = 6;\n      var t = Math.max(ref.row - 2, 0);\n      var tf = 14;\n      var r = l + 2;\n      var rf = 2;\n      var b = t + 4;\n      var bf = 16;\n      return [l, lf, t, tf, r, rf, b, bf];\n    }\n  }, {\n    key: \"render\",\n    value: function render(xmlStream, model) {\n      var rect = model.anchor ? this.getAnchorRect(model.anchor) : this.getDefaultRect(model.refAddress);\n      xmlStream.leafNode('x:Anchor', null, rect.join(', '));\n    }\n  }, {\n    key: \"parseOpen\",\n    value: function parseOpen(node) {\n      switch (node.name) {\n        case this.tag:\n          this.text = '';\n          return true;\n\n        default:\n          return false;\n      }\n    }\n  }, {\n    key: \"parseText\",\n    value: function parseText(text) {\n      this.text = text;\n    }\n  }, {\n    key: \"parseClose\",\n    value: function parseClose() {\n      return false;\n    }\n  }, {\n    key: \"tag\",\n    get: function get() {\n      return 'x:Anchor';\n    }\n  }]);\n\n  return VmlAnchorXform;\n}(BaseXform);\n\nmodule.exports = VmlAnchorXform;","map":{"version":3,"sources":["../../../../../lib/xlsx/xform/comment/vml-anchor-xform.js"],"names":["BaseXform","require","VmlAnchorXform","anchor","l","Math","lf","t","tf","r","rf","b","bf","ref","xmlStream","model","rect","node","text","module"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAMA,SAAS,GAAGC,OAAO,CAAzB,eAAyB,CAAzB,C,CAEA;;;IACMC,c;;;;;;;;;;;;;kCAKUC,M,EAAQ;AACpB,UAAMC,CAAC,GAAGC,IAAI,CAAJA,KAAAA,CAAWF,MAAM,CAA3B,IAAUE,CAAV;AACA,UAAMC,EAAE,GAAGD,IAAI,CAAJA,KAAAA,CAAW,CAACF,MAAM,CAANA,IAAAA,GAAD,CAAA,IAAtB,EAAWE,CAAX;AACA,UAAME,CAAC,GAAGF,IAAI,CAAJA,KAAAA,CAAWF,MAAM,CAA3B,GAAUE,CAAV;AACA,UAAMG,EAAE,GAAGH,IAAI,CAAJA,KAAAA,CAAW,CAACF,MAAM,CAANA,GAAAA,GAAD,CAAA,IAAtB,EAAWE,CAAX;AACA,UAAMI,CAAC,GAAGJ,IAAI,CAAJA,KAAAA,CAAWF,MAAM,CAA3B,KAAUE,CAAV;AACA,UAAMK,EAAE,GAAGL,IAAI,CAAJA,KAAAA,CAAW,CAACF,MAAM,CAANA,KAAAA,GAAD,CAAA,IAAtB,EAAWE,CAAX;AACA,UAAMM,CAAC,GAAGN,IAAI,CAAJA,KAAAA,CAAWF,MAAM,CAA3B,MAAUE,CAAV;AACA,UAAMO,EAAE,GAAGP,IAAI,CAAJA,KAAAA,CAAW,CAACF,MAAM,CAANA,MAAAA,GAAD,CAAA,IAAtB,EAAWE,CAAX;AACA,aAAO,CAAA,CAAA,EAAA,EAAA,EAAA,CAAA,EAAA,EAAA,EAAA,CAAA,EAAA,EAAA,EAAA,CAAA,EAAP,EAAO,CAAP;AACD;;;mCAEcQ,G,EAAK;AAClB,UAAMT,CAAC,GAAGS,GAAG,CAAb,GAAA;AACA,UAAMP,EAAE,GAAR,CAAA;AACA,UAAMC,CAAC,GAAGF,IAAI,CAAJA,GAAAA,CAASQ,GAAG,CAAHA,GAAAA,GAATR,CAAAA,EAAV,CAAUA,CAAV;AACA,UAAMG,EAAE,GAAR,EAAA;AACA,UAAMC,CAAC,GAAGL,CAAC,GAAX,CAAA;AACA,UAAMM,EAAE,GAAR,CAAA;AACA,UAAMC,CAAC,GAAGJ,CAAC,GAAX,CAAA;AACA,UAAMK,EAAE,GAAR,EAAA;AACA,aAAO,CAAA,CAAA,EAAA,EAAA,EAAA,CAAA,EAAA,EAAA,EAAA,CAAA,EAAA,EAAA,EAAA,CAAA,EAAP,EAAO,CAAP;AACD;;;2BAEME,S,EAAWC,K,EAAO;AACvB,UAAMC,IAAI,GAAGD,KAAK,CAALA,MAAAA,GACT,KAAA,aAAA,CAAmBA,KAAK,CADfA,MACT,CADSA,GAET,KAAA,cAAA,CAAoBA,KAAK,CAF7B,UAEI,CAFJ;AAIAD,MAAAA,SAAS,CAATA,QAAAA,CAAAA,UAAAA,EAAAA,IAAAA,EAAqCE,IAAI,CAAJA,IAAAA,CAArCF,IAAqCE,CAArCF;AACD;;;8BAESG,I,EAAM;AACd,cAAQA,IAAI,CAAZ,IAAA;AACE,aAAK,KAAL,GAAA;AACE,eAAA,IAAA,GAAA,EAAA;AACA,iBAAA,IAAA;;AACF;AACE,iBAAA,KAAA;AALJ;AAOD;;;8BAESC,I,EAAM;AACd,WAAA,IAAA,GAAA,IAAA;AACD;;;iCAEY;AACX,aAAA,KAAA;AACD;;;wBApDS;AACR,aAAA,UAAA;AACD;;;;EAH0BlB,S;;AAwD7BmB,MAAM,CAANA,OAAAA,GAAAA,cAAAA","sourcesContent":["const BaseXform = require('../base-xform');\r\n\r\n// render the triangle in the cell for the comment\r\nclass VmlAnchorXform extends BaseXform {\r\n  get tag() {\r\n    return 'x:Anchor';\r\n  }\r\n\r\n  getAnchorRect(anchor) {\r\n    const l = Math.floor(anchor.left);\r\n    const lf = Math.floor((anchor.left - l) * 68);\r\n    const t = Math.floor(anchor.top);\r\n    const tf = Math.floor((anchor.top - t) * 18);\r\n    const r = Math.floor(anchor.right);\r\n    const rf = Math.floor((anchor.right - r) * 68);\r\n    const b = Math.floor(anchor.bottom);\r\n    const bf = Math.floor((anchor.bottom - b) * 18);\r\n    return [l, lf, t, tf, r, rf, b, bf];\r\n  }\r\n\r\n  getDefaultRect(ref) {\r\n    const l = ref.col;\r\n    const lf = 6;\r\n    const t = Math.max(ref.row - 2, 0);\r\n    const tf = 14;\r\n    const r = l + 2;\r\n    const rf = 2;\r\n    const b = t + 4;\r\n    const bf = 16;\r\n    return [l, lf, t, tf, r, rf, b, bf];\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    const rect = model.anchor\r\n      ? this.getAnchorRect(model.anchor)\r\n      : this.getDefaultRect(model.refAddress);\r\n\r\n    xmlStream.leafNode('x:Anchor', null, rect.join(', '));\r\n  }\r\n\r\n  parseOpen(node) {\r\n    switch (node.name) {\r\n      case this.tag:\r\n        this.text = '';\r\n        return true;\r\n      default:\r\n        return false;\r\n    }\r\n  }\r\n\r\n  parseText(text) {\r\n    this.text = text;\r\n  }\r\n\r\n  parseClose() {\r\n    return false;\r\n  }\r\n}\r\n\r\nmodule.exports = VmlAnchorXform;\r\n"]},"metadata":{},"sourceType":"script"}