{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/home/yashwant-intelligaia/Documents/Official/TestTasks/my-react-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n/* eslint-disable max-classes-per-file */\n\n\nvar Stream = require('readable-stream');\n\nvar utils = require('./utils');\n\nvar StringBuf = require('./string-buf'); // =============================================================================\n// data chunks - encapsulating incoming data\n\n\nvar StringChunk = /*#__PURE__*/function () {\n  function StringChunk(data, encoding) {\n    _classCallCheck(this, StringChunk);\n\n    this._data = data;\n    this._encoding = encoding;\n  }\n\n  _createClass(StringChunk, [{\n    key: \"copy\",\n    // copy to target buffer\n    value: function copy(target, targetOffset, offset, length) {\n      return this.toBuffer().copy(target, targetOffset, offset, length);\n    }\n  }, {\n    key: \"toBuffer\",\n    value: function toBuffer() {\n      if (!this._buffer) {\n        this._buffer = Buffer.from(this._data, this._encoding);\n      }\n\n      return this._buffer;\n    }\n  }, {\n    key: \"length\",\n    get: function get() {\n      return this.toBuffer().length;\n    }\n  }]);\n\n  return StringChunk;\n}();\n\nvar StringBufChunk = /*#__PURE__*/function () {\n  function StringBufChunk(data) {\n    _classCallCheck(this, StringBufChunk);\n\n    this._data = data;\n  }\n\n  _createClass(StringBufChunk, [{\n    key: \"copy\",\n    // copy to target buffer\n    value: function copy(target, targetOffset, offset, length) {\n      // eslint-disable-next-line no-underscore-dangle\n      return this._data._buf.copy(target, targetOffset, offset, length);\n    }\n  }, {\n    key: \"toBuffer\",\n    value: function toBuffer() {\n      return this._data.toBuffer();\n    }\n  }, {\n    key: \"length\",\n    get: function get() {\n      return this._data.length;\n    }\n  }]);\n\n  return StringBufChunk;\n}();\n\nvar BufferChunk = /*#__PURE__*/function () {\n  function BufferChunk(data) {\n    _classCallCheck(this, BufferChunk);\n\n    this._data = data;\n  }\n\n  _createClass(BufferChunk, [{\n    key: \"copy\",\n    // copy to target buffer\n    value: function copy(target, targetOffset, offset, length) {\n      this._data.copy(target, targetOffset, offset, length);\n    }\n  }, {\n    key: \"toBuffer\",\n    value: function toBuffer() {\n      return this._data;\n    }\n  }, {\n    key: \"length\",\n    get: function get() {\n      return this._data.length;\n    }\n  }]);\n\n  return BufferChunk;\n}(); // =============================================================================\n// ReadWriteBuf - a single buffer supporting simple read-write\n\n\nvar ReadWriteBuf = /*#__PURE__*/function () {\n  function ReadWriteBuf(size) {\n    _classCallCheck(this, ReadWriteBuf);\n\n    this.size = size; // the buffer\n\n    this.buffer = Buffer.alloc(size); // read index\n\n    this.iRead = 0; // write index\n\n    this.iWrite = 0;\n  }\n\n  _createClass(ReadWriteBuf, [{\n    key: \"toBuffer\",\n    value: function toBuffer() {\n      if (this.iRead === 0 && this.iWrite === this.size) {\n        return this.buffer;\n      }\n\n      var buf = Buffer.alloc(this.iWrite - this.iRead);\n      this.buffer.copy(buf, 0, this.iRead, this.iWrite);\n      return buf;\n    }\n  }, {\n    key: \"read\",\n    value: function read(size) {\n      var buf; // read size bytes from buffer and return buffer\n\n      if (size === 0) {\n        // special case - return null if no data requested\n        return null;\n      }\n\n      if (size === undefined || size >= this.length) {\n        // if no size specified or size is at least what we have then return all of the bytes\n        buf = this.toBuffer();\n        this.iRead = this.iWrite;\n        return buf;\n      } // otherwise return a chunk\n\n\n      buf = Buffer.alloc(size);\n      this.buffer.copy(buf, 0, this.iRead, size);\n      this.iRead += size;\n      return buf;\n    }\n  }, {\n    key: \"write\",\n    value: function write(chunk, offset, length) {\n      // write as many bytes from data from optional source offset\n      // and return number of bytes written\n      var size = Math.min(length, this.size - this.iWrite);\n      chunk.copy(this.buffer, this.iWrite, offset, offset + size);\n      this.iWrite += size;\n      return size;\n    }\n  }, {\n    key: \"length\",\n    get: function get() {\n      return this.iWrite - this.iRead;\n    }\n  }, {\n    key: \"eod\",\n    get: function get() {\n      return this.iRead === this.iWrite;\n    }\n  }, {\n    key: \"full\",\n    get: function get() {\n      return this.iWrite === this.size;\n    }\n  }]);\n\n  return ReadWriteBuf;\n}(); // =============================================================================\n// StreamBuf - a multi-purpose read-write stream\n//  As MemBuf - write as much data as you like. Then call toBuffer() to consolidate\n//  As StreamHub - pipe to multiple writables\n//  As readable stream - feed data into the writable part and have some other code read from it.\n// Note: Not sure why but StreamBuf does not like JS \"class\" sugar. It fails the\n// integration tests\n\n\nvar StreamBuf = function StreamBuf(options) {\n  options = options || {};\n  this.bufSize = options.bufSize || 1024 * 1024;\n  this.buffers = []; // batch mode fills a buffer completely before passing the data on\n  // to pipes or 'readable' event listeners\n\n  this.batch = options.batch || false;\n  this.corked = false; // where in the current writable buffer we're up to\n\n  this.inPos = 0; // where in the current readable buffer we've read up to\n\n  this.outPos = 0; // consuming pipe streams go here\n\n  this.pipes = []; // controls emit('data')\n\n  this.paused = false;\n  this.encoding = null;\n};\n\nutils.inherits(StreamBuf, Stream.Duplex, {\n  toBuffer: function toBuffer() {\n    switch (this.buffers.length) {\n      case 0:\n        return null;\n\n      case 1:\n        return this.buffers[0].toBuffer();\n\n      default:\n        return Buffer.concat(this.buffers.map(function (rwBuf) {\n          return rwBuf.toBuffer();\n        }));\n    }\n  },\n  // writable\n  // event drain - if write returns false (which it won't), indicates when safe to write again.\n  // finish - end() has been called\n  // pipe(src) - pipe() has been called on readable\n  // unpipe(src) - unpipe() has been called on readable\n  // error - duh\n  _getWritableBuffer: function _getWritableBuffer() {\n    if (this.buffers.length) {\n      var last = this.buffers[this.buffers.length - 1];\n\n      if (!last.full) {\n        return last;\n      }\n    }\n\n    var buf = new ReadWriteBuf(this.bufSize);\n    this.buffers.push(buf);\n    return buf;\n  },\n  _pipe: function _pipe(chunk) {\n    var _this = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n      var write;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              write = function write(pipe) {\n                return new Promise(function (resolve) {\n                  pipe.write(chunk.toBuffer(), function () {\n                    resolve();\n                  });\n                });\n              };\n\n              _context.next = 3;\n              return Promise.all(_this.pipes.map(write));\n\n            case 3:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }))();\n  },\n  _writeToBuffers: function _writeToBuffers(chunk) {\n    var inPos = 0;\n    var inLen = chunk.length;\n\n    while (inPos < inLen) {\n      // find writable buffer\n      var buffer = this._getWritableBuffer(); // write some data\n\n\n      inPos += buffer.write(chunk, inPos, inLen - inPos);\n    }\n  },\n  write: function write(data, encoding, callback) {\n    var _this2 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n      var chunk;\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              if (encoding instanceof Function) {\n                callback = encoding;\n                encoding = 'utf8';\n              }\n\n              callback = callback || utils.nop; // encapsulate data into a chunk\n\n              if (!(data instanceof StringBuf)) {\n                _context2.next = 6;\n                break;\n              }\n\n              chunk = new StringBufChunk(data);\n              _context2.next = 15;\n              break;\n\n            case 6:\n              if (!(data instanceof Buffer)) {\n                _context2.next = 10;\n                break;\n              }\n\n              chunk = new BufferChunk(data);\n              _context2.next = 15;\n              break;\n\n            case 10:\n              if (!(typeof data === 'string' || data instanceof String || data instanceof ArrayBuffer)) {\n                _context2.next = 14;\n                break;\n              }\n\n              chunk = new StringChunk(data, encoding);\n              _context2.next = 15;\n              break;\n\n            case 14:\n              throw new Error('Chunk must be one of type String, Buffer or StringBuf.');\n\n            case 15:\n              if (!_this2.pipes.length) {\n                _context2.next = 31;\n                break;\n              }\n\n              if (!_this2.batch) {\n                _context2.next = 21;\n                break;\n              }\n\n              _this2._writeToBuffers(chunk);\n\n              while (!_this2.corked && _this2.buffers.length > 1) {\n                _this2._pipe(_this2.buffers.shift());\n              }\n\n              _context2.next = 29;\n              break;\n\n            case 21:\n              if (_this2.corked) {\n                _context2.next = 27;\n                break;\n              }\n\n              _context2.next = 24;\n              return _this2._pipe(chunk);\n\n            case 24:\n              callback();\n              _context2.next = 29;\n              break;\n\n            case 27:\n              _this2._writeToBuffers(chunk);\n\n              process.nextTick(callback);\n\n            case 29:\n              _context2.next = 34;\n              break;\n\n            case 31:\n              if (!_this2.paused) {\n                _this2.emit('data', chunk.toBuffer());\n              }\n\n              _this2._writeToBuffers(chunk);\n\n              _this2.emit('readable');\n\n            case 34:\n              return _context2.abrupt(\"return\", true);\n\n            case 35:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }))();\n  },\n  cork: function cork() {\n    this.corked = true;\n  },\n  _flush: function _flush()\n  /* destination */\n  {\n    // if we have comsumers...\n    if (this.pipes.length) {\n      // and there's stuff not written\n      while (this.buffers.length) {\n        this._pipe(this.buffers.shift());\n      }\n    }\n  },\n  uncork: function uncork() {\n    this.corked = false;\n\n    this._flush();\n  },\n  end: function end(chunk, encoding, callback) {\n    var _this3 = this;\n\n    var writeComplete = function writeComplete(error) {\n      if (error) {\n        callback(error);\n      } else {\n        _this3._flush();\n\n        _this3.pipes.forEach(function (pipe) {\n          pipe.end();\n        });\n\n        _this3.emit('finish');\n      }\n    };\n\n    if (chunk) {\n      this.write(chunk, encoding, writeComplete);\n    } else {\n      writeComplete();\n    }\n  },\n  // readable\n  // event readable - some data is now available\n  // event data - switch to flowing mode - feeds chunks to handler\n  // event end - no more data\n  // event close - optional, indicates upstream close\n  // event error - duh\n  read: function read(size) {\n    var buffers; // read min(buffer, size || infinity)\n\n    if (size) {\n      buffers = [];\n\n      while (size && this.buffers.length && !this.buffers[0].eod) {\n        var first = this.buffers[0];\n        var buffer = first.read(size);\n        size -= buffer.length;\n        buffers.push(buffer);\n\n        if (first.eod && first.full) {\n          this.buffers.shift();\n        }\n      }\n\n      return Buffer.concat(buffers);\n    }\n\n    buffers = this.buffers.map(function (buf) {\n      return buf.toBuffer();\n    }).filter(Boolean);\n    this.buffers = [];\n    return Buffer.concat(buffers);\n  },\n  setEncoding: function setEncoding(encoding) {\n    // causes stream.read or stream.on('data) to return strings of encoding instead of Buffer objects\n    this.encoding = encoding;\n  },\n  pause: function pause() {\n    this.paused = true;\n  },\n  resume: function resume() {\n    this.paused = false;\n  },\n  isPaused: function isPaused() {\n    return !!this.paused;\n  },\n  pipe: function pipe(destination) {\n    // add destination to pipe list & write current buffer\n    this.pipes.push(destination);\n\n    if (!this.paused && this.buffers.length) {\n      this.end();\n    }\n  },\n  unpipe: function unpipe(destination) {\n    // remove destination from pipe list\n    this.pipes = this.pipes.filter(function (pipe) {\n      return pipe !== destination;\n    });\n  },\n  unshift: function unshift()\n  /* chunk */\n  {\n    // some numpty has read some data that's not for them and they want to put it back!\n    // Might implement this some day\n    throw new Error('Not Implemented');\n  },\n  wrap: function wrap()\n  /* stream */\n  {\n    // not implemented\n    throw new Error('Not Implemented');\n  }\n});\nmodule.exports = StreamBuf;","map":{"version":3,"sources":["../../../lib/utils/stream-buf.js"],"names":["Stream","require","utils","StringBuf","StringChunk","target","targetOffset","offset","length","Buffer","StringBufChunk","BufferChunk","ReadWriteBuf","buf","size","chunk","Math","StreamBuf","options","toBuffer","rwBuf","_getWritableBuffer","last","_pipe","write","pipe","resolve","Promise","_writeToBuffers","inPos","inLen","buffer","encoding","callback","data","process","cork","_flush","uncork","end","writeComplete","read","buffers","first","setEncoding","pause","resume","isPaused","unpipe","unshift","wrap","module"],"mappings":"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","sourcesContent":["/* eslint-disable max-classes-per-file */\r\nconst Stream = require('readable-stream');\r\n\r\nconst utils = require('./utils');\r\nconst StringBuf = require('./string-buf');\r\n\r\n// =============================================================================\r\n// data chunks - encapsulating incoming data\r\nclass StringChunk {\r\n  constructor(data, encoding) {\r\n    this._data = data;\r\n    this._encoding = encoding;\r\n  }\r\n\r\n  get length() {\r\n    return this.toBuffer().length;\r\n  }\r\n\r\n  // copy to target buffer\r\n  copy(target, targetOffset, offset, length) {\r\n    return this.toBuffer().copy(target, targetOffset, offset, length);\r\n  }\r\n\r\n  toBuffer() {\r\n    if (!this._buffer) {\r\n      this._buffer = Buffer.from(this._data, this._encoding);\r\n    }\r\n    return this._buffer;\r\n  }\r\n}\r\n\r\nclass StringBufChunk {\r\n  constructor(data) {\r\n    this._data = data;\r\n  }\r\n\r\n  get length() {\r\n    return this._data.length;\r\n  }\r\n\r\n  // copy to target buffer\r\n  copy(target, targetOffset, offset, length) {\r\n    // eslint-disable-next-line no-underscore-dangle\r\n    return this._data._buf.copy(target, targetOffset, offset, length);\r\n  }\r\n\r\n  toBuffer() {\r\n    return this._data.toBuffer();\r\n  }\r\n}\r\n\r\nclass BufferChunk {\r\n  constructor(data) {\r\n    this._data = data;\r\n  }\r\n\r\n  get length() {\r\n    return this._data.length;\r\n  }\r\n\r\n  // copy to target buffer\r\n  copy(target, targetOffset, offset, length) {\r\n    this._data.copy(target, targetOffset, offset, length);\r\n  }\r\n\r\n  toBuffer() {\r\n    return this._data;\r\n  }\r\n}\r\n\r\n// =============================================================================\r\n// ReadWriteBuf - a single buffer supporting simple read-write\r\nclass ReadWriteBuf {\r\n  constructor(size) {\r\n    this.size = size;\r\n    // the buffer\r\n    this.buffer = Buffer.alloc(size);\r\n    // read index\r\n    this.iRead = 0;\r\n    // write index\r\n    this.iWrite = 0;\r\n  }\r\n\r\n  toBuffer() {\r\n    if (this.iRead === 0 && this.iWrite === this.size) {\r\n      return this.buffer;\r\n    }\r\n\r\n    const buf = Buffer.alloc(this.iWrite - this.iRead);\r\n    this.buffer.copy(buf, 0, this.iRead, this.iWrite);\r\n    return buf;\r\n  }\r\n\r\n  get length() {\r\n    return this.iWrite - this.iRead;\r\n  }\r\n\r\n  get eod() {\r\n    return this.iRead === this.iWrite;\r\n  }\r\n\r\n  get full() {\r\n    return this.iWrite === this.size;\r\n  }\r\n\r\n  read(size) {\r\n    let buf;\r\n    // read size bytes from buffer and return buffer\r\n    if (size === 0) {\r\n      // special case - return null if no data requested\r\n      return null;\r\n    }\r\n\r\n    if (size === undefined || size >= this.length) {\r\n      // if no size specified or size is at least what we have then return all of the bytes\r\n      buf = this.toBuffer();\r\n      this.iRead = this.iWrite;\r\n      return buf;\r\n    }\r\n\r\n    // otherwise return a chunk\r\n    buf = Buffer.alloc(size);\r\n    this.buffer.copy(buf, 0, this.iRead, size);\r\n    this.iRead += size;\r\n    return buf;\r\n  }\r\n\r\n  write(chunk, offset, length) {\r\n    // write as many bytes from data from optional source offset\r\n    // and return number of bytes written\r\n    const size = Math.min(length, this.size - this.iWrite);\r\n    chunk.copy(this.buffer, this.iWrite, offset, offset + size);\r\n    this.iWrite += size;\r\n    return size;\r\n  }\r\n}\r\n\r\n// =============================================================================\r\n// StreamBuf - a multi-purpose read-write stream\r\n//  As MemBuf - write as much data as you like. Then call toBuffer() to consolidate\r\n//  As StreamHub - pipe to multiple writables\r\n//  As readable stream - feed data into the writable part and have some other code read from it.\r\n\r\n// Note: Not sure why but StreamBuf does not like JS \"class\" sugar. It fails the\r\n// integration tests\r\nconst StreamBuf = function(options) {\r\n  options = options || {};\r\n  this.bufSize = options.bufSize || 1024 * 1024;\r\n  this.buffers = [];\r\n\r\n  // batch mode fills a buffer completely before passing the data on\r\n  // to pipes or 'readable' event listeners\r\n  this.batch = options.batch || false;\r\n\r\n  this.corked = false;\r\n  // where in the current writable buffer we're up to\r\n  this.inPos = 0;\r\n\r\n  // where in the current readable buffer we've read up to\r\n  this.outPos = 0;\r\n\r\n  // consuming pipe streams go here\r\n  this.pipes = [];\r\n\r\n  // controls emit('data')\r\n  this.paused = false;\r\n\r\n  this.encoding = null;\r\n};\r\n\r\nutils.inherits(StreamBuf, Stream.Duplex, {\r\n  toBuffer() {\r\n    switch (this.buffers.length) {\r\n      case 0:\r\n        return null;\r\n      case 1:\r\n        return this.buffers[0].toBuffer();\r\n      default:\r\n        return Buffer.concat(this.buffers.map(rwBuf => rwBuf.toBuffer()));\r\n    }\r\n  },\r\n\r\n  // writable\r\n  // event drain - if write returns false (which it won't), indicates when safe to write again.\r\n  // finish - end() has been called\r\n  // pipe(src) - pipe() has been called on readable\r\n  // unpipe(src) - unpipe() has been called on readable\r\n  // error - duh\r\n\r\n  _getWritableBuffer() {\r\n    if (this.buffers.length) {\r\n      const last = this.buffers[this.buffers.length - 1];\r\n      if (!last.full) {\r\n        return last;\r\n      }\r\n    }\r\n    const buf = new ReadWriteBuf(this.bufSize);\r\n    this.buffers.push(buf);\r\n    return buf;\r\n  },\r\n\r\n  async _pipe(chunk) {\r\n    const write = function(pipe) {\r\n      return new Promise(resolve => {\r\n        pipe.write(chunk.toBuffer(), () => {\r\n          resolve();\r\n        });\r\n      });\r\n    };\r\n    await Promise.all(this.pipes.map(write));\r\n  },\r\n  _writeToBuffers(chunk) {\r\n    let inPos = 0;\r\n    const inLen = chunk.length;\r\n    while (inPos < inLen) {\r\n      // find writable buffer\r\n      const buffer = this._getWritableBuffer();\r\n\r\n      // write some data\r\n      inPos += buffer.write(chunk, inPos, inLen - inPos);\r\n    }\r\n  },\r\n  async write(data, encoding, callback) {\r\n    if (encoding instanceof Function) {\r\n      callback = encoding;\r\n      encoding = 'utf8';\r\n    }\r\n    callback = callback || utils.nop;\r\n\r\n    // encapsulate data into a chunk\r\n    let chunk;\r\n    if (data instanceof StringBuf) {\r\n      chunk = new StringBufChunk(data);\r\n    } else if (data instanceof Buffer) {\r\n      chunk = new BufferChunk(data);\r\n    } else if (typeof data === 'string' || data instanceof String || data instanceof ArrayBuffer) {\r\n      chunk = new StringChunk(data, encoding);\r\n    } else {\r\n      throw new Error('Chunk must be one of type String, Buffer or StringBuf.');\r\n    }\r\n\r\n    // now, do something with the chunk\r\n    if (this.pipes.length) {\r\n      if (this.batch) {\r\n        this._writeToBuffers(chunk);\r\n        while (!this.corked && this.buffers.length > 1) {\r\n          this._pipe(this.buffers.shift());\r\n        }\r\n      } else if (!this.corked) {\r\n        await this._pipe(chunk);\r\n        callback();\r\n      } else {\r\n        this._writeToBuffers(chunk);\r\n        process.nextTick(callback);\r\n      }\r\n    } else {\r\n      if (!this.paused) {\r\n        this.emit('data', chunk.toBuffer());\r\n      }\r\n\r\n      this._writeToBuffers(chunk);\r\n      this.emit('readable');\r\n    }\r\n\r\n    return true;\r\n  },\r\n  cork() {\r\n    this.corked = true;\r\n  },\r\n  _flush(/* destination */) {\r\n    // if we have comsumers...\r\n    if (this.pipes.length) {\r\n      // and there's stuff not written\r\n      while (this.buffers.length) {\r\n        this._pipe(this.buffers.shift());\r\n      }\r\n    }\r\n  },\r\n  uncork() {\r\n    this.corked = false;\r\n    this._flush();\r\n  },\r\n  end(chunk, encoding, callback) {\r\n    const writeComplete = error => {\r\n      if (error) {\r\n        callback(error);\r\n      } else {\r\n        this._flush();\r\n        this.pipes.forEach(pipe => {\r\n          pipe.end();\r\n        });\r\n        this.emit('finish');\r\n      }\r\n    };\r\n    if (chunk) {\r\n      this.write(chunk, encoding, writeComplete);\r\n    } else {\r\n      writeComplete();\r\n    }\r\n  },\r\n\r\n  // readable\r\n  // event readable - some data is now available\r\n  // event data - switch to flowing mode - feeds chunks to handler\r\n  // event end - no more data\r\n  // event close - optional, indicates upstream close\r\n  // event error - duh\r\n  read(size) {\r\n    let buffers;\r\n    // read min(buffer, size || infinity)\r\n    if (size) {\r\n      buffers = [];\r\n      while (size && this.buffers.length && !this.buffers[0].eod) {\r\n        const first = this.buffers[0];\r\n        const buffer = first.read(size);\r\n        size -= buffer.length;\r\n        buffers.push(buffer);\r\n        if (first.eod && first.full) {\r\n          this.buffers.shift();\r\n        }\r\n      }\r\n      return Buffer.concat(buffers);\r\n    }\r\n\r\n    buffers = this.buffers.map(buf => buf.toBuffer()).filter(Boolean);\r\n    this.buffers = [];\r\n    return Buffer.concat(buffers);\r\n  },\r\n  setEncoding(encoding) {\r\n    // causes stream.read or stream.on('data) to return strings of encoding instead of Buffer objects\r\n    this.encoding = encoding;\r\n  },\r\n  pause() {\r\n    this.paused = true;\r\n  },\r\n  resume() {\r\n    this.paused = false;\r\n  },\r\n  isPaused() {\r\n    return !!this.paused;\r\n  },\r\n  pipe(destination) {\r\n    // add destination to pipe list & write current buffer\r\n    this.pipes.push(destination);\r\n    if (!this.paused && this.buffers.length) {\r\n      this.end();\r\n    }\r\n  },\r\n  unpipe(destination) {\r\n    // remove destination from pipe list\r\n    this.pipes = this.pipes.filter(pipe => pipe !== destination);\r\n  },\r\n  unshift(/* chunk */) {\r\n    // some numpty has read some data that's not for them and they want to put it back!\r\n    // Might implement this some day\r\n    throw new Error('Not Implemented');\r\n  },\r\n  wrap(/* stream */) {\r\n    // not implemented\r\n    throw new Error('Not Implemented');\r\n  },\r\n});\r\n\r\nmodule.exports = StreamBuf;\r\n"]},"metadata":{},"sourceType":"script"}