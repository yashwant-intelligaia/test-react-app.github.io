{"ast":null,"code":"\"use strict\";\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nvar utils = require('../../../utils/utils');\n\nvar BaseXform = require('../base-xform');\n\nvar Range = require('../../../doc/range');\n\nvar Enums = require('../../../doc/enums');\n\nvar RichTextXform = require('../strings/rich-text-xform');\n\nfunction getValueType(v) {\n  if (v === null || v === undefined) {\n    return Enums.ValueType.Null;\n  }\n\n  if (v instanceof String || typeof v === 'string') {\n    return Enums.ValueType.String;\n  }\n\n  if (typeof v === 'number') {\n    return Enums.ValueType.Number;\n  }\n\n  if (typeof v === 'boolean') {\n    return Enums.ValueType.Boolean;\n  }\n\n  if (v instanceof Date) {\n    return Enums.ValueType.Date;\n  }\n\n  if (v.text && v.hyperlink) {\n    return Enums.ValueType.Hyperlink;\n  }\n\n  if (v.formula) {\n    return Enums.ValueType.Formula;\n  }\n\n  if (v.error) {\n    return Enums.ValueType.Error;\n  }\n\n  throw new Error('I could not understand type of value');\n}\n\nfunction getEffectiveCellType(cell) {\n  switch (cell.type) {\n    case Enums.ValueType.Formula:\n      return getValueType(cell.result);\n\n    default:\n      return cell.type;\n  }\n}\n\nvar CellXform = /*#__PURE__*/function (_BaseXform) {\n  _inherits(CellXform, _BaseXform);\n\n  var _super = _createSuper(CellXform);\n\n  function CellXform() {\n    var _this;\n\n    _classCallCheck(this, CellXform);\n\n    _this = _super.call(this);\n    _this.richTextXForm = new RichTextXform();\n    return _this;\n  }\n\n  _createClass(CellXform, [{\n    key: \"prepare\",\n    value: function prepare(model, options) {\n      var styleId = options.styles.addStyleModel(model.style || {}, getEffectiveCellType(model));\n\n      if (styleId) {\n        model.styleId = styleId;\n      }\n\n      if (model.comment) {\n        options.comments.push(_objectSpread(_objectSpread({}, model.comment), {}, {\n          ref: model.address\n        }));\n      }\n\n      switch (model.type) {\n        case Enums.ValueType.String:\n        case Enums.ValueType.RichText:\n          if (options.sharedStrings) {\n            model.ssId = options.sharedStrings.add(model.value);\n          }\n\n          break;\n\n        case Enums.ValueType.Date:\n          if (options.date1904) {\n            model.date1904 = true;\n          }\n\n          break;\n\n        case Enums.ValueType.Hyperlink:\n          if (options.sharedStrings && model.text !== undefined && model.text !== null) {\n            model.ssId = options.sharedStrings.add(model.text);\n          }\n\n          options.hyperlinks.push({\n            address: model.address,\n            target: model.hyperlink,\n            tooltip: model.tooltip\n          });\n          break;\n\n        case Enums.ValueType.Merge:\n          options.merges.add(model);\n          break;\n\n        case Enums.ValueType.Formula:\n          if (options.date1904) {\n            // in case valueType is date\n            model.date1904 = true;\n          }\n\n          if (model.shareType === 'shared') {\n            model.si = options.siFormulae++;\n          }\n\n          if (model.formula) {\n            options.formulae[model.address] = model;\n          } else if (model.sharedFormula) {\n            var master = options.formulae[model.sharedFormula];\n\n            if (!master) {\n              throw new Error(\"Shared Formula master must exist above and or left of clone for cell \".concat(model.address));\n            }\n\n            if (master.si === undefined) {\n              master.shareType = 'shared';\n              master.si = options.siFormulae++;\n              master.range = new Range(master.address, model.address);\n            } else if (master.range) {\n              master.range.expandToAddress(model.address);\n            }\n\n            model.si = master.si;\n          }\n\n          break;\n\n        default:\n          break;\n      }\n    }\n  }, {\n    key: \"renderFormula\",\n    value: function renderFormula(xmlStream, model) {\n      var attrs = null;\n\n      switch (model.shareType) {\n        case 'shared':\n          attrs = {\n            t: 'shared',\n            ref: model.ref || model.range.range,\n            si: model.si\n          };\n          break;\n\n        case 'array':\n          attrs = {\n            t: 'array',\n            ref: model.ref\n          };\n          break;\n\n        default:\n          if (model.si !== undefined) {\n            attrs = {\n              t: 'shared',\n              si: model.si\n            };\n          }\n\n          break;\n      }\n\n      switch (getValueType(model.result)) {\n        case Enums.ValueType.Null:\n          // ?\n          xmlStream.leafNode('f', attrs, model.formula);\n          break;\n\n        case Enums.ValueType.String:\n          // oddly, formula results don't ever use shared strings\n          xmlStream.addAttribute('t', 'str');\n          xmlStream.leafNode('f', attrs, model.formula);\n          xmlStream.leafNode('v', null, model.result);\n          break;\n\n        case Enums.ValueType.Number:\n          xmlStream.leafNode('f', attrs, model.formula);\n          xmlStream.leafNode('v', null, model.result);\n          break;\n\n        case Enums.ValueType.Boolean:\n          xmlStream.addAttribute('t', 'b');\n          xmlStream.leafNode('f', attrs, model.formula);\n          xmlStream.leafNode('v', null, model.result ? 1 : 0);\n          break;\n\n        case Enums.ValueType.Error:\n          xmlStream.addAttribute('t', 'e');\n          xmlStream.leafNode('f', attrs, model.formula);\n          xmlStream.leafNode('v', null, model.result.error);\n          break;\n\n        case Enums.ValueType.Date:\n          xmlStream.leafNode('f', attrs, model.formula);\n          xmlStream.leafNode('v', null, utils.dateToExcel(model.result, model.date1904));\n          break;\n        // case Enums.ValueType.Hyperlink: // ??\n        // case Enums.ValueType.Formula:\n\n        default:\n          throw new Error('I could not understand type of value');\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render(xmlStream, model) {\n      var _this2 = this;\n\n      if (model.type === Enums.ValueType.Null && !model.styleId) {\n        // if null and no style, exit\n        return;\n      }\n\n      xmlStream.openNode('c');\n      xmlStream.addAttribute('r', model.address);\n\n      if (model.styleId) {\n        xmlStream.addAttribute('s', model.styleId);\n      }\n\n      switch (model.type) {\n        case Enums.ValueType.Null:\n          break;\n\n        case Enums.ValueType.Number:\n          xmlStream.leafNode('v', null, model.value);\n          break;\n\n        case Enums.ValueType.Boolean:\n          xmlStream.addAttribute('t', 'b');\n          xmlStream.leafNode('v', null, model.value ? '1' : '0');\n          break;\n\n        case Enums.ValueType.Error:\n          xmlStream.addAttribute('t', 'e');\n          xmlStream.leafNode('v', null, model.value.error);\n          break;\n\n        case Enums.ValueType.String:\n        case Enums.ValueType.RichText:\n          if (model.ssId !== undefined) {\n            xmlStream.addAttribute('t', 's');\n            xmlStream.leafNode('v', null, model.ssId);\n          } else if (model.value && model.value.richText) {\n            xmlStream.addAttribute('t', 'inlineStr');\n            xmlStream.openNode('is');\n            model.value.richText.forEach(function (text) {\n              _this2.richTextXForm.render(xmlStream, text);\n            });\n            xmlStream.closeNode('is');\n          } else {\n            xmlStream.addAttribute('t', 'str');\n            xmlStream.leafNode('v', null, model.value);\n          }\n\n          break;\n\n        case Enums.ValueType.Date:\n          xmlStream.leafNode('v', null, utils.dateToExcel(model.value, model.date1904));\n          break;\n\n        case Enums.ValueType.Hyperlink:\n          if (model.ssId !== undefined) {\n            xmlStream.addAttribute('t', 's');\n            xmlStream.leafNode('v', null, model.ssId);\n          } else {\n            xmlStream.addAttribute('t', 'str');\n            xmlStream.leafNode('v', null, model.text);\n          }\n\n          break;\n\n        case Enums.ValueType.Formula:\n          this.renderFormula(xmlStream, model);\n          break;\n\n        case Enums.ValueType.Merge:\n          // nothing to add\n          break;\n\n        default:\n          break;\n      }\n\n      xmlStream.closeNode(); // </c>\n    }\n  }, {\n    key: \"parseOpen\",\n    value: function parseOpen(node) {\n      if (this.parser) {\n        this.parser.parseOpen(node);\n        return true;\n      }\n\n      switch (node.name) {\n        case 'c':\n          // const address = colCache.decodeAddress(node.attributes.r);\n          this.model = {\n            address: node.attributes.r\n          };\n          this.t = node.attributes.t;\n\n          if (node.attributes.s) {\n            this.model.styleId = parseInt(node.attributes.s, 10);\n          }\n\n          return true;\n\n        case 'f':\n          this.currentNode = 'f';\n          this.model.si = node.attributes.si;\n          this.model.shareType = node.attributes.t;\n          this.model.ref = node.attributes.ref;\n          return true;\n\n        case 'v':\n          this.currentNode = 'v';\n          return true;\n\n        case 't':\n          this.currentNode = 't';\n          return true;\n\n        case 'r':\n          this.parser = this.richTextXForm;\n          this.parser.parseOpen(node);\n          return true;\n\n        default:\n          return false;\n      }\n    }\n  }, {\n    key: \"parseText\",\n    value: function parseText(text) {\n      if (this.parser) {\n        this.parser.parseText(text);\n        return;\n      }\n\n      switch (this.currentNode) {\n        case 'f':\n          this.model.formula = this.model.formula ? this.model.formula + text : text;\n          break;\n\n        case 'v':\n        case 't':\n          if (this.model.value && this.model.value.richText) {\n            this.model.value.richText.text = this.model.value.richText.text ? this.model.value.richText.text + text : text;\n          } else {\n            this.model.value = this.model.value ? this.model.value + text : text;\n          }\n\n          break;\n\n        default:\n          break;\n      }\n    }\n  }, {\n    key: \"parseClose\",\n    value: function parseClose(name) {\n      switch (name) {\n        case 'c':\n          {\n            var model = this.model; // first guess on cell type\n\n            if (model.formula || model.shareType) {\n              model.type = Enums.ValueType.Formula;\n\n              if (model.value) {\n                if (this.t === 'str') {\n                  model.result = utils.xmlDecode(model.value);\n                } else if (this.t === 'b') {\n                  model.result = parseInt(model.value, 10) !== 0;\n                } else if (this.t === 'e') {\n                  model.result = {\n                    error: model.value\n                  };\n                } else {\n                  model.result = parseFloat(model.value);\n                }\n\n                model.value = undefined;\n              }\n            } else if (model.value !== undefined) {\n              switch (this.t) {\n                case 's':\n                  model.type = Enums.ValueType.String;\n                  model.value = parseInt(model.value, 10);\n                  break;\n\n                case 'str':\n                  model.type = Enums.ValueType.String;\n                  model.value = utils.xmlDecode(model.value);\n                  break;\n\n                case 'inlineStr':\n                  model.type = Enums.ValueType.String;\n                  break;\n\n                case 'b':\n                  model.type = Enums.ValueType.Boolean;\n                  model.value = parseInt(model.value, 10) !== 0;\n                  break;\n\n                case 'e':\n                  model.type = Enums.ValueType.Error;\n                  model.value = {\n                    error: model.value\n                  };\n                  break;\n\n                default:\n                  model.type = Enums.ValueType.Number;\n                  model.value = parseFloat(model.value);\n                  break;\n              }\n            } else if (model.styleId) {\n              model.type = Enums.ValueType.Null;\n            } else {\n              model.type = Enums.ValueType.Merge;\n            }\n\n            return false;\n          }\n\n        case 'f':\n        case 'v':\n        case 'is':\n          this.currentNode = undefined;\n          return true;\n\n        case 't':\n          if (this.parser) {\n            this.parser.parseClose(name);\n            return true;\n          }\n\n          this.currentNode = undefined;\n          return true;\n\n        case 'r':\n          this.model.value = this.model.value || {};\n          this.model.value.richText = this.model.value.richText || [];\n          this.model.value.richText.push(this.parser.model);\n          this.parser = undefined;\n          this.currentNode = undefined;\n          return true;\n\n        default:\n          if (this.parser) {\n            this.parser.parseClose(name);\n            return true;\n          }\n\n          return false;\n      }\n    }\n  }, {\n    key: \"reconcile\",\n    value: function reconcile(model, options) {\n      var style = model.styleId && options.styles && options.styles.getStyleModel(model.styleId);\n\n      if (style) {\n        model.style = style;\n      }\n\n      if (model.styleId !== undefined) {\n        model.styleId = undefined;\n      }\n\n      switch (model.type) {\n        case Enums.ValueType.String:\n          if (typeof model.value === 'number') {\n            if (options.sharedStrings) {\n              model.value = options.sharedStrings.getString(model.value);\n            }\n          }\n\n          if (model.value.richText) {\n            model.type = Enums.ValueType.RichText;\n          }\n\n          break;\n\n        case Enums.ValueType.Number:\n          if (style && utils.isDateFmt(style.numFmt)) {\n            model.type = Enums.ValueType.Date;\n            model.value = utils.excelToDate(model.value, options.date1904);\n          }\n\n          break;\n\n        case Enums.ValueType.Formula:\n          if (model.result !== undefined && style && utils.isDateFmt(style.numFmt)) {\n            model.result = utils.excelToDate(model.result, options.date1904);\n          }\n\n          if (model.shareType === 'shared') {\n            if (model.ref) {\n              // master\n              options.formulae[model.si] = model.address;\n            } else {\n              // slave\n              model.sharedFormula = options.formulae[model.si];\n              delete model.shareType;\n            }\n\n            delete model.si;\n          }\n\n          break;\n\n        default:\n          break;\n      } // look for hyperlink\n\n\n      var hyperlink = options.hyperlinkMap[model.address];\n\n      if (hyperlink) {\n        if (model.type === Enums.ValueType.Formula) {\n          model.text = model.result;\n          model.result = undefined;\n        } else {\n          model.text = model.value;\n          model.value = undefined;\n        }\n\n        model.type = Enums.ValueType.Hyperlink;\n        model.hyperlink = hyperlink;\n      }\n\n      var comment = options.commentsMap && options.commentsMap[model.address];\n\n      if (comment) {\n        model.comment = comment;\n      }\n    }\n  }, {\n    key: \"tag\",\n    get: function get() {\n      return 'c';\n    }\n  }]);\n\n  return CellXform;\n}(BaseXform);\n\nmodule.exports = CellXform;","map":{"version":3,"sources":["../../../../../lib/xlsx/xform/sheet/cell-xform.js"],"names":["utils","require","BaseXform","Range","Enums","RichTextXform","v","cell","getValueType","CellXform","model","options","styleId","getEffectiveCellType","ref","address","target","tooltip","master","xmlStream","attrs","t","si","node","r","parseInt","text","name","error","value","parseFloat","style","hyperlink","comment","module"],"mappings":"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","sourcesContent":["const utils = require('../../../utils/utils');\r\nconst BaseXform = require('../base-xform');\r\nconst Range = require('../../../doc/range');\r\nconst Enums = require('../../../doc/enums');\r\n\r\nconst RichTextXform = require('../strings/rich-text-xform');\r\n\r\nfunction getValueType(v) {\r\n  if (v === null || v === undefined) {\r\n    return Enums.ValueType.Null;\r\n  }\r\n  if (v instanceof String || typeof v === 'string') {\r\n    return Enums.ValueType.String;\r\n  }\r\n  if (typeof v === 'number') {\r\n    return Enums.ValueType.Number;\r\n  }\r\n  if (typeof v === 'boolean') {\r\n    return Enums.ValueType.Boolean;\r\n  }\r\n  if (v instanceof Date) {\r\n    return Enums.ValueType.Date;\r\n  }\r\n  if (v.text && v.hyperlink) {\r\n    return Enums.ValueType.Hyperlink;\r\n  }\r\n  if (v.formula) {\r\n    return Enums.ValueType.Formula;\r\n  }\r\n  if (v.error) {\r\n    return Enums.ValueType.Error;\r\n  }\r\n  throw new Error('I could not understand type of value');\r\n}\r\n\r\nfunction getEffectiveCellType(cell) {\r\n  switch (cell.type) {\r\n    case Enums.ValueType.Formula:\r\n      return getValueType(cell.result);\r\n    default:\r\n      return cell.type;\r\n  }\r\n}\r\n\r\nclass CellXform extends BaseXform {\r\n  constructor() {\r\n    super();\r\n\r\n    this.richTextXForm = new RichTextXform();\r\n  }\r\n\r\n  get tag() {\r\n    return 'c';\r\n  }\r\n\r\n  prepare(model, options) {\r\n    const styleId = options.styles.addStyleModel(model.style || {}, getEffectiveCellType(model));\r\n    if (styleId) {\r\n      model.styleId = styleId;\r\n    }\r\n\r\n    if (model.comment) {\r\n      options.comments.push({...model.comment, ref: model.address});\r\n    }\r\n\r\n    switch (model.type) {\r\n      case Enums.ValueType.String:\r\n      case Enums.ValueType.RichText:\r\n        if (options.sharedStrings) {\r\n          model.ssId = options.sharedStrings.add(model.value);\r\n        }\r\n        break;\r\n\r\n      case Enums.ValueType.Date:\r\n        if (options.date1904) {\r\n          model.date1904 = true;\r\n        }\r\n        break;\r\n\r\n      case Enums.ValueType.Hyperlink:\r\n        if (options.sharedStrings && model.text !== undefined && model.text !== null) {\r\n          model.ssId = options.sharedStrings.add(model.text);\r\n        }\r\n        options.hyperlinks.push({\r\n          address: model.address,\r\n          target: model.hyperlink,\r\n          tooltip: model.tooltip,\r\n        });\r\n        break;\r\n\r\n      case Enums.ValueType.Merge:\r\n        options.merges.add(model);\r\n        break;\r\n\r\n      case Enums.ValueType.Formula:\r\n        if (options.date1904) {\r\n          // in case valueType is date\r\n          model.date1904 = true;\r\n        }\r\n\r\n        if (model.shareType === 'shared') {\r\n          model.si = options.siFormulae++;\r\n        }\r\n\r\n        if (model.formula) {\r\n          options.formulae[model.address] = model;\r\n        } else if (model.sharedFormula) {\r\n          const master = options.formulae[model.sharedFormula];\r\n          if (!master) {\r\n            throw new Error(\r\n              `Shared Formula master must exist above and or left of clone for cell ${model.address}`\r\n            );\r\n          }\r\n          if (master.si === undefined) {\r\n            master.shareType = 'shared';\r\n            master.si = options.siFormulae++;\r\n            master.range = new Range(master.address, model.address);\r\n          } else if (master.range) {\r\n            master.range.expandToAddress(model.address);\r\n          }\r\n          model.si = master.si;\r\n        }\r\n        break;\r\n\r\n      default:\r\n        break;\r\n    }\r\n  }\r\n\r\n  renderFormula(xmlStream, model) {\r\n    let attrs = null;\r\n    switch (model.shareType) {\r\n      case 'shared':\r\n        attrs = {\r\n          t: 'shared',\r\n          ref: model.ref || model.range.range,\r\n          si: model.si,\r\n        };\r\n        break;\r\n\r\n      case 'array':\r\n        attrs = {\r\n          t: 'array',\r\n          ref: model.ref,\r\n        };\r\n        break;\r\n\r\n      default:\r\n        if (model.si !== undefined) {\r\n          attrs = {\r\n            t: 'shared',\r\n            si: model.si,\r\n          };\r\n        }\r\n        break;\r\n    }\r\n\r\n    switch (getValueType(model.result)) {\r\n      case Enums.ValueType.Null: // ?\r\n        xmlStream.leafNode('f', attrs, model.formula);\r\n        break;\r\n\r\n      case Enums.ValueType.String:\r\n        // oddly, formula results don't ever use shared strings\r\n        xmlStream.addAttribute('t', 'str');\r\n        xmlStream.leafNode('f', attrs, model.formula);\r\n        xmlStream.leafNode('v', null, model.result);\r\n        break;\r\n\r\n      case Enums.ValueType.Number:\r\n        xmlStream.leafNode('f', attrs, model.formula);\r\n        xmlStream.leafNode('v', null, model.result);\r\n        break;\r\n\r\n      case Enums.ValueType.Boolean:\r\n        xmlStream.addAttribute('t', 'b');\r\n        xmlStream.leafNode('f', attrs, model.formula);\r\n        xmlStream.leafNode('v', null, model.result ? 1 : 0);\r\n        break;\r\n\r\n      case Enums.ValueType.Error:\r\n        xmlStream.addAttribute('t', 'e');\r\n        xmlStream.leafNode('f', attrs, model.formula);\r\n        xmlStream.leafNode('v', null, model.result.error);\r\n        break;\r\n\r\n      case Enums.ValueType.Date:\r\n        xmlStream.leafNode('f', attrs, model.formula);\r\n        xmlStream.leafNode('v', null, utils.dateToExcel(model.result, model.date1904));\r\n        break;\r\n\r\n      // case Enums.ValueType.Hyperlink: // ??\r\n      // case Enums.ValueType.Formula:\r\n      default:\r\n        throw new Error('I could not understand type of value');\r\n    }\r\n  }\r\n\r\n  render(xmlStream, model) {\r\n    if (model.type === Enums.ValueType.Null && !model.styleId) {\r\n      // if null and no style, exit\r\n      return;\r\n    }\r\n\r\n    xmlStream.openNode('c');\r\n    xmlStream.addAttribute('r', model.address);\r\n\r\n    if (model.styleId) {\r\n      xmlStream.addAttribute('s', model.styleId);\r\n    }\r\n\r\n    switch (model.type) {\r\n      case Enums.ValueType.Null:\r\n        break;\r\n\r\n      case Enums.ValueType.Number:\r\n        xmlStream.leafNode('v', null, model.value);\r\n        break;\r\n\r\n      case Enums.ValueType.Boolean:\r\n        xmlStream.addAttribute('t', 'b');\r\n        xmlStream.leafNode('v', null, model.value ? '1' : '0');\r\n        break;\r\n\r\n      case Enums.ValueType.Error:\r\n        xmlStream.addAttribute('t', 'e');\r\n        xmlStream.leafNode('v', null, model.value.error);\r\n        break;\r\n\r\n      case Enums.ValueType.String:\r\n      case Enums.ValueType.RichText:\r\n        if (model.ssId !== undefined) {\r\n          xmlStream.addAttribute('t', 's');\r\n          xmlStream.leafNode('v', null, model.ssId);\r\n        } else if (model.value && model.value.richText) {\r\n          xmlStream.addAttribute('t', 'inlineStr');\r\n          xmlStream.openNode('is');\r\n          model.value.richText.forEach(text => {\r\n            this.richTextXForm.render(xmlStream, text);\r\n          });\r\n          xmlStream.closeNode('is');\r\n        } else {\r\n          xmlStream.addAttribute('t', 'str');\r\n          xmlStream.leafNode('v', null, model.value);\r\n        }\r\n        break;\r\n\r\n      case Enums.ValueType.Date:\r\n        xmlStream.leafNode('v', null, utils.dateToExcel(model.value, model.date1904));\r\n        break;\r\n\r\n      case Enums.ValueType.Hyperlink:\r\n        if (model.ssId !== undefined) {\r\n          xmlStream.addAttribute('t', 's');\r\n          xmlStream.leafNode('v', null, model.ssId);\r\n        } else {\r\n          xmlStream.addAttribute('t', 'str');\r\n          xmlStream.leafNode('v', null, model.text);\r\n        }\r\n        break;\r\n\r\n      case Enums.ValueType.Formula:\r\n        this.renderFormula(xmlStream, model);\r\n        break;\r\n\r\n      case Enums.ValueType.Merge:\r\n        // nothing to add\r\n        break;\r\n\r\n      default:\r\n        break;\r\n    }\r\n\r\n    xmlStream.closeNode(); // </c>\r\n  }\r\n\r\n  parseOpen(node) {\r\n    if (this.parser) {\r\n      this.parser.parseOpen(node);\r\n      return true;\r\n    }\r\n    switch (node.name) {\r\n      case 'c':\r\n        // const address = colCache.decodeAddress(node.attributes.r);\r\n        this.model = {\r\n          address: node.attributes.r,\r\n        };\r\n        this.t = node.attributes.t;\r\n        if (node.attributes.s) {\r\n          this.model.styleId = parseInt(node.attributes.s, 10);\r\n        }\r\n        return true;\r\n\r\n      case 'f':\r\n        this.currentNode = 'f';\r\n        this.model.si = node.attributes.si;\r\n        this.model.shareType = node.attributes.t;\r\n        this.model.ref = node.attributes.ref;\r\n        return true;\r\n\r\n      case 'v':\r\n        this.currentNode = 'v';\r\n        return true;\r\n\r\n      case 't':\r\n        this.currentNode = 't';\r\n        return true;\r\n\r\n      case 'r':\r\n        this.parser = this.richTextXForm;\r\n        this.parser.parseOpen(node);\r\n        return true;\r\n\r\n      default:\r\n        return false;\r\n    }\r\n  }\r\n\r\n  parseText(text) {\r\n    if (this.parser) {\r\n      this.parser.parseText(text);\r\n      return;\r\n    }\r\n    switch (this.currentNode) {\r\n      case 'f':\r\n        this.model.formula = this.model.formula ? this.model.formula + text : text;\r\n        break;\r\n      case 'v':\r\n      case 't':\r\n        if (this.model.value && this.model.value.richText) {\r\n          this.model.value.richText.text = this.model.value.richText.text\r\n            ? this.model.value.richText.text + text\r\n            : text;\r\n        } else {\r\n          this.model.value = this.model.value ? this.model.value + text : text;\r\n        }\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n  }\r\n\r\n  parseClose(name) {\r\n    switch (name) {\r\n      case 'c': {\r\n        const {model} = this;\r\n\r\n        // first guess on cell type\r\n        if (model.formula || model.shareType) {\r\n          model.type = Enums.ValueType.Formula;\r\n          if (model.value) {\r\n            if (this.t === 'str') {\r\n              model.result = utils.xmlDecode(model.value);\r\n            } else if (this.t === 'b') {\r\n              model.result = parseInt(model.value, 10) !== 0;\r\n            } else if (this.t === 'e') {\r\n              model.result = {error: model.value};\r\n            } else {\r\n              model.result = parseFloat(model.value);\r\n            }\r\n            model.value = undefined;\r\n          }\r\n        } else if (model.value !== undefined) {\r\n          switch (this.t) {\r\n            case 's':\r\n              model.type = Enums.ValueType.String;\r\n              model.value = parseInt(model.value, 10);\r\n              break;\r\n            case 'str':\r\n              model.type = Enums.ValueType.String;\r\n              model.value = utils.xmlDecode(model.value);\r\n              break;\r\n            case 'inlineStr':\r\n              model.type = Enums.ValueType.String;\r\n              break;\r\n            case 'b':\r\n              model.type = Enums.ValueType.Boolean;\r\n              model.value = parseInt(model.value, 10) !== 0;\r\n              break;\r\n            case 'e':\r\n              model.type = Enums.ValueType.Error;\r\n              model.value = {error: model.value};\r\n              break;\r\n            default:\r\n              model.type = Enums.ValueType.Number;\r\n              model.value = parseFloat(model.value);\r\n              break;\r\n          }\r\n        } else if (model.styleId) {\r\n          model.type = Enums.ValueType.Null;\r\n        } else {\r\n          model.type = Enums.ValueType.Merge;\r\n        }\r\n        return false;\r\n      }\r\n\r\n      case 'f':\r\n      case 'v':\r\n      case 'is':\r\n        this.currentNode = undefined;\r\n        return true;\r\n\r\n      case 't':\r\n        if (this.parser) {\r\n          this.parser.parseClose(name);\r\n          return true;\r\n        }\r\n        this.currentNode = undefined;\r\n        return true;\r\n\r\n      case 'r':\r\n        this.model.value = this.model.value || {};\r\n        this.model.value.richText = this.model.value.richText || [];\r\n        this.model.value.richText.push(this.parser.model);\r\n        this.parser = undefined;\r\n        this.currentNode = undefined;\r\n        return true;\r\n\r\n      default:\r\n        if (this.parser) {\r\n          this.parser.parseClose(name);\r\n          return true;\r\n        }\r\n        return false;\r\n    }\r\n  }\r\n\r\n  reconcile(model, options) {\r\n    const style = model.styleId && options.styles && options.styles.getStyleModel(model.styleId);\r\n    if (style) {\r\n      model.style = style;\r\n    }\r\n    if (model.styleId !== undefined) {\r\n      model.styleId = undefined;\r\n    }\r\n\r\n    switch (model.type) {\r\n      case Enums.ValueType.String:\r\n        if (typeof model.value === 'number') {\r\n          if (options.sharedStrings) {\r\n            model.value = options.sharedStrings.getString(model.value);\r\n          }\r\n        }\r\n        if (model.value.richText) {\r\n          model.type = Enums.ValueType.RichText;\r\n        }\r\n        break;\r\n\r\n      case Enums.ValueType.Number:\r\n        if (style && utils.isDateFmt(style.numFmt)) {\r\n          model.type = Enums.ValueType.Date;\r\n          model.value = utils.excelToDate(model.value, options.date1904);\r\n        }\r\n        break;\r\n\r\n      case Enums.ValueType.Formula:\r\n        if (model.result !== undefined && style && utils.isDateFmt(style.numFmt)) {\r\n          model.result = utils.excelToDate(model.result, options.date1904);\r\n        }\r\n        if (model.shareType === 'shared') {\r\n          if (model.ref) {\r\n            // master\r\n            options.formulae[model.si] = model.address;\r\n          } else {\r\n            // slave\r\n            model.sharedFormula = options.formulae[model.si];\r\n            delete model.shareType;\r\n          }\r\n          delete model.si;\r\n        }\r\n        break;\r\n\r\n      default:\r\n        break;\r\n    }\r\n\r\n    // look for hyperlink\r\n    const hyperlink = options.hyperlinkMap[model.address];\r\n    if (hyperlink) {\r\n      if (model.type === Enums.ValueType.Formula) {\r\n        model.text = model.result;\r\n        model.result = undefined;\r\n      } else {\r\n        model.text = model.value;\r\n        model.value = undefined;\r\n      }\r\n      model.type = Enums.ValueType.Hyperlink;\r\n      model.hyperlink = hyperlink;\r\n    }\r\n\r\n    const comment = options.commentsMap && options.commentsMap[model.address];\r\n    if (comment) {\r\n      model.comment = comment;\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = CellXform;\r\n"]},"metadata":{},"sourceType":"script"}