{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.HeaderTransformer = void 0;\n\nconst lodash_isundefined_1 = __importDefault(require(\"lodash.isundefined\"));\n\nconst lodash_isfunction_1 = __importDefault(require(\"lodash.isfunction\"));\n\nconst lodash_uniq_1 = __importDefault(require(\"lodash.uniq\"));\n\nconst lodash_groupby_1 = __importDefault(require(\"lodash.groupby\"));\n\nclass HeaderTransformer {\n  constructor(parserOptions) {\n    this.headers = null;\n    this.receivedHeaders = false;\n    this.shouldUseFirstRow = false;\n    this.processedFirstRow = false;\n    this.headersLength = 0;\n    this.parserOptions = parserOptions;\n\n    if (parserOptions.headers === true) {\n      this.shouldUseFirstRow = true;\n    } else if (Array.isArray(parserOptions.headers)) {\n      this.setHeaders(parserOptions.headers);\n    } else if (lodash_isfunction_1.default(parserOptions.headers)) {\n      this.headersTransform = parserOptions.headers;\n    }\n  }\n\n  transform(row, cb) {\n    if (!this.shouldMapRow(row)) {\n      return cb(null, {\n        row: null,\n        isValid: true\n      });\n    }\n\n    return cb(null, this.processRow(row));\n  }\n\n  shouldMapRow(row) {\n    const {\n      parserOptions\n    } = this;\n\n    if (!this.headersTransform && parserOptions.renameHeaders && !this.processedFirstRow) {\n      if (!this.receivedHeaders) {\n        throw new Error('Error renaming headers: new headers must be provided in an array');\n      }\n\n      this.processedFirstRow = true;\n      return false;\n    }\n\n    if (!this.receivedHeaders && Array.isArray(row)) {\n      if (this.headersTransform) {\n        this.setHeaders(this.headersTransform(row));\n      } else if (this.shouldUseFirstRow) {\n        this.setHeaders(row);\n      } else {\n        // dont do anything with the headers if we didnt receive a transform or shouldnt use the first row.\n        return true;\n      }\n\n      return false;\n    }\n\n    return true;\n  }\n\n  processRow(row) {\n    if (!this.headers) {\n      return {\n        row: row,\n        isValid: true\n      };\n    }\n\n    const {\n      parserOptions\n    } = this;\n\n    if (!parserOptions.discardUnmappedColumns && row.length > this.headersLength) {\n      if (!parserOptions.strictColumnHandling) {\n        throw new Error(`Unexpected Error: column header mismatch expected: ${this.headersLength} columns got: ${row.length}`);\n      }\n\n      return {\n        row: row,\n        isValid: false,\n        reason: `Column header mismatch expected: ${this.headersLength} columns got: ${row.length}`\n      };\n    }\n\n    if (parserOptions.strictColumnHandling && row.length < this.headersLength) {\n      return {\n        row: row,\n        isValid: false,\n        reason: `Column header mismatch expected: ${this.headersLength} columns got: ${row.length}`\n      };\n    }\n\n    return {\n      row: this.mapHeaders(row),\n      isValid: true\n    };\n  }\n\n  mapHeaders(row) {\n    const rowMap = {};\n    const {\n      headers,\n      headersLength\n    } = this;\n\n    for (let i = 0; i < headersLength; i += 1) {\n      const header = headers[i];\n\n      if (!lodash_isundefined_1.default(header)) {\n        const val = row[i]; // eslint-disable-next-line no-param-reassign\n\n        if (lodash_isundefined_1.default(val)) {\n          rowMap[header] = '';\n        } else {\n          rowMap[header] = val;\n        }\n      }\n    }\n\n    return rowMap;\n  }\n\n  setHeaders(headers) {\n    var _a;\n\n    const filteredHeaders = headers.filter(h => !!h);\n\n    if (lodash_uniq_1.default(filteredHeaders).length !== filteredHeaders.length) {\n      const grouped = lodash_groupby_1.default(filteredHeaders);\n      const duplicates = Object.keys(grouped).filter(dup => grouped[dup].length > 1);\n      throw new Error(`Duplicate headers found ${JSON.stringify(duplicates)}`);\n    }\n\n    this.headers = headers;\n    this.receivedHeaders = true;\n    this.headersLength = ((_a = this.headers) === null || _a === void 0 ? void 0 : _a.length) || 0;\n  }\n\n}\n\nexports.HeaderTransformer = HeaderTransformer;","map":{"version":3,"sources":["../../../src/transforms/HeaderTransformer.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HeaderTransformer = void 0;\nconst lodash_isundefined_1 = __importDefault(require(\"lodash.isundefined\"));\nconst lodash_isfunction_1 = __importDefault(require(\"lodash.isfunction\"));\nconst lodash_uniq_1 = __importDefault(require(\"lodash.uniq\"));\nconst lodash_groupby_1 = __importDefault(require(\"lodash.groupby\"));\nclass HeaderTransformer {\n    constructor(parserOptions) {\n        this.headers = null;\n        this.receivedHeaders = false;\n        this.shouldUseFirstRow = false;\n        this.processedFirstRow = false;\n        this.headersLength = 0;\n        this.parserOptions = parserOptions;\n        if (parserOptions.headers === true) {\n            this.shouldUseFirstRow = true;\n        }\n        else if (Array.isArray(parserOptions.headers)) {\n            this.setHeaders(parserOptions.headers);\n        }\n        else if (lodash_isfunction_1.default(parserOptions.headers)) {\n            this.headersTransform = parserOptions.headers;\n        }\n    }\n    transform(row, cb) {\n        if (!this.shouldMapRow(row)) {\n            return cb(null, { row: null, isValid: true });\n        }\n        return cb(null, this.processRow(row));\n    }\n    shouldMapRow(row) {\n        const { parserOptions } = this;\n        if (!this.headersTransform && parserOptions.renameHeaders && !this.processedFirstRow) {\n            if (!this.receivedHeaders) {\n                throw new Error('Error renaming headers: new headers must be provided in an array');\n            }\n            this.processedFirstRow = true;\n            return false;\n        }\n        if (!this.receivedHeaders && Array.isArray(row)) {\n            if (this.headersTransform) {\n                this.setHeaders(this.headersTransform(row));\n            }\n            else if (this.shouldUseFirstRow) {\n                this.setHeaders(row);\n            }\n            else {\n                // dont do anything with the headers if we didnt receive a transform or shouldnt use the first row.\n                return true;\n            }\n            return false;\n        }\n        return true;\n    }\n    processRow(row) {\n        if (!this.headers) {\n            return { row: row, isValid: true };\n        }\n        const { parserOptions } = this;\n        if (!parserOptions.discardUnmappedColumns && row.length > this.headersLength) {\n            if (!parserOptions.strictColumnHandling) {\n                throw new Error(`Unexpected Error: column header mismatch expected: ${this.headersLength} columns got: ${row.length}`);\n            }\n            return {\n                row: row,\n                isValid: false,\n                reason: `Column header mismatch expected: ${this.headersLength} columns got: ${row.length}`,\n            };\n        }\n        if (parserOptions.strictColumnHandling && row.length < this.headersLength) {\n            return {\n                row: row,\n                isValid: false,\n                reason: `Column header mismatch expected: ${this.headersLength} columns got: ${row.length}`,\n            };\n        }\n        return { row: this.mapHeaders(row), isValid: true };\n    }\n    mapHeaders(row) {\n        const rowMap = {};\n        const { headers, headersLength } = this;\n        for (let i = 0; i < headersLength; i += 1) {\n            const header = headers[i];\n            if (!lodash_isundefined_1.default(header)) {\n                const val = row[i];\n                // eslint-disable-next-line no-param-reassign\n                if (lodash_isundefined_1.default(val)) {\n                    rowMap[header] = '';\n                }\n                else {\n                    rowMap[header] = val;\n                }\n            }\n        }\n        return rowMap;\n    }\n    setHeaders(headers) {\n        var _a;\n        const filteredHeaders = headers.filter((h) => !!h);\n        if (lodash_uniq_1.default(filteredHeaders).length !== filteredHeaders.length) {\n            const grouped = lodash_groupby_1.default(filteredHeaders);\n            const duplicates = Object.keys(grouped).filter((dup) => grouped[dup].length > 1);\n            throw new Error(`Duplicate headers found ${JSON.stringify(duplicates)}`);\n        }\n        this.headers = headers;\n        this.receivedHeaders = true;\n        this.headersLength = ((_a = this.headers) === null || _a === void 0 ? void 0 : _a.length) || 0;\n    }\n}\nexports.HeaderTransformer = HeaderTransformer;\n//# sourceMappingURL=HeaderTransformer.js.map"]},"metadata":{},"sourceType":"script"}