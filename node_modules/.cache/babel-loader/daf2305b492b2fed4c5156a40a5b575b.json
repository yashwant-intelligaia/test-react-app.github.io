{"ast":null,"code":"'use strict';\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nvar _ = require('../utils/under-dash');\n\nvar colCache = require('../utils/col-cache');\n\nvar CellMatrix = require('../utils/cell-matrix');\n\nvar Range = require('./range');\n\nvar rangeRegexp = /[$](\\w+)[$](\\d+)(:[$](\\w+)[$](\\d+))?/;\n\nvar DefinedNames = /*#__PURE__*/function () {\n  function DefinedNames() {\n    _classCallCheck(this, DefinedNames);\n\n    this.matrixMap = {};\n  }\n\n  _createClass(DefinedNames, [{\n    key: \"getMatrix\",\n    value: function getMatrix(name) {\n      var matrix = this.matrixMap[name] || (this.matrixMap[name] = new CellMatrix());\n      return matrix;\n    } // add a name to a cell. locStr in the form SheetName!$col$row or SheetName!$c1$r1:$c2:$r2\n\n  }, {\n    key: \"add\",\n    value: function add(locStr, name) {\n      var location = colCache.decodeEx(locStr);\n      this.addEx(location, name);\n    }\n  }, {\n    key: \"addEx\",\n    value: function addEx(location, name) {\n      var matrix = this.getMatrix(name);\n\n      if (location.top) {\n        for (var col = location.left; col <= location.right; col++) {\n          for (var row = location.top; row <= location.bottom; row++) {\n            var address = {\n              sheetName: location.sheetName,\n              address: colCache.n2l(col) + row,\n              row: row,\n              col: col\n            };\n            matrix.addCellEx(address);\n          }\n        }\n      } else {\n        matrix.addCellEx(location);\n      }\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(locStr, name) {\n      var location = colCache.decodeEx(locStr);\n      this.removeEx(location, name);\n    }\n  }, {\n    key: \"removeEx\",\n    value: function removeEx(location, name) {\n      var matrix = this.getMatrix(name);\n      matrix.removeCellEx(location);\n    }\n  }, {\n    key: \"removeAllNames\",\n    value: function removeAllNames(location) {\n      _.each(this.matrixMap, function (matrix) {\n        matrix.removeCellEx(location);\n      });\n    }\n  }, {\n    key: \"forEach\",\n    value: function forEach(callback) {\n      _.each(this.matrixMap, function (matrix, name) {\n        matrix.forEach(function (cell) {\n          callback(name, cell);\n        });\n      });\n    } // get all the names of a cell\n\n  }, {\n    key: \"getNames\",\n    value: function getNames(addressStr) {\n      return this.getNamesEx(colCache.decodeEx(addressStr));\n    }\n  }, {\n    key: \"getNamesEx\",\n    value: function getNamesEx(address) {\n      return _.map(this.matrixMap, function (matrix, name) {\n        return matrix.findCellEx(address) && name;\n      }).filter(Boolean);\n    }\n  }, {\n    key: \"_explore\",\n    value: function _explore(matrix, cell) {\n      cell.mark = false;\n      var sheetName = cell.sheetName;\n      var range = new Range(cell.row, cell.col, cell.row, cell.col, sheetName);\n      var x;\n      var y; // grow vertical - only one col to worry about\n\n      function vGrow(yy, edge) {\n        var c = matrix.findCellAt(sheetName, yy, cell.col);\n\n        if (!c || !c.mark) {\n          return false;\n        }\n\n        range[edge] = yy;\n        c.mark = false;\n        return true;\n      }\n\n      for (y = cell.row - 1; vGrow(y, 'top'); y--) {\n        ;\n      }\n\n      for (y = cell.row + 1; vGrow(y, 'bottom'); y++) {\n        ;\n      } // grow horizontal - ensure all rows can grow\n\n\n      function hGrow(xx, edge) {\n        var cells = [];\n\n        for (y = range.top; y <= range.bottom; y++) {\n          var c = matrix.findCellAt(sheetName, y, xx);\n\n          if (c && c.mark) {\n            cells.push(c);\n          } else {\n            return false;\n          }\n        }\n\n        range[edge] = xx;\n\n        for (var i = 0; i < cells.length; i++) {\n          cells[i].mark = false;\n        }\n\n        return true;\n      }\n\n      for (x = cell.col - 1; hGrow(x, 'left'); x--) {\n        ;\n      }\n\n      for (x = cell.col + 1; hGrow(x, 'right'); x++) {\n        ;\n      }\n\n      return range;\n    }\n  }, {\n    key: \"getRanges\",\n    value: function getRanges(name, matrix) {\n      var _this = this;\n\n      matrix = matrix || this.matrixMap[name];\n\n      if (!matrix) {\n        return {\n          name: name,\n          ranges: []\n        };\n      } // mark and sweep!\n\n\n      matrix.forEach(function (cell) {\n        cell.mark = true;\n      });\n      var ranges = matrix.map(function (cell) {\n        return cell.mark && _this._explore(matrix, cell);\n      }).filter(Boolean).map(function (range) {\n        return range.$shortRange;\n      });\n      return {\n        name: name,\n        ranges: ranges\n      };\n    }\n  }, {\n    key: \"normaliseMatrix\",\n    value: function normaliseMatrix(matrix, sheetName) {\n      // some of the cells might have shifted on specified sheet\n      // need to reassign rows, cols\n      matrix.forEachInSheet(sheetName, function (cell, row, col) {\n        if (cell) {\n          if (cell.row !== row || cell.col !== col) {\n            cell.row = row;\n            cell.col = col;\n            cell.address = colCache.n2l(col) + row;\n          }\n        }\n      });\n    }\n  }, {\n    key: \"spliceRows\",\n    value: function spliceRows(sheetName, start, numDelete, numInsert) {\n      var _this2 = this;\n\n      _.each(this.matrixMap, function (matrix) {\n        matrix.spliceRows(sheetName, start, numDelete, numInsert);\n\n        _this2.normaliseMatrix(matrix, sheetName);\n      });\n    }\n  }, {\n    key: \"spliceColumns\",\n    value: function spliceColumns(sheetName, start, numDelete, numInsert) {\n      var _this3 = this;\n\n      _.each(this.matrixMap, function (matrix) {\n        matrix.spliceColumns(sheetName, start, numDelete, numInsert);\n\n        _this3.normaliseMatrix(matrix, sheetName);\n      });\n    }\n  }, {\n    key: \"model\",\n    get: function get() {\n      var _this4 = this; // To get names per cell - just iterate over all names finding cells if they exist\n\n\n      return _.map(this.matrixMap, function (matrix, name) {\n        return _this4.getRanges(name, matrix);\n      }).filter(function (definedName) {\n        return definedName.ranges.length;\n      });\n    },\n    set: function set(value) {\n      // value is [ { name, ranges }, ... ]\n      var matrixMap = this.matrixMap = {};\n      value.forEach(function (definedName) {\n        var matrix = matrixMap[definedName.name] = new CellMatrix();\n        definedName.ranges.forEach(function (rangeStr) {\n          if (rangeRegexp.test(rangeStr.split('!').pop() || '')) {\n            matrix.addCell(rangeStr);\n          }\n        });\n      });\n    }\n  }]);\n\n  return DefinedNames;\n}();\n\nmodule.exports = DefinedNames;","map":{"version":3,"sources":["../../../lib/doc/defined-names.js"],"names":["_","require","colCache","CellMatrix","Range","rangeRegexp","DefinedNames","name","matrix","locStr","location","col","row","address","sheetName","callback","addressStr","cell","range","c","y","vGrow","cells","i","x","hGrow","ranges","start","numDelete","numInsert","definedName","value","matrixMap","rangeStr","module"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nconst _ = require('../utils/under-dash');\r\nconst colCache = require('../utils/col-cache');\r\nconst CellMatrix = require('../utils/cell-matrix');\r\nconst Range = require('./range');\r\n\r\nconst rangeRegexp = /[$](\\w+)[$](\\d+)(:[$](\\w+)[$](\\d+))?/;\r\n\r\nclass DefinedNames {\r\n  constructor() {\r\n    this.matrixMap = {};\r\n  }\r\n\r\n  getMatrix(name) {\r\n    const matrix = this.matrixMap[name] || (this.matrixMap[name] = new CellMatrix());\r\n    return matrix;\r\n  }\r\n\r\n  // add a name to a cell. locStr in the form SheetName!$col$row or SheetName!$c1$r1:$c2:$r2\r\n  add(locStr, name) {\r\n    const location = colCache.decodeEx(locStr);\r\n    this.addEx(location, name);\r\n  }\r\n\r\n  addEx(location, name) {\r\n    const matrix = this.getMatrix(name);\r\n    if (location.top) {\r\n      for (let col = location.left; col <= location.right; col++) {\r\n        for (let row = location.top; row <= location.bottom; row++) {\r\n          const address = {\r\n            sheetName: location.sheetName,\r\n            address: colCache.n2l(col) + row,\r\n            row,\r\n            col,\r\n          };\r\n\r\n          matrix.addCellEx(address);\r\n        }\r\n      }\r\n    } else {\r\n      matrix.addCellEx(location);\r\n    }\r\n  }\r\n\r\n  remove(locStr, name) {\r\n    const location = colCache.decodeEx(locStr);\r\n    this.removeEx(location, name);\r\n  }\r\n\r\n  removeEx(location, name) {\r\n    const matrix = this.getMatrix(name);\r\n    matrix.removeCellEx(location);\r\n  }\r\n\r\n  removeAllNames(location) {\r\n    _.each(this.matrixMap, matrix => {\r\n      matrix.removeCellEx(location);\r\n    });\r\n  }\r\n\r\n  forEach(callback) {\r\n    _.each(this.matrixMap, (matrix, name) => {\r\n      matrix.forEach(cell => {\r\n        callback(name, cell);\r\n      });\r\n    });\r\n  }\r\n\r\n  // get all the names of a cell\r\n  getNames(addressStr) {\r\n    return this.getNamesEx(colCache.decodeEx(addressStr));\r\n  }\r\n\r\n  getNamesEx(address) {\r\n    return _.map(this.matrixMap, (matrix, name) => matrix.findCellEx(address) && name).filter(\r\n      Boolean\r\n    );\r\n  }\r\n\r\n  _explore(matrix, cell) {\r\n    cell.mark = false;\r\n    const {sheetName} = cell;\r\n\r\n    const range = new Range(cell.row, cell.col, cell.row, cell.col, sheetName);\r\n    let x;\r\n    let y;\r\n\r\n    // grow vertical - only one col to worry about\r\n    function vGrow(yy, edge) {\r\n      const c = matrix.findCellAt(sheetName, yy, cell.col);\r\n      if (!c || !c.mark) {\r\n        return false;\r\n      }\r\n      range[edge] = yy;\r\n      c.mark = false;\r\n      return true;\r\n    }\r\n    for (y = cell.row - 1; vGrow(y, 'top'); y--);\r\n    for (y = cell.row + 1; vGrow(y, 'bottom'); y++);\r\n\r\n    // grow horizontal - ensure all rows can grow\r\n    function hGrow(xx, edge) {\r\n      const cells = [];\r\n      for (y = range.top; y <= range.bottom; y++) {\r\n        const c = matrix.findCellAt(sheetName, y, xx);\r\n        if (c && c.mark) {\r\n          cells.push(c);\r\n        } else {\r\n          return false;\r\n        }\r\n      }\r\n      range[edge] = xx;\r\n      for (let i = 0; i < cells.length; i++) {\r\n        cells[i].mark = false;\r\n      }\r\n      return true;\r\n    }\r\n    for (x = cell.col - 1; hGrow(x, 'left'); x--);\r\n    for (x = cell.col + 1; hGrow(x, 'right'); x++);\r\n\r\n    return range;\r\n  }\r\n\r\n  getRanges(name, matrix) {\r\n    matrix = matrix || this.matrixMap[name];\r\n\r\n    if (!matrix) {\r\n      return {name, ranges: []};\r\n    }\r\n\r\n    // mark and sweep!\r\n    matrix.forEach(cell => {\r\n      cell.mark = true;\r\n    });\r\n    const ranges = matrix\r\n      .map(cell => cell.mark && this._explore(matrix, cell))\r\n      .filter(Boolean)\r\n      .map(range => range.$shortRange);\r\n\r\n    return {\r\n      name,\r\n      ranges,\r\n    };\r\n  }\r\n\r\n  normaliseMatrix(matrix, sheetName) {\r\n    // some of the cells might have shifted on specified sheet\r\n    // need to reassign rows, cols\r\n    matrix.forEachInSheet(sheetName, (cell, row, col) => {\r\n      if (cell) {\r\n        if (cell.row !== row || cell.col !== col) {\r\n          cell.row = row;\r\n          cell.col = col;\r\n          cell.address = colCache.n2l(col) + row;\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  spliceRows(sheetName, start, numDelete, numInsert) {\r\n    _.each(this.matrixMap, matrix => {\r\n      matrix.spliceRows(sheetName, start, numDelete, numInsert);\r\n      this.normaliseMatrix(matrix, sheetName);\r\n    });\r\n  }\r\n\r\n  spliceColumns(sheetName, start, numDelete, numInsert) {\r\n    _.each(this.matrixMap, matrix => {\r\n      matrix.spliceColumns(sheetName, start, numDelete, numInsert);\r\n      this.normaliseMatrix(matrix, sheetName);\r\n    });\r\n  }\r\n\r\n  get model() {\r\n    // To get names per cell - just iterate over all names finding cells if they exist\r\n    return _.map(this.matrixMap, (matrix, name) => this.getRanges(name, matrix)).filter(\r\n      definedName => definedName.ranges.length\r\n    );\r\n  }\r\n\r\n  set model(value) {\r\n    // value is [ { name, ranges }, ... ]\r\n    const matrixMap = (this.matrixMap = {});\r\n    value.forEach(definedName => {\r\n      const matrix = (matrixMap[definedName.name] = new CellMatrix());\r\n      definedName.ranges.forEach(rangeStr => {\r\n        if (rangeRegexp.test(rangeStr.split('!').pop() || '')) {\r\n          matrix.addCell(rangeStr);\r\n        }\r\n      });\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = DefinedNames;\r\n"]},"metadata":{},"sourceType":"script"}