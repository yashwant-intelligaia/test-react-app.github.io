{"ast":null,"code":"\"use strict\";\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar addressRegex = /^[A-Z]+\\d+$/; // =========================================================================\n// Column Letter to Number conversion\n\nvar colCache = {\n  _dictionary: ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'],\n  _l2nFill: 0,\n  _l2n: {},\n  _n2l: [],\n  _level: function _level(n) {\n    if (n <= 26) {\n      return 1;\n    }\n\n    if (n <= 26 * 26) {\n      return 2;\n    }\n\n    return 3;\n  },\n  _fill: function _fill(level) {\n    var c;\n    var v;\n    var l1;\n    var l2;\n    var l3;\n    var n = 1;\n\n    if (level >= 4) {\n      throw new Error('Out of bounds. Excel supports columns from 1 to 16384');\n    }\n\n    if (this._l2nFill < 1 && level >= 1) {\n      while (n <= 26) {\n        c = this._dictionary[n - 1];\n        this._n2l[n] = c;\n        this._l2n[c] = n;\n        n++;\n      }\n\n      this._l2nFill = 1;\n    }\n\n    if (this._l2nFill < 2 && level >= 2) {\n      n = 27;\n\n      while (n <= 26 + 26 * 26) {\n        v = n - (26 + 1);\n        l1 = v % 26;\n        l2 = Math.floor(v / 26);\n        c = this._dictionary[l2] + this._dictionary[l1];\n        this._n2l[n] = c;\n        this._l2n[c] = n;\n        n++;\n      }\n\n      this._l2nFill = 2;\n    }\n\n    if (this._l2nFill < 3 && level >= 3) {\n      n = 26 + 26 * 26 + 1;\n\n      while (n <= 16384) {\n        v = n - (26 * 26 + 26 + 1);\n        l1 = v % 26;\n        l2 = Math.floor(v / 26) % 26;\n        l3 = Math.floor(v / (26 * 26));\n        c = this._dictionary[l3] + this._dictionary[l2] + this._dictionary[l1];\n        this._n2l[n] = c;\n        this._l2n[c] = n;\n        n++;\n      }\n\n      this._l2nFill = 3;\n    }\n  },\n  l2n: function l2n(l) {\n    if (!this._l2n[l]) {\n      this._fill(l.length);\n    }\n\n    if (!this._l2n[l]) {\n      throw new Error(\"Out of bounds. Invalid column letter: \".concat(l));\n    }\n\n    return this._l2n[l];\n  },\n  n2l: function n2l(n) {\n    if (n < 1 || n > 16384) {\n      throw new Error(\"\".concat(n, \" is out of bounds. Excel supports columns from 1 to 16384\"));\n    }\n\n    if (!this._n2l[n]) {\n      this._fill(this._level(n));\n    }\n\n    return this._n2l[n];\n  },\n  // =========================================================================\n  // Address processing\n  _hash: {},\n  // check if value looks like an address\n  validateAddress: function validateAddress(value) {\n    if (!addressRegex.test(value)) {\n      throw new Error(\"Invalid Address: \".concat(value));\n    }\n\n    return true;\n  },\n  // convert address string into structure\n  decodeAddress: function decodeAddress(value) {\n    var addr = value.length < 5 && this._hash[value];\n\n    if (addr) {\n      return addr;\n    }\n\n    var hasCol = false;\n    var col = '';\n    var colNumber = 0;\n    var hasRow = false;\n    var row = '';\n    var rowNumber = 0;\n\n    for (var i = 0, char; i < value.length; i++) {\n      char = value.charCodeAt(i); // col should before row\n\n      if (!hasRow && char >= 65 && char <= 90) {\n        // 65 = 'A'.charCodeAt(0)\n        // 90 = 'Z'.charCodeAt(0)\n        hasCol = true;\n        col += value[i]; // colNumber starts from 1\n\n        colNumber = colNumber * 26 + char - 64;\n      } else if (char >= 48 && char <= 57) {\n        // 48 = '0'.charCodeAt(0)\n        // 57 = '9'.charCodeAt(0)\n        hasRow = true;\n        row += value[i]; // rowNumber starts from 0\n\n        rowNumber = rowNumber * 10 + char - 48;\n      } else if (hasRow && hasCol && char !== 36) {\n        // 36 = '$'.charCodeAt(0)\n        break;\n      }\n    }\n\n    if (!hasCol) {\n      colNumber = undefined;\n    } else if (colNumber > 16384) {\n      throw new Error(\"Out of bounds. Invalid column letter: \".concat(col));\n    }\n\n    if (!hasRow) {\n      rowNumber = undefined;\n    } // in case $row$col\n\n\n    value = col + row;\n    var address = {\n      address: value,\n      col: colNumber,\n      row: rowNumber,\n      $col$row: \"$\".concat(col, \"$\").concat(row)\n    }; // mem fix - cache only the tl 100x100 square\n\n    if (colNumber <= 100 && rowNumber <= 100) {\n      this._hash[value] = address;\n      this._hash[address.$col$row] = address;\n    }\n\n    return address;\n  },\n  // convert r,c into structure (if only 1 arg, assume r is address string)\n  getAddress: function getAddress(r, c) {\n    if (c) {\n      var address = this.n2l(c) + r;\n      return this.decodeAddress(address);\n    }\n\n    return this.decodeAddress(r);\n  },\n  // convert [address], [tl:br] into address structures\n  decode: function decode(value) {\n    var parts = value.split(':');\n\n    if (parts.length === 2) {\n      var tl = this.decodeAddress(parts[0]);\n      var br = this.decodeAddress(parts[1]);\n      var result = {\n        top: Math.min(tl.row, br.row),\n        left: Math.min(tl.col, br.col),\n        bottom: Math.max(tl.row, br.row),\n        right: Math.max(tl.col, br.col)\n      }; // reconstruct tl, br and dimensions\n\n      result.tl = this.n2l(result.left) + result.top;\n      result.br = this.n2l(result.right) + result.bottom;\n      result.dimensions = \"\".concat(result.tl, \":\").concat(result.br);\n      return result;\n    }\n\n    return this.decodeAddress(value);\n  },\n  // convert [sheetName!][$]col[$]row[[$]col[$]row] into address or range structures\n  decodeEx: function decodeEx(value) {\n    var groups = value.match(/(?:(?:(?:'((?:[^']|'')*)')|([^'^ !]*))!)?(.*)/);\n    var sheetName = groups[1] || groups[2]; // Qouted and unqouted groups\n\n    var reference = groups[3]; // Remaining address\n\n    var parts = reference.split(':');\n\n    if (parts.length > 1) {\n      var tl = this.decodeAddress(parts[0]);\n      var br = this.decodeAddress(parts[1]);\n      var top = Math.min(tl.row, br.row);\n      var left = Math.min(tl.col, br.col);\n      var bottom = Math.max(tl.row, br.row);\n      var right = Math.max(tl.col, br.col);\n      tl = this.n2l(left) + top;\n      br = this.n2l(right) + bottom;\n      return {\n        top: top,\n        left: left,\n        bottom: bottom,\n        right: right,\n        sheetName: sheetName,\n        tl: {\n          address: tl,\n          col: left,\n          row: top,\n          $col$row: \"$\".concat(this.n2l(left), \"$\").concat(top),\n          sheetName: sheetName\n        },\n        br: {\n          address: br,\n          col: right,\n          row: bottom,\n          $col$row: \"$\".concat(this.n2l(right), \"$\").concat(bottom),\n          sheetName: sheetName\n        },\n        dimensions: \"\".concat(tl, \":\").concat(br)\n      };\n    }\n\n    if (reference.startsWith('#')) {\n      return sheetName ? {\n        sheetName: sheetName,\n        error: reference\n      } : {\n        error: reference\n      };\n    }\n\n    var address = this.decodeAddress(reference);\n    return sheetName ? _objectSpread({\n      sheetName: sheetName\n    }, address) : address;\n  },\n  // convert row,col into address string\n  encodeAddress: function encodeAddress(row, col) {\n    return colCache.n2l(col) + row;\n  },\n  // convert row,col into string address or t,l,b,r into range\n  encode: function encode() {\n    switch (arguments.length) {\n      case 2:\n        return colCache.encodeAddress(arguments[0], arguments[1]);\n\n      case 4:\n        return \"\".concat(colCache.encodeAddress(arguments[0], arguments[1]), \":\").concat(colCache.encodeAddress(arguments[2], arguments[3]));\n\n      default:\n        throw new Error('Can only encode with 2 or 4 arguments');\n    }\n  },\n  // return true if address is contained within range\n  inRange: function inRange(range, address) {\n    var _range = _slicedToArray(range, 5),\n        left = _range[0],\n        top = _range[1],\n        right = _range[3],\n        bottom = _range[4];\n\n    var _address = _slicedToArray(address, 2),\n        col = _address[0],\n        row = _address[1];\n\n    return col >= left && col <= right && row >= top && row <= bottom;\n  }\n};\nmodule.exports = colCache;","map":{"version":3,"sources":["../../../lib/utils/col-cache.js"],"names":["addressRegex","colCache","_dictionary","_l2nFill","_l2n","_n2l","_level","n","_fill","level","c","v","l1","l2","Math","l3","l2n","l","n2l","_hash","validateAddress","decodeAddress","addr","value","hasCol","col","colNumber","hasRow","row","rowNumber","i","char","address","$col$row","getAddress","decode","parts","tl","br","result","top","left","bottom","right","decodeEx","groups","sheetName","reference","dimensions","error","encodeAddress","encode","arguments","inRange","module"],"mappings":"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","sourcesContent":["const addressRegex = /^[A-Z]+\\d+$/;\r\n// =========================================================================\r\n// Column Letter to Number conversion\r\nconst colCache = {\r\n  _dictionary: [\r\n    'A',\r\n    'B',\r\n    'C',\r\n    'D',\r\n    'E',\r\n    'F',\r\n    'G',\r\n    'H',\r\n    'I',\r\n    'J',\r\n    'K',\r\n    'L',\r\n    'M',\r\n    'N',\r\n    'O',\r\n    'P',\r\n    'Q',\r\n    'R',\r\n    'S',\r\n    'T',\r\n    'U',\r\n    'V',\r\n    'W',\r\n    'X',\r\n    'Y',\r\n    'Z',\r\n  ],\r\n  _l2nFill: 0,\r\n  _l2n: {},\r\n  _n2l: [],\r\n  _level(n) {\r\n    if (n <= 26) {\r\n      return 1;\r\n    }\r\n    if (n <= 26 * 26) {\r\n      return 2;\r\n    }\r\n    return 3;\r\n  },\r\n  _fill(level) {\r\n    let c;\r\n    let v;\r\n    let l1;\r\n    let l2;\r\n    let l3;\r\n    let n = 1;\r\n    if (level >= 4) {\r\n      throw new Error('Out of bounds. Excel supports columns from 1 to 16384');\r\n    }\r\n    if (this._l2nFill < 1 && level >= 1) {\r\n      while (n <= 26) {\r\n        c = this._dictionary[n - 1];\r\n        this._n2l[n] = c;\r\n        this._l2n[c] = n;\r\n        n++;\r\n      }\r\n      this._l2nFill = 1;\r\n    }\r\n    if (this._l2nFill < 2 && level >= 2) {\r\n      n = 27;\r\n      while (n <= 26 + (26 * 26)) {\r\n        v = n - (26 + 1);\r\n        l1 = v % 26;\r\n        l2 = Math.floor(v / 26);\r\n        c = this._dictionary[l2] + this._dictionary[l1];\r\n        this._n2l[n] = c;\r\n        this._l2n[c] = n;\r\n        n++;\r\n      }\r\n      this._l2nFill = 2;\r\n    }\r\n    if (this._l2nFill < 3 && level >= 3) {\r\n      n = 26 + (26 * 26) + 1;\r\n      while (n <= 16384) {\r\n        v = n - ((26 * 26) + 26 + 1);\r\n        l1 = v % 26;\r\n        l2 = Math.floor(v / 26) % 26;\r\n        l3 = Math.floor(v / (26 * 26));\r\n        c = this._dictionary[l3] + this._dictionary[l2] + this._dictionary[l1];\r\n        this._n2l[n] = c;\r\n        this._l2n[c] = n;\r\n        n++;\r\n      }\r\n      this._l2nFill = 3;\r\n    }\r\n  },\r\n  l2n(l) {\r\n    if (!this._l2n[l]) {\r\n      this._fill(l.length);\r\n    }\r\n    if (!this._l2n[l]) {\r\n      throw new Error(`Out of bounds. Invalid column letter: ${l}`);\r\n    }\r\n    return this._l2n[l];\r\n  },\r\n  n2l(n) {\r\n    if (n < 1 || n > 16384) {\r\n      throw new Error(`${n} is out of bounds. Excel supports columns from 1 to 16384`);\r\n    }\r\n    if (!this._n2l[n]) {\r\n      this._fill(this._level(n));\r\n    }\r\n    return this._n2l[n];\r\n  },\r\n\r\n  // =========================================================================\r\n  // Address processing\r\n  _hash: {},\r\n\r\n  // check if value looks like an address\r\n  validateAddress(value) {\r\n    if (!addressRegex.test(value)) {\r\n      throw new Error(`Invalid Address: ${value}`);\r\n    }\r\n    return true;\r\n  },\r\n\r\n  // convert address string into structure\r\n  decodeAddress(value) {\r\n    const addr = value.length < 5 && this._hash[value];\r\n    if (addr) {\r\n      return addr;\r\n    }\r\n    let hasCol = false;\r\n    let col = '';\r\n    let colNumber = 0;\r\n    let hasRow = false;\r\n    let row = '';\r\n    let rowNumber = 0;\r\n    for (let i = 0, char; i < value.length; i++) {\r\n      char = value.charCodeAt(i);\r\n      // col should before row\r\n      if (!hasRow && char >= 65 && char <= 90) {\r\n        // 65 = 'A'.charCodeAt(0)\r\n        // 90 = 'Z'.charCodeAt(0)\r\n        hasCol = true;\r\n        col += value[i];\r\n        // colNumber starts from 1\r\n        colNumber = (colNumber * 26) + char - 64;\r\n      } else if (char >= 48 && char <= 57) {\r\n        // 48 = '0'.charCodeAt(0)\r\n        // 57 = '9'.charCodeAt(0)\r\n        hasRow = true;\r\n        row += value[i];\r\n        // rowNumber starts from 0\r\n        rowNumber = (rowNumber * 10) + char - 48;\r\n      } else if (hasRow && hasCol && char !== 36) {\r\n        // 36 = '$'.charCodeAt(0)\r\n        break;\r\n      }\r\n    }\r\n    if (!hasCol) {\r\n      colNumber = undefined;\r\n    } else if (colNumber > 16384) {\r\n      throw new Error(`Out of bounds. Invalid column letter: ${col}`);\r\n    }\r\n    if (!hasRow) {\r\n      rowNumber = undefined;\r\n    }\r\n\r\n    // in case $row$col\r\n    value = col + row;\r\n\r\n    const address = {\r\n      address: value,\r\n      col: colNumber,\r\n      row: rowNumber,\r\n      $col$row: `$${col}$${row}`,\r\n    };\r\n\r\n    // mem fix - cache only the tl 100x100 square\r\n    if (colNumber <= 100 && rowNumber <= 100) {\r\n      this._hash[value] = address;\r\n      this._hash[address.$col$row] = address;\r\n    }\r\n\r\n    return address;\r\n  },\r\n\r\n  // convert r,c into structure (if only 1 arg, assume r is address string)\r\n  getAddress(r, c) {\r\n    if (c) {\r\n      const address = this.n2l(c) + r;\r\n      return this.decodeAddress(address);\r\n    }\r\n    return this.decodeAddress(r);\r\n  },\r\n\r\n  // convert [address], [tl:br] into address structures\r\n  decode(value) {\r\n    const parts = value.split(':');\r\n    if (parts.length === 2) {\r\n      const tl = this.decodeAddress(parts[0]);\r\n      const br = this.decodeAddress(parts[1]);\r\n      const result = {\r\n        top: Math.min(tl.row, br.row),\r\n        left: Math.min(tl.col, br.col),\r\n        bottom: Math.max(tl.row, br.row),\r\n        right: Math.max(tl.col, br.col),\r\n      };\r\n      // reconstruct tl, br and dimensions\r\n      result.tl = this.n2l(result.left) + result.top;\r\n      result.br = this.n2l(result.right) + result.bottom;\r\n      result.dimensions = `${result.tl}:${result.br}`;\r\n      return result;\r\n    }\r\n    return this.decodeAddress(value);\r\n  },\r\n\r\n  // convert [sheetName!][$]col[$]row[[$]col[$]row] into address or range structures\r\n  decodeEx(value) {\r\n    const groups = value.match(/(?:(?:(?:'((?:[^']|'')*)')|([^'^ !]*))!)?(.*)/);\r\n\r\n    const sheetName = groups[1] || groups[2]; // Qouted and unqouted groups\r\n    const reference = groups[3]; // Remaining address\r\n\r\n    const parts = reference.split(':');\r\n    if (parts.length > 1) {\r\n      let tl = this.decodeAddress(parts[0]);\r\n      let br = this.decodeAddress(parts[1]);\r\n      const top = Math.min(tl.row, br.row);\r\n      const left = Math.min(tl.col, br.col);\r\n      const bottom = Math.max(tl.row, br.row);\r\n      const right = Math.max(tl.col, br.col);\r\n\r\n      tl = this.n2l(left) + top;\r\n      br = this.n2l(right) + bottom;\r\n\r\n      return {\r\n        top,\r\n        left,\r\n        bottom,\r\n        right,\r\n        sheetName,\r\n        tl: {address: tl, col: left, row: top, $col$row: `$${this.n2l(left)}$${top}`, sheetName},\r\n        br: {\r\n          address: br,\r\n          col: right,\r\n          row: bottom,\r\n          $col$row: `$${this.n2l(right)}$${bottom}`,\r\n          sheetName,\r\n        },\r\n        dimensions: `${tl}:${br}`,\r\n      };\r\n    }\r\n    if (reference.startsWith('#')) {\r\n      return sheetName ? {sheetName, error: reference} : {error: reference};\r\n    }\r\n\r\n    const address = this.decodeAddress(reference);\r\n    return sheetName ? {sheetName, ...address} : address;\r\n  },\r\n\r\n  // convert row,col into address string\r\n  encodeAddress(row, col) {\r\n    return colCache.n2l(col) + row;\r\n  },\r\n\r\n  // convert row,col into string address or t,l,b,r into range\r\n  encode() {\r\n    switch (arguments.length) {\r\n      case 2:\r\n        return colCache.encodeAddress(arguments[0], arguments[1]);\r\n      case 4:\r\n        return `${colCache.encodeAddress(arguments[0], arguments[1])}:${colCache.encodeAddress(\r\n          arguments[2],\r\n          arguments[3]\r\n        )}`;\r\n      default:\r\n        throw new Error('Can only encode with 2 or 4 arguments');\r\n    }\r\n  },\r\n\r\n  // return true if address is contained within range\r\n  inRange(range, address) {\r\n    const [left, top, , right, bottom] = range;\r\n    const [col, row] = address;\r\n    return col >= left && col <= right && row >= top && row <= bottom;\r\n  },\r\n};\r\n\r\nmodule.exports = colCache;\r\n"]},"metadata":{},"sourceType":"script"}